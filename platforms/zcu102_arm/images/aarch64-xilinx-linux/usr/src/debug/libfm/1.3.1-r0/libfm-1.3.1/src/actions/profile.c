/* profile.c generated by valac 0.34.7, the Vala compiler
 * generated from profile.vala, do not modify */

/*      profile.vala*/
/*      */
/*      Copyright 2011 Hong Jen Yee (PCMan) <pcman.tw@pcman.tw@gmail.com>*/
/*      */
/*      This program is free software; you can redistribute it and/or modify*/
/*      it under the terms of the GNU General Public License as published by*/
/*      the Free Software Foundation; either version 2 of the License, or*/
/*      (at your option) any later version.*/
/*      */
/*      This program is distributed in the hope that it will be useful,*/
/*      but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*      GNU General Public License for more details.*/
/*      */
/*      You should have received a copy of the GNU General Public License*/
/*      along with this program; if not, write to the Free Software*/
/*      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,*/
/*      MA 02110-1301, USA.*/
/*      */
/*      */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <fm-file-info.h>
#include <stdio.h>


#define FM_TYPE_FILE_ACTION_EXEC_MODE (fm_file_action_exec_mode_get_type ())
typedef struct _FmFileActionProfile FmFileActionProfile;
typedef struct _FmFileActionCondition FmFileActionCondition;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _fm_file_action_condition_free0(var) ((var == NULL) ? NULL : (var = (fm_file_action_condition_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

typedef enum  {
	FM_FILE_ACTION_EXEC_MODE_NORMAL,
	FM_FILE_ACTION_EXEC_MODE_TERMINAL,
	FM_FILE_ACTION_EXEC_MODE_EMBEDDED,
	FM_FILE_ACTION_EXEC_MODE_DISPLAY_OUTPUT
} FmFileActionExecMode;

struct _FmFileActionProfile {
	gchar* id;
	gchar* name;
	gchar* exec;
	gchar* path;
	FmFileActionExecMode exec_mode;
	gboolean startup_notify;
	gchar* startup_wm_class;
	gchar* exec_as;
	FmFileActionCondition* condition;
};



GType fm_file_action_exec_mode_get_type (void) G_GNUC_CONST;
void fm_file_action_profile_free (FmFileActionProfile* self);
void fm_file_action_condition_free (FmFileActionCondition* self);
static void fm_file_action_profile_instance_init (FmFileActionProfile * self);
FmFileActionProfile* fm_file_action_profile_new (GKeyFile* kf, const gchar* profile_name);
gchar* utils_key_file_get_string (GKeyFile* kf, const gchar* group, const gchar* key, const gchar* def_val);
gboolean utils_key_file_get_bool (GKeyFile* kf, const gchar* group, const gchar* key, gboolean def_val);
FmFileActionCondition* fm_file_action_condition_new (GKeyFile* kf, const gchar* group);
static gboolean fm_file_action_profile_launch_once (FmFileActionProfile* self, GAppLaunchContext* ctx, FmFileInfo* first_file, GList* files, gchar** output);
gchar* fm_file_action_parameters_expand (const gchar* templ, GList* files, gboolean for_display, FmFileInfo* first_file);
gboolean fm_file_action_profile_launch (FmFileActionProfile* self, GAppLaunchContext* ctx, GList* files, gchar** output);
gboolean fm_file_action_parameters_is_plural (const gchar* exec);
gboolean fm_file_action_profile_match (FmFileActionProfile* self, GList* files);
gboolean fm_file_action_condition_match (FmFileActionCondition* self, GList* files);


GType fm_file_action_exec_mode_get_type (void) {
	static volatile gsize fm_file_action_exec_mode_type_id__volatile = 0;
	if (g_once_init_enter (&fm_file_action_exec_mode_type_id__volatile)) {
		static const GEnumValue values[] = {{FM_FILE_ACTION_EXEC_MODE_NORMAL, "FM_FILE_ACTION_EXEC_MODE_NORMAL", "normal"}, {FM_FILE_ACTION_EXEC_MODE_TERMINAL, "FM_FILE_ACTION_EXEC_MODE_TERMINAL", "terminal"}, {FM_FILE_ACTION_EXEC_MODE_EMBEDDED, "FM_FILE_ACTION_EXEC_MODE_EMBEDDED", "embedded"}, {FM_FILE_ACTION_EXEC_MODE_DISPLAY_OUTPUT, "FM_FILE_ACTION_EXEC_MODE_DISPLAY_OUTPUT", "display-output"}, {0, NULL, NULL}};
		GType fm_file_action_exec_mode_type_id;
		fm_file_action_exec_mode_type_id = g_enum_register_static ("FmFileActionExecMode", values);
		g_once_init_leave (&fm_file_action_exec_mode_type_id__volatile, fm_file_action_exec_mode_type_id);
	}
	return fm_file_action_exec_mode_type_id__volatile;
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


FmFileActionProfile* fm_file_action_profile_new (GKeyFile* kf, const gchar* profile_name) {
	FmFileActionProfile* self;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* group_name = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	GKeyFile* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	GKeyFile* _tmp8_ = NULL;
	const gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	GKeyFile* _tmp11_ = NULL;
	const gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	gchar* s = NULL;
	GKeyFile* _tmp14_ = NULL;
	const gchar* _tmp15_ = NULL;
	gchar* _tmp16_ = NULL;
	const gchar* _tmp17_ = NULL;
	GKeyFile* _tmp21_ = NULL;
	const gchar* _tmp22_ = NULL;
	gboolean _tmp23_ = FALSE;
	GKeyFile* _tmp24_ = NULL;
	const gchar* _tmp25_ = NULL;
	gchar* _tmp26_ = NULL;
	GKeyFile* _tmp27_ = NULL;
	const gchar* _tmp28_ = NULL;
	gchar* _tmp29_ = NULL;
	GKeyFile* _tmp30_ = NULL;
	const gchar* _tmp31_ = NULL;
	FmFileActionCondition* _tmp32_ = NULL;
	g_return_val_if_fail (kf != NULL, NULL);
	g_return_val_if_fail (profile_name != NULL, NULL);
	self = g_slice_new0 (FmFileActionProfile);
	fm_file_action_profile_instance_init (self);
	_tmp0_ = profile_name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->id);
	self->id = _tmp1_;
	_tmp2_ = profile_name;
	_tmp3_ = string_to_string (_tmp2_);
	_tmp4_ = g_strconcat ("X-Action-Profile ", _tmp3_, NULL);
	group_name = _tmp4_;
	_tmp5_ = kf;
	_tmp6_ = group_name;
	_tmp7_ = utils_key_file_get_string (_tmp5_, _tmp6_, "Name", NULL);
	_g_free0 (self->name);
	self->name = _tmp7_;
	_tmp8_ = kf;
	_tmp9_ = group_name;
	_tmp10_ = utils_key_file_get_string (_tmp8_, _tmp9_, "Exec", NULL);
	_g_free0 (self->exec);
	self->exec = _tmp10_;
	_tmp11_ = kf;
	_tmp12_ = group_name;
	_tmp13_ = utils_key_file_get_string (_tmp11_, _tmp12_, "Path", NULL);
	_g_free0 (self->path);
	self->path = _tmp13_;
	_tmp14_ = kf;
	_tmp15_ = group_name;
	_tmp16_ = utils_key_file_get_string (_tmp14_, _tmp15_, "ExecutionMode", NULL);
	s = _tmp16_;
	_tmp17_ = s;
	if (g_strcmp0 (_tmp17_, "Normal") == 0) {
		self->exec_mode = FM_FILE_ACTION_EXEC_MODE_NORMAL;
	} else {
		const gchar* _tmp18_ = NULL;
		_tmp18_ = s;
		if (g_strcmp0 (_tmp18_, "Terminal") == 0) {
			self->exec_mode = FM_FILE_ACTION_EXEC_MODE_TERMINAL;
		} else {
			const gchar* _tmp19_ = NULL;
			_tmp19_ = s;
			if (g_strcmp0 (_tmp19_, "Embedded") == 0) {
				self->exec_mode = FM_FILE_ACTION_EXEC_MODE_EMBEDDED;
			} else {
				const gchar* _tmp20_ = NULL;
				_tmp20_ = s;
				if (g_strcmp0 (_tmp20_, "DisplayOutput") == 0) {
					self->exec_mode = FM_FILE_ACTION_EXEC_MODE_DISPLAY_OUTPUT;
				} else {
					self->exec_mode = FM_FILE_ACTION_EXEC_MODE_NORMAL;
				}
			}
		}
	}
	_tmp21_ = kf;
	_tmp22_ = group_name;
	_tmp23_ = utils_key_file_get_bool (_tmp21_, _tmp22_, "StartupNotify", FALSE);
	self->startup_notify = _tmp23_;
	_tmp24_ = kf;
	_tmp25_ = group_name;
	_tmp26_ = utils_key_file_get_string (_tmp24_, _tmp25_, "StartupWMClass", NULL);
	_g_free0 (self->startup_wm_class);
	self->startup_wm_class = _tmp26_;
	_tmp27_ = kf;
	_tmp28_ = group_name;
	_tmp29_ = utils_key_file_get_string (_tmp27_, _tmp28_, "ExecuteAs", NULL);
	_g_free0 (self->exec_as);
	self->exec_as = _tmp29_;
	_tmp30_ = kf;
	_tmp31_ = group_name;
	_tmp32_ = fm_file_action_condition_new (_tmp30_, _tmp31_);
	_fm_file_action_condition_free0 (self->condition);
	self->condition = _tmp32_;
	_g_free0 (s);
	_g_free0 (group_name);
	return self;
}


static gboolean fm_file_action_profile_launch_once (FmFileActionProfile* self, GAppLaunchContext* ctx, FmFileInfo* first_file, GList* files, gchar** output) {
	gchar* _vala_output = NULL;
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	gchar* exec_cmd = NULL;
	const gchar* _tmp1_ = NULL;
	GList* _tmp2_ = NULL;
	FmFileInfo* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	FILE* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	gboolean ret = FALSE;
	FmFileActionExecMode _tmp8_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (ctx != NULL, FALSE);
	_tmp0_ = self->exec;
	if (_tmp0_ == NULL) {
		result = FALSE;
		if (output) {
			*output = _vala_output;
		} else {
			_g_free0 (_vala_output);
		}
		return result;
	}
	_tmp1_ = self->exec;
	_tmp2_ = files;
	_tmp3_ = first_file;
	_tmp4_ = fm_file_action_parameters_expand (_tmp1_, _tmp2_, FALSE, _tmp3_);
	exec_cmd = _tmp4_;
	_tmp5_ = stdout;
	_tmp6_ = self->id;
	_tmp7_ = exec_cmd;
	fprintf (_tmp5_, "Profile: %s\nlaunch command: %s\n\n", _tmp6_, _tmp7_);
	ret = FALSE;
	_tmp8_ = self->exec_mode;
	if (_tmp8_ == FM_FILE_ACTION_EXEC_MODE_DISPLAY_OUTPUT) {
		{
			gint exit_status = 0;
			gboolean _tmp9_ = FALSE;
			const gchar* _tmp10_ = NULL;
			gchar* _tmp11_ = NULL;
			gint _tmp12_ = 0;
			gboolean _tmp13_ = FALSE;
			gboolean _tmp15_ = FALSE;
			_tmp10_ = exec_cmd;
			_tmp13_ = g_spawn_command_line_sync (_tmp10_, &_tmp11_, NULL, &_tmp12_, &_inner_error_);
			_g_free0 (_vala_output);
			_vala_output = _tmp11_;
			exit_status = _tmp12_;
			_tmp9_ = _tmp13_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				gboolean _tmp14_ = FALSE;
				if (_inner_error_->domain == G_SPAWN_ERROR) {
					goto __catch4_g_spawn_error;
				}
				_g_free0 (exec_cmd);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return _tmp14_;
			}
			ret = _tmp9_;
			_tmp15_ = ret;
			if (_tmp15_) {
				gint _tmp16_ = 0;
				_tmp16_ = exit_status;
				ret = _tmp16_ == 0;
			}
		}
		goto __finally4;
		__catch4_g_spawn_error:
		{
			GError* err = NULL;
			err = _inner_error_;
			_inner_error_ = NULL;
			_g_error_free0 (err);
		}
		__finally4:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			gboolean _tmp17_ = FALSE;
			_g_free0 (exec_cmd);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return _tmp17_;
		}
	} else {
		{
			gboolean _tmp18_ = FALSE;
			const gchar* _tmp19_ = NULL;
			gboolean _tmp20_ = FALSE;
			_tmp19_ = exec_cmd;
			_tmp20_ = g_spawn_command_line_async (_tmp19_, &_inner_error_);
			_tmp18_ = _tmp20_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				gboolean _tmp21_ = FALSE;
				if (_inner_error_->domain == G_SPAWN_ERROR) {
					goto __catch5_g_spawn_error;
				}
				_g_free0 (exec_cmd);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return _tmp21_;
			}
			ret = _tmp18_;
		}
		goto __finally5;
		__catch5_g_spawn_error:
		{
			GError* err = NULL;
			err = _inner_error_;
			_inner_error_ = NULL;
			_g_error_free0 (err);
		}
		__finally5:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			gboolean _tmp22_ = FALSE;
			_g_free0 (exec_cmd);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return _tmp22_;
		}
	}
	result = ret;
	_g_free0 (exec_cmd);
	if (output) {
		*output = _vala_output;
	} else {
		_g_free0 (_vala_output);
	}
	return result;
}


gboolean fm_file_action_profile_launch (FmFileActionProfile* self, GAppLaunchContext* ctx, GList* files, gchar** output) {
	gchar* _vala_output = NULL;
	gboolean result = FALSE;
	gboolean plural_form = FALSE;
	const gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean ret = FALSE;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (ctx != NULL, FALSE);
	_tmp0_ = self->exec;
	_tmp1_ = fm_file_action_parameters_is_plural (_tmp0_);
	plural_form = _tmp1_;
	_tmp2_ = plural_form;
	if (_tmp2_) {
		GAppLaunchContext* _tmp3_ = NULL;
		GList* _tmp4_ = NULL;
		GList* _tmp5_ = NULL;
		gconstpointer _tmp6_ = NULL;
		GList* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gboolean _tmp9_ = FALSE;
		_tmp3_ = ctx;
		_tmp4_ = files;
		_tmp5_ = g_list_first (_tmp4_);
		_tmp6_ = _tmp5_->data;
		_tmp7_ = files;
		_tmp9_ = fm_file_action_profile_launch_once (self, _tmp3_, (FmFileInfo*) _tmp6_, _tmp7_, &_tmp8_);
		_g_free0 (_vala_output);
		_vala_output = _tmp8_;
		ret = _tmp9_;
	} else {
		GString* all_output = NULL;
		const gchar* _tmp10_ = NULL;
		GList* _tmp12_ = NULL;
		gboolean _tmp23_ = FALSE;
		GString* _tmp24_ = NULL;
		all_output = NULL;
		_tmp10_ = _vala_output;
		if (_tmp10_ != NULL) {
			GString* _tmp11_ = NULL;
			_tmp11_ = g_string_new ("");
			_g_string_free0 (all_output);
			all_output = _tmp11_;
		}
		_tmp12_ = files;
		{
			GList* fi_collection = NULL;
			GList* fi_it = NULL;
			fi_collection = _tmp12_;
			for (fi_it = fi_collection; fi_it != NULL; fi_it = fi_it->next) {
				FmFileInfo* fi = NULL;
				fi = (FmFileInfo*) fi_it->data;
				{
					gchar* one_output = NULL;
					GAppLaunchContext* _tmp13_ = NULL;
					FmFileInfo* _tmp14_ = NULL;
					GList* _tmp15_ = NULL;
					gchar* _tmp16_ = NULL;
					gboolean _tmp17_ = FALSE;
					GString* _tmp18_ = NULL;
					_tmp13_ = ctx;
					_tmp14_ = fi;
					_tmp15_ = files;
					fm_file_action_profile_launch_once (self, _tmp13_, _tmp14_, _tmp15_, &_tmp16_);
					_g_free0 (one_output);
					one_output = _tmp16_;
					_tmp18_ = all_output;
					if (_tmp18_ != NULL) {
						const gchar* _tmp19_ = NULL;
						_tmp19_ = one_output;
						_tmp17_ = _tmp19_ != NULL;
					} else {
						_tmp17_ = FALSE;
					}
					if (_tmp17_) {
						GString* _tmp20_ = NULL;
						const gchar* _tmp21_ = NULL;
						GString* _tmp22_ = NULL;
						_tmp20_ = all_output;
						_tmp21_ = one_output;
						g_string_append (_tmp20_, _tmp21_);
						_tmp22_ = all_output;
						g_string_append (_tmp22_, "\n");
					}
					_g_free0 (one_output);
				}
			}
		}
		_tmp24_ = all_output;
		if (_tmp24_ != NULL) {
			const gchar* _tmp25_ = NULL;
			_tmp25_ = _vala_output;
			_tmp23_ = _tmp25_ != NULL;
		} else {
			_tmp23_ = FALSE;
		}
		if (_tmp23_) {
			GString* _tmp26_ = NULL;
			gchar* _tmp27_ = NULL;
			_tmp26_ = all_output;
			_tmp27_ = _tmp26_->str;
			_tmp26_->str = NULL;
			_g_free0 (_vala_output);
			_vala_output = _tmp27_;
		}
		ret = TRUE;
		_g_string_free0 (all_output);
	}
	result = ret;
	if (output) {
		*output = _vala_output;
	} else {
		_g_free0 (_vala_output);
	}
	return result;
}


gboolean fm_file_action_profile_match (FmFileActionProfile* self, GList* files) {
	gboolean result = FALSE;
	FILE* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	FmFileActionCondition* _tmp2_ = NULL;
	GList* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = stdout;
	_tmp1_ = self->id;
	fprintf (_tmp0_, "  match profile: %s\n", _tmp1_);
	_tmp2_ = self->condition;
	_tmp3_ = files;
	_tmp4_ = fm_file_action_condition_match (_tmp2_, _tmp3_);
	result = _tmp4_;
	return result;
}


static void fm_file_action_profile_instance_init (FmFileActionProfile * self) {
}


void fm_file_action_profile_free (FmFileActionProfile* self) {
	_g_free0 (self->id);
	_g_free0 (self->name);
	_g_free0 (self->exec);
	_g_free0 (self->path);
	_g_free0 (self->startup_wm_class);
	_g_free0 (self->exec_as);
	_fm_file_action_condition_free0 (self->condition);
	g_slice_free (FmFileActionProfile, self);
}



