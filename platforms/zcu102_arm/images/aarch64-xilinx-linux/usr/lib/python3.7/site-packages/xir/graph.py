"""
 Copyright 2019 Xilinx Inc.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 
     http://www.apache.org/licenses/LICENSE-2.0
 
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
"""

import sys
from pathlib import Path
from typing import Any, Dict, List, NoReturn, Optional

import numpy as np

from op import Op
from subgraph import Subgraph
from tensor import NUMPY_DTYPE_TO_XIR_DTYPE, XIR_DTYPE_TO_NUMPY_DTYPE
from xir.wrapper import *


class Graph(object):
    def __init__(self, name: str) -> NoReturn:
        # create an XirGraph object
        self.__xir_graph: XirGraph = XirGraph.create(name)
        self.__xir_attrs: XirAttrs = self.__xir_graph.get_attrs()
        # key: name of attribute, value: type string of attribute
        self.__attrs_info_dict: Dict[str, str] = {}
        # subgraph
        self.__subgraph: Subgraph = None

    @property
    def metadata(self) -> XirGraph:
        """Get metadata of Graph.
        
        Returns
        -------
        XirGraph
            XirGraph object.
        """
        return self.__xir_graph

    @metadata.setter
    def metadata(self, xir_graph: XirGraph) -> NoReturn:
        """Set metadata of Graph.
        
        Parameters
        ----------
        xir_graph : XirGraph
            XirGraph object
        """
        # reset meta data
        self.__xir_graph = xir_graph

    def get_name(self) -> str:
        """
        Get name of graph.

        Returns:
            name of graph
        """
        return self.__xir_graph.get_name()

    def create_const_op(self, name: str, tensor: np.ndarray) -> Op:
        """Create and add a const a op on graph. 'op_type' is set 'const' for const op, while 'data' for input data op.
        
        Parameters
        ----------
        name : str
            name of const op to be created.
        tensor : np.ndarray
            numpy ndarray object
        
        Returns
        -------
        Op
            Op object.
        """
        assert tensor is not None, "'tensor' should not be None."
        return self.create_op(name, "const", tensor)

    def create_op(
        self,
        name: str,
        kind: str,
        tensor: Optional[np.ndarray] = None,
        attrs: Optional[Dict[str, Any]] = None,
        input_ops: Optional[Dict[str, List[Op]]] = None,
        **kwargs,
    ) -> Op:
        """Create and add a non-const op on graph.
        
        Parameters
        ----------
        name : str
            name of op to be created.
        kind : str
            kind: type of op to be created.
        tensor : Optional[np.ndarray], optional
            output tensor, by default None.
        attrs : Optional[Dict[str, Any]], optional
            attributes attached with op to be created, by default None.
        input_ops : Optional[Dict[str, List[Op]]], optional
            input ops of op to be created, by default None.
        
        Returns
        -------
        Op
            Op object.
        """
        assert name is not None, "'name' should not be None."
        assert kind is not None, "'kind' should not be None."
        kind = kind.lower()
        if kind == "const":
            assert tensor is not None, "'tensor' should not be None."

        if attrs is not None:
            assert isinstance(attrs, Dict), "'attrs' should be of Dict type."
            assert len(attrs) > 0, "'attrs' should contain one or more items."
        if input_ops is not None:
            assert isinstance(input_ops, Dict), "'input_ops' should be of Dict type."
            assert len(input_ops) > 0, "'input_ops' should contain one or more items."

        # attrs
        xir_attrs: XirAttrs = XirAttrs.create()
        ext_attrs_info_dict = {}
        if attrs is not None and len(attrs) > 0:
            attrs_info_dict = XirOpHelper.get_attrs_types(kind)
            for attr_name, value in attrs.items():
                # get dtype info of attribute
                dtype = attrs_info_dict.get(attr_name)
                if dtype:
                    getattr(xir_attrs, f"set_attr_{dtype}")(attr_name, value)
                else:
                    dtype = value.__class__.__name__
                    if dtype == "list":
                        if len(value) == 0:
                            return
                        item_dtype = value[0].__class__.__name__
                        # check dtype consistency of each item in list
                        for item in value:
                            assert (
                                item.__class__.__name__ == item_dtype
                            ), f"[ERROR] inconsistent item dtype in list: {value}"
                        if item_dtype == "int":
                            dtype = "vint"
                        elif item_dtype == "float":
                            dtype = "vfloat"
                        elif item_dtype == "str":
                            dtype = "vstr"
                        else:
                            raise TypeError(
                                f"[ERROR] Unsupported item type in list: {value}."
                            )
                    elif dtype == "dict":
                        if len(value) == 0:
                            return
                        key_dtype, val_dtype = None, None
                        for key, val in value.items():
                            if key_dtype is None or val_dtype is None:
                                key_dtype = key.__class__.__name__
                                val_dtype = val.__class__.__name__
                                assert (
                                    key_dtype == "str"
                                ), "[ERROR] the type of key of the attr value should be 'str'."
                                assert (
                                    val_dtype == "str"
                                ), "[ERROR] the type of value of the attr value should be 'str' or 'int'."
                                dtype = "dict_" + val_dtype
                            assert (
                                key.__class__.__name__ == key_dtype
                            ), "[ERROR] the type of key of the attr value should be 'str'."
                            assert (
                                val.__class__.__name__ == val_dtype
                            ), "[ERROR] the type of value of the attr value should be 'str'."

                    try:
                        if (
                            attr_name not in ext_attrs_info_dict
                            or dtype != ext_attrs_info_dict[attr_name]
                        ):
                            ext_attrs_info_dict[attr_name] = dtype
                        getattr(xir_attrs, f"set_attr_{dtype}")(attr_name, value)
                    except:
                        raise ValueError(
                            f"[Error] Unsupported data type: attr_name={attr_name}, data_type={dtype}"
                        )
        elif kind == "const":
            XirAttrsHelper.set_const_data(xir_attrs, tensor)

        # input_ops
        op_dict = xir_op_dict()
        if input_ops is not None:
            for key, value in input_ops.items():
                op_dict[key] = xir_op_list([x.metadata for x in value])

        # output tensor
        if tensor is not None:
            dtype: XirDataType = NUMPY_DTYPE_TO_XIR_DTYPE.get(tensor.dtype.name)
            shape: List[int] = list(tensor.shape)
            # create tensor with specified name, shape and data type
            out_tensor = XirTensorHelper.create_tensor(name, shape, dtype)
        elif "dtype" in kwargs:
            dtype: XirDataType = NUMPY_DTYPE_TO_XIR_DTYPE.get(kwargs["dtype"].name)
            # create tensor with specified name, shape and data type
            out_tensor = XirTensorHelper.create_tensor(name, [1, 1, 1, 1], dtype)
        else:
            # create tensor with specified name, shape and data type
            out_tensor = XirTensorHelper.create_tensor(
                name, [1, 1, 1, 1], XirDataType.FLOAT32
            )

        xir_op: XirOp = XirGraphHelper.create_op(
            self.__xir_graph, name, kind, xir_attrs, op_dict, out_tensor
        )
        assert xir_op is not None, "Failed to create op."

        # create Op object to hold xir_op
        op: Op = Op()
        # set op metadata
        op.metadata = xir_op
        op.graph = self
        return op

    def remove_op(self, op: Op):
        """
        Remove an Op instance from graph.

        Parameters:
            op: instance of Op to be removed from graph.
        """
        return self.__xir_graph.remove_op(op.metadata)

    def get_op_num(self) -> int:
        """
        Returns the number of ops.
        """
        return self.__xir_graph.get_op_num()

    def get_op(self, name: str) -> Optional[Op]:
        """
        Get an Op object by its name.

        Parameters:
            name: name of Op object.

        Returns:
            Op object.
        """
        xir_op = self.__xir_graph.get_op(name)
        op = Op()
        op.metadata = xir_op
        op.graph = self
        return op

    def get_ops(self) -> List[Op]:
        """
        Returns ops.
        """
        xir_ops: List[XirOp] = self.__xir_graph.get_ops()
        ops: List[Op] = []
        if len(xir_ops) > 0:
            for xir_op in xir_ops:
                op = Op()
                op.metadata = xir_op
                op.graph = self
                ops.append(op)
        return ops

    def topsort(self) -> List[Op]:
        """Sort ops on graph in topological ordering.
        
        Returns
        -------
        List[Op]
            list of ops in topological ordering.
        """
        xir_ops: List[XirOp] = self.__xir_graph.topsort()
        ops: List[Op] = []
        if len(xir_ops) > 0:
            for xir_op in xir_ops:
                op = Op()
                op.metadata = xir_op
                op.graph = self
                ops.append(op)
        return ops

    def dump(self, fname: Path) -> NoReturn:
        """Dump graph to a svg or png file.
        
        Parameters
        ----------
        fname : Path
            file name of target file.
        
        Returns
        -------
        NoReturn
            No return.
        """
        assert fname is not None, "'fname' should not be None."
        suffix = fname.suffix[1:].lower()
        if suffix not in ["png", "svg"]:
            suffix = "svg"
        self.__xir_graph.dump(str(fname.absolute()), suffix)

    def serialize(self, fname: Path) -> NoReturn:
        """Serialize graph to xmodel file.
        
        Parameters
        ----------
        fname : Path
            name of xmodel file.
        
        Returns
        -------
        NoReturn
            No return.
        """
        self.__xir_graph.serialize(str(fname.resolve()))

    def get_root_subgraph(self) -> Subgraph:
        """Get root subgraph
        
        Returns
        -------
        Subgraph
            root subgraph
        """
        root_xir_subgraph: XirSubgraph = self.__xir_graph.get_root_subgraph()
        # create wrapper class
        root_subgraph = Subgraph()
        root_subgraph.metadata = root_xir_subgraph
        return root_subgraph

    def get_leaf_subgraph(self) -> Subgraph:
        """Get leaf subgraph
        
        Returns
        -------
        Subgraph
            leaf subgraph
        """
        leaf_xir_subgraph: XirSubgraph = self.__xir_graph.get_leaf_subgraph()
        # create wrapper class
        leaf_subgraph = Subgraph()
        leaf_subgraph.metadata = leaf_xir_subgraph
        return leaf_subgraph

    def infer_shape(self) -> NoReturn:
        """Shape inference
        
        Returns
        -------
        NoReturn
            No return.
        """
        self.__xir_graph.infer_shape()

    @staticmethod
    def deserialize(fname: Path) -> "Graph":
        """Create Graph object from a xmodel file.
        
        Parameters
        ----------
        fname : Path
            name of xmodel file.
        
        Returns
        -------
        Graph
            Graph object.
        """
        xir_graph = XirGraph.deserialize(str(fname.resolve()))
        # create Graph object
        graph = Graph(xir_graph.get_name())
        # set metadata
        graph.metadata = xir_graph

        return graph

    def set_attr(self, name: str, value: Any) -> NoReturn:
        """set and update value of attribute.
        
        Parameters
        ----------
        name : str
            name of attributes.
        value : Any
            value of attribute.
        """
        assert name is not None, "'name' is not None."
        assert value is not None, "'value' should not be None."

        # get dtype info of attribute
        xir_attrs_types = XirGraphHelper.get_attrs_types(self.__xir_attrs)
        dtype = xir_attrs_types.get(name)
        if dtype:
            try:
                getattr(self.__xir_attrs, f"set_attr_{dtype}")(name, value)
                XirGraphHelper.set_graph_attrs(self.__xir_graph, self.__xir_attrs)
            except TypeError:
                sys.exit(
                    f"[ERROR] The type of new value of '{name}' attribute should be '{dtype}'"
                )
        else:
            dtype = value.__class__.__name__

            if dtype == "list":
                if len(value) == 0:
                    return
                item_dtype = value[0].__class__.__name__
                # check dtype consistency of each item in list
                for item in value:
                    assert (
                        item.__class__.__name__ == item_dtype
                    ), f"[ERROR] inconsistent item dtype in list: {value}"
                if item_dtype == "int":
                    dtype = "vint"
                elif item_dtype == "float":
                    dtype = "vfloat"
                elif item_dtype == "str":
                    dtype = "vstr"
                else:
                    raise TypeError(f"[ERROR] Unsupported item type in list: {value}.")
            elif dtype == "dict":
                if len(value) == 0:
                    return
                key_dtype, val_dtype = None, None
                for key, val in value.items():
                    if key_dtype is None or val_dtype is None:
                        key_dtype = key.__class__.__name__
                        val_dtype = val.__class__.__name__
                        assert (
                            key_dtype == "str"
                        ), "[ERROR] the type of key of the attr value should be 'str'."
                        assert val_dtype in [
                            "str",
                            "int",
                        ], "[ERROR] the type of value of the attr value should be 'str' or 'int'."
                        dtype = "dict_" + val_dtype
                    assert (
                        key.__class__.__name__ == key_dtype
                    ), "[ERROR] the type of key of the attr value should be 'str'."
                    assert (
                        val.__class__.__name__ == val_dtype
                    ), f"[ERROR] the type of value of the attr value should be {val_dtype}."

            try:
                getattr(self.__xir_attrs, f"set_attr_{dtype}")(name, value)
                XirGraphHelper.set_graph_attrs(self.__xir_graph, self.__xir_attrs)
            except:
                raise ValueError(
                    f"[Error] Unsupported data type: attr_name={name}, data_type={dtype}"
                )

    def get_attr(self, name: str) -> Optional[Any]:
        if not self.__xir_graph.has_attr(name):
            return None
        # get dtype info of attribute
        attrs_types_dict = XirGraphHelper.get_attrs_types(self.__xir_attrs)
        dtype = attrs_types_dict.get(name)
        assert (
            dtype is not None
        ), f"[ERROR] Not found the type info of '{name}' attribute."
        return getattr(self.__xir_attrs, f"get_attr_{dtype}")(name)

    def has_attr(self, name: str) -> bool:
        return self.__xir_graph.has_attr(name)

    def get_attrs(self) -> Dict[str, Any]:
        """Get all attributes.
        
        Returns
        -------
        Dict[str, Any]
            attibutes
        """
        res = {}
        attr_names = self.__xir_attrs.get_keys()
        for name in attr_names:
            res[name] = self.get_attr(name)
        return res

    def set_attrs(self, attrs: Dict[str, Any]) -> NoReturn:
        """Set multiple attributes.
        
        Parameters
        ----------
        attrs : Dict[str, Any]
            a group of attributes.
        """
        assert attrs is not None, "'attrs' should not be None."
        assert len(attrs) > 0, "'attrs' should contain one or more attributes."

        for name, value in attrs.items():
            self.set_attr(name, value)
