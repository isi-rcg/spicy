"""
 Copyright 2019 Xilinx Inc.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 
     http://www.apache.org/licenses/LICENSE-2.0
 
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
"""

from typing import Any, Dict, List, NoReturn, Optional
from tensor import Tensor
from xir.wrapper import *
from tensor import NUMPY_DTYPE_TO_XIR_DTYPE, XIR_DTYPE_TO_NUMPY_DTYPE
import numpy as np
import sys


class Op(object):
    def __init__(self) -> NoReturn:
        self.__xir_op: XirOp = None
        self.__xir_attrs: XirAttrs = None
        self.__graph: Graph = None

    def get_name(self) -> str:
        """Get op name
        
        Returns
        -------
        str
            name of Op instance.
        """
        return self.__xir_op.get_name()

    def get_type(self) -> str:
        """Get op types
        
        Returns
        -------
        str
            type of Op instance.
        """
        return self.__xir_op.get_type()

    def get_input_num(self) -> int:
        """
        Returns number of input ops.
        """
        return self.__xir_op.get_input_num()

    def get_input_num_by_name(self, name: str) -> int:
        """Get number of input ops by specified input name.
        
        Parameters
        ----------
        name : str
            kind of input op, such as "input" and "weight".
        
        Returns
        -------
        int
            number of input ops.
        """
        return self.__xir_op.get_input_num_by_name(name)

    def get_input_ops(self) -> List["Op"]:
        """Get all input ops.
        
        Returns
        -------
        List[Op]
            list of Op objects.
        """
        xir_input_ops: List[XirOp] = self.__xir_op.get_input_ops()
        assert xir_input_ops is not None
        ops = []
        for xir_op in xir_input_ops:
            op = Op()
            op.metadata = xir_op
            ops.append(op)
        return ops

    def get_input_ops_by_name(self, name: str) -> List["Op"]:
        """Get input ops with specific name.
        
        Parameters
        ----------
        name : str
            kind of input op, such as "input" and "weight".
        
        Returns
        -------
        List[Op]
            list of Op objects.
        """
        xir_input_ops: List[XirOp] = self.__xir_op.get_input_ops(name)
        assert xir_input_ops is not None
        assert len(xir_input_ops) > 0
        ops = []
        for xir_op in xir_input_ops:
            op = Op()
            op.metadata = xir_op
            ops.append(op)
        return ops

    def get_input_op(self, name: str, idx: int = 0) -> "Op":
        """Get input op by kind and index.
        
        Parameters
        ----------
        name : str
            kind of input op, such as "input" and "weight".
        idx : int, optional
            the ordering index, by default 0
        
        Returns
        -------
        Op
            list of Op objects.
        """
        xir_input_op: XirOp = self.__xir_op.get_input_op(name, idx)
        op = Op()
        op.metadata = xir_input_op
        return op

    def set_input_ops(self, name: str, ops: List["Op"]) -> NoReturn:
        """Set input ops with specified kind.
        
        Parameters
        ----------
        name : str
            kind of input ops, such as "input" and "weight".
        ops : List[Op]
            list of input Op objects.
        """
        assert name is not None, "'name' should not be None."
        assert ops is not None, "'ops' should not be None."
        assert len(ops) > 0, "'ops' should contain one or more Op objects."
        xir_ops = []
        for op in ops:
            xir_ops.append(op.metadata)
        self.__xir_op.set_input_ops(name, xir_ops)

    def replace_input_op(self, op_old: "Op", op_new: "Op") -> NoReturn:
        """Replace old Op object with new one.
        
        Parameters
        ----------
        op_old : Op
            old Op object.
        op_new : Op
            new Op object.
        """
        assert op_old is not None, "'op_old' should not be None."
        assert op_new is not None, "'op_new' should not be None."
        self.__xir_op.replace_input_op(op_old.metadata, op_new.metadata)

    def get_fanout_num(self) -> int:
        """Get number of fan-out Op objects.
        
        Returns
        -------
        int
            number of fan-out Op objects.
        """
        return self.__xir_op.get_fanout_num()

    def get_fanout_ops(self) -> List["Op"]:
        """Get fan-out Op objects.
        
        Returns
        -------
        List[Op]
            list of fan-out Op objects.
        """
        xir_ops = self.__xir_op.get_fanout_ops()
        assert xir_ops is not None
        assert len(xir_ops) > 0
        ops = []
        for xir_op in xir_ops:
            op = Op()
            op.metadata = xir_op
            ops.append(op)
        return ops

    def get_input_tensors(self) -> List[Tensor]:
        """Get input tensors.
        
        Returns
        -------
        List[Tensor]
            list of Tensor objects.
        """
        xir_tensors = self.__xir_op.get_input_tensors()
        tensors = []
        if len(xir_tensors) > 0:
            for xir_tensor in xir_tensors:
                tensor = Tensor()
                tensor.metadata = xir_tensor
                tensors.append(tensor)
        return tensors

    def get_input_tensors_by_name(self, name: str) -> List[Tensor]:
        """Get input tensors with specific argument name.
        
        Parameters
        ----------
        name : str
            argument name.
        
        Returns
        -------
        List[Tensor]
            list of Tensor objects.
        """
        xir_tensors = self.__xir_op.get_input_tensors_by_name(name)
        assert xir_tensors is not None
        assert len(xir_tensors) > 0
        tensors = []
        for xir_tensor in xir_tensors:
            tensor = Tensor()
            tensor.metadata = xir_tensor
            tensors.append(tensor)
        return tensors

    def get_input_tensor(self, name: str, idx: int = 0) -> Tensor:
        """Get input tensor by specific argument name and index.
        
        Parameters
        ----------
        name : str
            argument name.
        idx : int, optional
            index of input tensor, by default 0
        
        Returns
        -------
        Tensor
            input tensor.
        """
        xir_tensor = self.__xir_op.get_input_tensor(name, idx)
        assert xir_tensor is not None
        tensor = Tensor()
        tensor.metadata = xir_tensor
        return tensor

    def get_output_tensor(self) -> Tensor:
        """Get output tensor.
        
        Returns
        -------
        Tensor
            Tensor object.
        """
        xir_tensor = self.__xir_op.get_output_tensor()
        assert xir_tensor is not None
        tensor = Tensor()
        tensor.metadata = xir_tensor
        return tensor

    def get_attrs(self) -> Dict[str, Any]:
        """Get all attributes.
        
        Returns
        -------
        Dict[str, Any]
            attibutes
        """
        res = {}
        attr_names = self.__xir_attrs.get_keys()
        for name in attr_names:
            res[name] = self.get_attr(name)
        return res

    def set_attrs(self, attrs: Dict[str, Any]) -> NoReturn:
        """Set multiple attributes.
        
        Parameters
        ----------
        attrs : Dict[str, Any]
            a group of attributes.
        """
        assert attrs is not None, "'attrs' should not be None."
        assert len(attrs) > 0, "'attrs' should contain one or more attributes."

        for name, value in attrs.items():
            self.set_attr(name, value)

    def has_attr(self, name: str) -> bool:
        """Check if a specific attribute exists or not.
        
        Parameters
        ----------
        name : str
            name of attribute.
        
        Returns
        -------
        bool
            True, if the attribute exists; otherwise, False.
        """
        assert name is not None, "'name' should not be None."
        return self.__xir_attrs.has_attr(name)

    def get_attr(self, name: str) -> Optional[Any]:
        """Get attribute value.
        
        Parameters
        ----------
        name : str
            name of attribute.
        
        Returns
        -------
        Optional[Any]
            attribute value if name is found; otherwise, None.
        """
        assert name is not None, "'name' is not None."

        if not self.__xir_attrs.has_attr(name):
            return None

        if self.get_type() == "const":
            if name == "data":
                tensor = self.get_output_tensor()
                return XirAttrsHelper.get_const_data(
                    self.__xir_attrs,
                    NUMPY_DTYPE_TO_XIR_DTYPE[tensor.dtype],
                    tensor.shape,
                )
            else:
                raise ValueError(
                    f"[Error] Unsupported attribute in 'const' op: attr_name={name}"
                )
        else:
            # get dtype info of attribute
            attrs_types_dict = XirOpHelper.get_attrs_types(self.__xir_attrs)
            dtype = attrs_types_dict.get(name)
            assert (
                dtype is not None
            ), f"[ERROR] Not found the type info of '{name}' attribute."
            return getattr(self.__xir_attrs, f"get_attr_{dtype}")(name)

    def set_attr(self, name: str, value: Any) -> NoReturn:
        """set and update value of attribute.
        
        Parameters
        ----------
        name : str
            name of attributes.
        value : Any
            value of attribute.
        """
        assert name is not None, "'name' is not None."
        assert value is not None, "'value' should not be None."

        # get dtype info of attribute
        xir_attrs_types = XirOpHelper.get_attrs_types(self.__xir_attrs)
        dtype = xir_attrs_types.get(name)
        if dtype:
            try:
                getattr(self.__xir_attrs, f"set_attr_{dtype}")(name, value)
                XirOpHelper.set_op_attrs(self.__xir_op, self.__xir_attrs)
            except TypeError:
                sys.exit(
                    f"[ERROR] The type of new value of '{name}' attribute should be '{dtype}'"
                )
        else:
            dtype = value.__class__.__name__

            if dtype == "list":
                if len(value) == 0:
                    return
                item_dtype = value[0].__class__.__name__
                # check dtype consistency of each item in list
                for item in value:
                    assert (
                        item.__class__.__name__ == item_dtype
                    ), f"[ERROR] inconsistent item dtype in list: {value}"
                if item_dtype == "int":
                    dtype = "vint"
                elif item_dtype == "float":
                    dtype = "vfloat"
                elif item_dtype == "str":
                    dtype = "vstr"
                else:
                    raise TypeError(f"[ERROR] Unsupported item type in list: {value}.")
            elif dtype == "dict":
                if len(value) == 0:
                    return
                key_dtype, val_dtype = None, None
                for key, val in value.items():
                    if key_dtype is None or val_dtype is None:
                        key_dtype = key.__class__.__name__
                        val_dtype = val.__class__.__name__
                        assert (
                            key_dtype == "str"
                        ), "[ERROR] the type of key of the attr value should be 'str'."
                        assert val_dtype in [
                            "str",
                            "int",
                        ], "[ERROR] the type of value of the attr value should be 'str' or 'int'."
                        dtype = "dict_" + val_dtype
                    assert (
                        key.__class__.__name__ == key_dtype
                    ), "[ERROR] the type of key of the attr value should be 'str'."
                    assert (
                        val.__class__.__name__ == val_dtype
                    ), f"[ERROR] the type of value of the attr value should be {val_dtype}."

            try:
                getattr(self.__xir_attrs, f"set_attr_{dtype}")(name, value)
                XirOpHelper.set_op_attrs(self.__xir_op, self.__xir_attrs)
            except:
                raise ValueError(
                    f"[Error] Unsupported data type: attr_name={name}, data_type={dtype}"
                )

    def infer_shape(self) -> NoReturn:
        self.__xir_op.infer_shape()

    @property
    def graph(self) -> "Graph":
        """Get Graph object the Op object resides in.
        
        Returns
        -------
        Graph
            Graph object.
        """
        return self.__graph

    @graph.setter
    def graph(self, graph: "Graph") -> NoReturn:
        """Set Graph object the Op object resides in.
        
        Parameters
        ----------
        graph : Graph
            Graph object.
        """
        assert graph is not None, "'graph' should not be None."
        self.__graph = graph

    @property
    def metadata(self) -> XirOp:
        """
        Returns xir::Op object held by Op.
        """
        return self.__xir_op

    @metadata.setter
    def metadata(self, xir_op: XirOp) -> NoReturn:
        """
        Set metadata of Op.

        Parameters:
            xir_op: instance of XirOp.
        """
        self.__xir_op = xir_op
        self.__xir_attrs = self.__xir_op.get_attrs()
