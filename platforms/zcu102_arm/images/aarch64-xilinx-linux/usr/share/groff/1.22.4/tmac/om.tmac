.ig
Mom -- a typesetting/document-processing macro set for groff.

Copyright (C) 2002-2018  Free Software Foundation, Inc.
 Written by Peter Schaffter <peter@schaffter.ca>
 PDF integration contributed by Deri James <deri.james@chuzzlewit.co.uk>

This file is part of groff.

groff is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

groff is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.

Version 2.4
-----------
Antoine de St-Exup√©ry asserted that elegance in engineering is
achieved not when there is nothing left to add, but when there is
nothing left to take away.

By those standards, mom is a Rube Goldberg contraption.  She was
created over the years while groff, and my understanding of it,
changed and evolved.  However, I'm a firm believer in "if it ain't
broke, don't fix it."  Version 2.0 removed some of the redundancies
and cruft, but mom still needs some nip and tuck.

"<anything>" in the description of arguments that can be passed
to a macro means that any argument turns the feature off.

Thanks to everyone who has contributed suggestions and patches,
and to those whose GPL'd work has been plundered.  Special thanks
to Werner Lemberg (margin notes), Tadziu Hoffman (underlining),
Deri James (pdf integration), Robin Haberkorn (tbl integration, eqn
extensions, and float management).
..
.\" %beginstrip%
\#
\# ====================================================================
\#
.if \n(.C \
.   ab [mom]: The groff mom macros do not work in compatibility mode.
\# Check that GNU troff is being run
.if !\n[.g]=1 \
.   ab [mom]: The mom macros require that you be running GNU troff.
\# Check which version of groff is being run
.if (\n[.x]\n[.y] < 118) \
.   ab [mom]: You need GNU troff version 1.18 or higher to run this version of mom.
\# Mom version
.ds version 2.4
.if dVERSION \{\
.   ab [mom]: Version \*[version]
.\}
\# Groff revision
.ds short_revision \n[.Y]
.substring short_revision 0 0
\#
\# Add supplementary styles
.sty \n[.fp] UL      \"  Ultra Light
.sty \n[.fp] ULI     \"  Ultra Light Italic
.sty \n[.fp] ULCD    \"  Ultra Light Condensed
.sty \n[.fp] ULCDI   \"  Ultra Light Condensed Italic
.sty \n[.fp] ULEX    \"  Ultra Light Extended
.sty \n[.fp] ULEXI   \"  Ultra Light Extended Italic
\#
.sty \n[.fp] XL      \"  Extra Light
.sty \n[.fp] XLI     \"  Extra Light Italic
.sty \n[.fp] XLCD    \"  Extra Light Condensed
.sty \n[.fp] XLCDI   \"  Extra Light Condensed Italic
.sty \n[.fp] XLEX    \"  Extra Light Extended
.sty \n[.fp] XLEXI   \"  Extra Light Extended Italic
\#
.sty \n[.fp] TH      \"  Thin
.sty \n[.fp] THI     \"  Thin Italic
.sty \n[.fp] THCD    \"  Thin Condensed
.sty \n[.fp] THCDI   \"  Thin Condensed Italic
.sty \n[.fp] THEX    \"  Thin Extended
.sty \n[.fp] THEXI   \"  Thin Extended Italic
\#
.sty \n[.fp] L       \"  Light Roman
.sty \n[.fp] LI      \"  Light Italic
.sty \n[.fp] LCD     \"  Light Condensed
.sty \n[.fp] LCDI    \"  Light Condensed Italic
.sty \n[.fp] LEX     \"  Light Extended
.sty \n[.fp] LEXI    \"  Light Extended Italic
\#
.sty \n[.fp] BK      \"  Book Roman
.sty \n[.fp] BKI     \"  Book Italic
.sty \n[.fp] BKCD    \"  Book Condensed
.sty \n[.fp] BKCDI   \"  Book Condensed Italic
.sty \n[.fp] BKEX    \"  Book Extended
.sty \n[.fp] BKEXI   \"  Book Extended Italic
\#
.sty \n[.fp] CD      \"  Medium Condensed
.sty \n[.fp] CDI     \"  Medium Condensed Italic
.sty \n[.fp] EX      \"  Medium Extended
.sty \n[.fp] EXI     \"  Medium Extended Italic
\#
.sty \n[.fp] DB      \"  DemiBold Roman
.sty \n[.fp] DBI     \"  DemiBold Italic
.sty \n[.fp] DBCD    \"  DemiBold Condensed
.sty \n[.fp] DBCDI   \"  DemiBold Condensed Italic
.sty \n[.fp] DBEX    \"  DemiBold Extended
.sty \n[.fp] DBEXI   \"  DemiBold Extended Italic
\#
.sty \n[.fp] SB      \"  SemiBold Roman
.sty \n[.fp] SBI     \"  SemiBold Italic
.sty \n[.fp] SBCD    \"  SemiBold Condensed
.sty \n[.fp] SBCDI   \"  SemiBold Condensed Italic
.sty \n[.fp] SBEX    \"  SemiBold Extended
.sty \n[.fp] SBEXI   \"  SemiBold Extended Italic
\#
.sty \n[.fp] BCD     \"  Bold Condensed
.sty \n[.fp] BCDI    \"  Bold Condensed Italic
.sty \n[.fp] BEX     \"  Bold Extended
.sty \n[.fp] BEXI    \"  Bold Extended Italic
.sty \n[.fp] BO      \"  Bold Outline
\#
.sty \n[.fp] XB      \"  Extra Bold
.sty \n[.fp] XBI     \"  Extra Bold Italic
.sty \n[.fp] XBCD    \"  Extra Bold Condensed
.sty \n[.fp] XBCDI   \"  Extra Bold Condensed Italic
.sty \n[.fp] XBEX    \"  Extra Bold Extended
.sty \n[.fp] XBEXI   \"  Extra Bold Extended Italic
\#
.sty \n[.fp] UB      \"  Ultra Bold
.sty \n[.fp] UBI     \"  Ultra Bold Italic
.sty \n[.fp] UBCD    \"  Ultra Bold Condensed
.sty \n[.fp] UBCDI   \"  Ultra Bold Condensed Italic
.sty \n[.fp] UBEX    \"  Ultra Bold Extended
.sty \n[.fp] UBEXI   \"  Ultra Bold Extended Italic
\#
.sty \n[.fp] HV      \"  Heavy
.sty \n[.fp] HVI     \"  Heavy Italic
.sty \n[.fp] HVCD    \"  Heavy Condensed
.sty \n[.fp] HVCDI   \"  Heavy Condensed Italic
.sty \n[.fp] HVEX    \"  Heavy Extended
.sty \n[.fp] HVEXI   \"  Heavy Extended Italic
\#
.sty \n[.fp] BL      \"  Black
.sty \n[.fp] BLI     \"  Black Italic
.sty \n[.fp] BLCD    \"  Black Condensed
.sty \n[.fp] BLCDI   \"  Black Condensed Italic
.sty \n[.fp] BLEX    \"  Black Extended
.sty \n[.fp] BLEXI   \"  Black Extended Italic
.sty \n[.fp] BLO     \"  Black Outline
\#
.sty \n[.fp] XBL     \"  Extra Black
.sty \n[.fp] XBLI    \"  Extra Black Italic
.sty \n[.fp] XBLCD   \"  Extra Black
.sty \n[.fp] XBLCDI  \"  Extra Black
.sty \n[.fp] XBLEX   \"  Extra Black Italic
.sty \n[.fp] XBLEXI  \"  Extra Black Italic
\#
.sty \n[.fp] UBL     \"  Ultra Black
.sty \n[.fp] UBLI    \"  Ultra Black Italic
.sty \n[.fp] UBLCD   \"  Ultra Black Condensed
.sty \n[.fp] UBLCDI  \"  Ultra Black Condensed Italic
.sty \n[.fp] UBLEX   \"  Ultra Black Extended
.sty \n[.fp] UBLEXI  \"  Ultra Black Extended Italic
\#
.sty \n[.fp] SC      \"  Small Caps Roman
.sty \n[.fp] SCI     \"  Small Caps Italic
.sty \n[.fp] SCDB    \"  Small Caps Demibold
.sty \n[.fp] SCDBI   \"  Small Caps Demibold Italic
.sty \n[.fp] SCSB    \"  Small Caps Semibold
.sty \n[.fp] SCSBI   \"  Small Caps Semibold Italic
\#
\# Instruct grops to use square linecaps and joins.
\# This instruction is also executed in DO_B_MARGIN, NEWPAGE, and HEADER
\#
.if !n \X'ps: exec 0 setlinejoin'\X'ps: exec 0 setlinecap'
\#
\# The following PostScript, provided by Tadziu Hoffmann, permits
\# no-fail underlining
\#
.de ul*ps
ps: def
grops begin
/decornone { grops begin /X { } def /Y { } def /y2 -1 def end } def
/decorline { grops begin u neg /uld exch def u /ulw exch def
             /X { currentpoint /y0 exch def /x0 exch def } def
             /Y { currentpoint /y1 exch def /x1 exch def
                  drawline /x2 x1 def /y2 y1 def } def end } def
/drawline { gsave ulw setlinewidth 0 setlinecap x1 y1 uld sub moveto
            y2 y0 eq { x2 y2 } { x0 y0 } ifelse uld sub lineto stroke
            grestore } def
decornone
/uld 0 def
/ulw 0 def
/A { X show Y } def
/B { 0 SC 3 -1 roll X widthshow Y } def
/C { 0 exch X ashow Y } def
/D { 0 exch 0 SC 5 2 roll X awidthshow Y } def
/E { 0 rmoveto X show Y } def
/F { 0 rmoveto 0 SC 3 -1 roll X widthshow Y } def
/G { 0 rmoveto 0 exch X ashow Y } def
/H { 0 rmoveto 0 exch 0 SC 5 2 roll X awidthshow Y } def
/I { 0 exch rmoveto X show Y } def
/J { 0 exch rmoveto 0 SC 3 -1 roll X widthshow Y } def
/K { 0 exch rmoveto 0 exch X ashow Y } def
/L { 0 exch rmoveto 0 exch 0 SC 5 2 roll X awidthshow Y } def
/M { rmoveto X show Y } def
/N { rmoveto 0 SC 3 -1 roll X widthshow Y } def
/O { rmoveto 0 exch X ashow Y } def
/P { rmoveto 0 exch 0 SC 5 2 roll X awidthshow Y } def
/Q { moveto X show Y } def
/R { moveto 0 SC 3 -1 roll X widthshow Y } def
/S { moveto 0 exch X ashow Y } def
/T { moveto 0 exch 0 SC 5 2 roll X awidthshow Y } def
end
..
\#
.if !n \Y[ul*ps]
.if n .color 0
.nr TOC.RELOCATE 0 \" TOC.RELOCATE is off by default
.ds PDFHREF.TEXTCOL.DEFAULT 0.0 0.3 0.9
.nr PDFHREF.VIEW.LEADING.C 3i
.nr PDFHREF.VIEW.LEADING.T 1i
.nr PDFHREF.VIEW.LEADING 0
.nr PDFHREF.VIEW.LEADING.H \n[PDFHREF.VIEW.LEADING]
\#
\# ====================================================================
\#
\# TYPESETTING MACROS, STRINGS, AND ALIASES
\# ========================================
\#
\# +++ALIASES+++
\#
\# Alias .als as ALIAS, and .aln (number registers) as ALIASN
\#
.als      ALIAS           als
.als      ALIASN          aln
\#
\# ALIASES FOR GROFF REQUESTS
\# --------------------------
\#
.ALIAS    MAC             de
.ALIAS    BR              br
.ALIAS    SPREAD          brp
.ALIAS    ESC_CHAR        ec
.ALIAS    STRING          ds
.ALIAS    INCLUDE         so
\#
\# ALIASES FOR NUMBER REGISTERS
\# ----------------------------
\#
.ALIASN  #PT_SIZE        .ps    \"fractional point size in units
.ALIASN  #DIVER_DEPTH     dn    \"diversion depth
.ALIASN  #DIVER_WIDTH     dl    \"diversion width
.ALIASN  #TRAP_DISTANCE  .t     \"distance to next trap
.ALIASN  #LEAD           .v     \"line space
.ALIASN  #PAGE_LENGTH    .p     \"page length
.ALIASN  #NUM_ARGS       .$     \"number of arguments passed to a macro
.ALIASN  #INDENT         .i     \"value of current indent
\#
\# ====================================================================
\#
\# MISCELLANEOUS
\# =============
.nr #L_MARGIN \n[.o]  \" Tabs, etc require #L_MARGIN
.cflags 4 /\[en]      \" So slash and en-dashes get broken
\#
\# 'END' is used throughout as the 2nd arg to 'MAC' (alias of .de)
\# Defining it as a macro here prevents groff from complaining
\# that 'END' isn't defined.
\#
.de END
..
\#
\# ====================================================================
\#
\# +++PAGE LAYOUT+++
\#
\# Macros that control the physical layout of the page: paper size
\# and margins.
\#
\# PAGE WIDTH
\# ----------
\# *Argument:
\#   <width of printer sheet>
\# *Function:
\#   Stores user supplied page width in register #PAGE_WIDTH.
\# *Notes:
\#   #PAGE_WIDTH is used to establish the default LL (and right margin).
\#   Requires unit of measure.
\#
.MAC PAGEWIDTH END
.    br
.    nr #PAGE_WIDTH \\$1
.    if !r#L_MARGIN .L_MARGIN \\n[.o]
.    if !r#R_MARGIN .R_MARGIN 1i
.    if '\\*[.T]'pdf' \X'papersize=\\n[#PAGE_WIDTH]z,\\n[#PAGE_LENGTH]z'\c
.END
\#
\# L_MARGIN
\# --------
\# *Argument:
\#   <offset from page left>
\# *Function:
\#   Stores user supplied page offset in register #L_MARGIN.
\#   Sets .po to user supplied offset.
\# *Notes:
\#   Requires unit of measure.
\#
.MAC L_MARGIN END
.    br
.    nr #L_MARGIN (\\$1)
.    po \\n[#L_MARGIN]u
.END
\#
\# R_MARGIN
\# --------
\# *Argument:
\#   <width of right margin>
\# *Function:
\#   Stores user supplied right margin in register #R_MARGIN.
\# *Notes:
\#   This is a pseudo-margin.  Right margin is actually a function of
\#   line length.  The macro calculates line length from the page offset
\#   and the value plugged into #R_MARGIN.
\#
\#   N.B. -- PAGEWIDTH and L_MARGIN have to be defined before R_MARGIN.
\#
\#   Requires unit of measure.
\#
.MAC R_MARGIN END
.    br
.    nr #R_MARGIN (\\$1)
.    ll \\n[#PAGE_WIDTH]u-\\n[#L_MARGIN]u-\\n[#R_MARGIN]u
.    ta \\n[.l]u
.    nr #L_LENGTH \\n[.l]
.END
\#
\# T_MARGIN
\# --------
\# *Argument:
\#   <distance to advance from top of page>
\# *Function:
\#   Stores the user supplied top margin in register #T_MARGIN.
\#   Advances user supplied depth from the top of the page.
\# *Notes:
\#   Requires unit of measure.
\#
.MAC T_MARGIN END
.    nr #T_MARGIN (\\$1)
.    if !\\n[#DOCS] .sp |\\n[#T_MARGIN]u-1v
.    wh 0i DO_T_MARGIN
.END
\#
\# B_MARGIN
\# --------
\# *Argument:
\#   <space to leave at the bottom of the page>
\# *Function:
\#   Stores the user supplied bottom margin in register #B_MARGIN.
\# *Notes:
\#   Requires unit of measure.
\#
.MAC B_MARGIN END
.    br
.    nr #B_MARGIN (\\$1)
.    nr #ORIGINAL_B_MARGIN \\n[#B_MARGIN]
.    nr #B_MARGIN_SET 1
.    wh -\\n[#B_MARGIN]u DO_B_MARGIN
.END
\#
\# PAGE
\# ----
\# *Arguments:
\#   <pagewidth>  [pagelength [leftmargin [rightmargin [topmargin [bottommargin]]]]]
\# *Function:
\#   Page set-up.  Collects arguments and passes them to the appropriate
\#   macros.
\# *Notes:
\#   All arguments after pagewidth are optional, but must appear
\#   in the order given above.  (User can fill in as much or as
\#   little as desired.)
\#
\#   All arguments require a unit of measure.
\#
.MAC PAGE END
.    br
.    PAGEWIDTH   \\$1
.    PAGELENGTH  \\$2
.    ie '\\$3''  .L_MARGIN \\n[.o]
.    el          .L_MARGIN \\$3
.    ie '\\$4''  .R_MARGIN 1i
.    el          .R_MARGIN \\$4
.    if !'\\$5'' .T_MARGIN \\$5
.    if !'\\$6'' .B_MARGIN \\$6
.END
\#
\# gropdf: pass pagelength to postprocessor; no need for -P-p
\#
.MAC PAGELENGTH END
.    pl \\$*
.    if '\\*[.T]'pdf' \X'papersize=\\n[#PAGE_WIDTH]z,\\n[#PAGE_LENGTH]z'\c
.END
\#
\# =====================================================================
\#
\# +++PAGE CONTROL+++
\#
\# Generic macros for breaking pages.
\#
\# DO_T_MARGIN
\# -----------
\# *Argument:
\#   <none>
\# *Function:
\#   Plants the top margin at the top of each page.
\# *Notes:
\#   The trap is set in .T_MARGIN or .PAGE
\#
.MAC DO_T_MARGIN END
.    ev T_MARGIN
.    sp |\\n[#T_MARGIN]u-1v
.    ev
.END
\#
\# DO_B_MARGIN
\# -----------
\# *Argument:
\#   <none>
\# *Function:
\#   Plants the bottom margin at the bottom of each page.
\# *Notes:
\#   The trap is set in .B_MARGIN or .PAGE.
\#
.MAC DO_B_MARGIN END
.    nr #T_MARGIN_LEAD_ADJ \\n[#LEAD]-12000
.    ev B_MARGIN
.    if !n .nop \X'ps: exec 0 setlinejoin'\X'ps: exec 0 setlinecap'
.    ie \\n[#DOCS] \
.       if !\\n[#NEWPAGE] .bp
.    el .bp
.    ev
.END
\#
\# NEWPAGE
\# -------
\# *Argument:
\#   <none>
\# *Function:
\#   Breaks to a new page.
\# *Notes:
\#   If a B_MARGIN has been set, processes that, otherwise, just
\#   breaks to a new page.
\#
.MAC NEWPAGE END
.    br
.    if \\n[#DOC_TYPE]=5 \{\
.       if \\n[#NUM_ARGS]>0 \
.       pdftransition PAGE \\$1
.    \}
.    if !\\n[defer] \{\
.       nr #NEWPAGE 1
.       rr tbl*no-print-header
.    \}
.    ie !\\n[#DOCS]=1 \
.       if \\n[#B_MARGIN_SET]=1 .DO_B_MARGIN
.    el \{\
.       if \\n[#COLUMNS]=1 .nr #COL_NUM \\n[#NUM_COLS]
.       if !\\n[#FN_DEPTH] \{\
.          ch FN_OVERFLOW_TRAP
.          nr #RESET_FN_OVERFLOW_TRAP 1
.       \}
.    \}
.    if dPDF.EXPORT \
.       if \\n[#FLEX_ACTIVE] \
.          if !\\n[#NO_FLEX] \
.             tm .ds pre-newpage-\\n% \\n%@\\n[#COL_NUM]
.    if (\\n[@TOP]=0):(\\n[#END_COVER]=1) \
.       bp
.    rr #END_COVER
.    if \\n[#RESET_FN_OVERFLOW_TRAP] \{\
.       wh -\\n[#FN_OVERFLOW_TRAP_POS]u FN_OVERFLOW_TRAP
.       rr #RESET_FN_OVERFLOW_TRAP_POS
.   \}
.END
\#
.ALIAS NEWSLIDE NEWPAGE
\#
\# =====================================================================
\#
\# +++GENERAL STYLE MACROS+++
\#
\# LINE LENGTH
\# -----------
\# *Argument:
\#   <line length>
\# *Function:
\#   Stores user supplied line length in register #L_LENGTH.
\#   Sets .ll to #L_LENGTHu
\# *Notes:
\#   Requires unit of measure.
\#
.MAC LL END
.    nr #USER_SET_L_LENGTH 1
.    ll \\$1
.    nr #L_LENGTH \\n[.l]
.    ta \\n[.l]u
.END
\#
\# +++FAMILY AND FONT+++
\#
\# FALLBACK FONT
\# -------------
\# *Argument:
\#   <fallback font> [ ABORT | WARN ] | ABORT | WARN
\# *Function:
\#   Sets register #ABORT_FT_ERRORS to 1, or defines a fallback font
\#   called "dummy" at font position 0.
\# *Notes:
\#   Calls to non-existent families cause mom to continue processing
\#   files using the fallback font until a valid family is entered.
\#
\#   Calls to non-existent fonts generate warnings.  If ABORT is passed
\#   to FALLBACK_FONT, mom stops processing files after the warning.
\#   Otherwise, she continues to process files using the fallback font
\#   after the warning is issued.  The default fallback font is CR; the
\#   default for font warnings is to abort.
\#
.MAC FALLBACK_FONT END
.    if \\n[#NUM_ARGS]=1 \{\
.       if '\\$1'ABORT' .nr #ABORT_FT_ERRORS 1
.       if '\\$1'WARN' \
.          if r #ABORT_FT_ERRORS .nr #ABORT_FT_ERRORS 0
.       if !'\\$1'ABORT' \
.          if !'\\$1'WARN' .fp 0 dummy \\$1
.    \}
.    if \\n[#NUM_ARGS]=2 \{\
.       fp 0 dummy \\$1
.       if '\\$2'ABORT' .nr #ABORT_FT_ERRORS 1
.       if '\\$2'WARN'  .nr #ABORT_FT_ERRORS 0
.    \}
.END
\#
.FALLBACK_FONT CR ABORT
\#
\# FAMILY
\# ------
\# *Argument:
\#   <font family>
\# *Function:
\#   Stores user supplied font family in string $FAMILY.  Sets .fam
\#   to $FAMILY.
\#
.MAC FAMILY END
.    if '\\n[.ev]'COVER_TEXT' .ds $SAVED_DOC_FAM \\n[.fam]
.    if \\n[#COLLATE] .rm $SAVED_DOC_FAM
.    ds $FAMILY \\$1
.    if \\n[#PRINT_STYLE]=1 \{\
.       fam \\*[$TYPEWRITER_FAM]
.       return
.    \}
.    if \\n[#IGNORE] \{\
.       fam \\*[$TYPEWRITER_FAM]
.       return
.    \}
.    if (\\n[.x]\\n[.y]\\*[short_revision] >= 1192) .ds $SAVED_STYLE \\n[.sty]
.    ft 0
.    fam \\*[$FAMILY]
.    if (\\n[.x]\\n[.y]\\*[short_revision] >= 1192) \{\
.       ft \\*[$SAVED_STYLE]
.       if !F\\n[.fn] .ft 0
.    \}
.    ie \\n[#PRE_COLLATE]=1 .
.    el \{\
.       if \\n[#COLLATE]=1 \
.          if !r#START .ds $DOC_FAM \\*[$FAMILY]
.    \}
.END
\#
\# FONT
\# ----
\# *Argument:
\#   R | I | B | BI | <other style extension>
\# *Function:
\#  Stores user supplied font in $FONT and sets .ft to $FONT.
\#
.MAC FT END
.    ds $FONT \\$1
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie '\\$1'I' \{\
.          if \\n[#UNDERLINE_ITALIC]=1 \{\
.             UNDERLINE
.             return
.          \}
.          if \\n[#ITALIC_MEANS_ITALIC]=1 \{\
.             ds $FONT \\$1
.             ft \\*[$FONT]
.             return
.          \}
.       \}
.       el .UNDERLINE OFF
.       return
.    \}
.    ft 0
.    ft \\*[$FONT]
.    if (\\n[.x]\\n[.y]\\*[short_revision] >= 1192) \{\
.       if '\\n[.sty]'' \{\
.          if !F\\n[.fn] \{\
.             if !S\\*[$FONT] \{\
.                tm1 "[mom]: Font style "\\*[$FONT]" at line \\n[.c] has not been registered.
.                ie \\n[#ABORT_FT_ERRORS]=0 \
.                   tm1 "       Continuing to process using fallback font.
.                el .ab [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.             \}
.             if \\n[.f]=0 \{\
.                tm1 "[mom]: Either font style "\\*[$FONT]" at line \\n[.c] does not exist in family "\\n[.fam]",
.                tm1 "       or family "\\n[.fam]" has not been installed.
.                ie \\n[#ABORT_FT_ERRORS]=0 \
.                   tm1 "       Continuing to process using fallback font.
.                el .ab [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.             \}
.          \}
.       \}
.    \}
.END
\#
\# POINT SIZE
\# ----------
\# *Arguments:
\#   <point size of type>
\# *Function:
\#   Sets point size to user supplied value in scaled points.
\#   If #AUTO_LEAD is on, resets lead accordingly.
\# *Notes:
\#   Must NOT use a unit of measure.
\#
.MAC PT_SIZE END
.    if \\n[#PRINT_STYLE]=1 .return
.    if \\n[#IGNORE] .return
.    ps \\$1
.    nr #PT_SIZE_IN_UNITS \\n[.ps]
.    ie '\\$0'DOC_PT_SIZE' \{\
.       if !\\n[#DOCS] .DOC_MACRO_ERROR \\$0
.       br
.       nr #NEW_DOC_PT_SIZE \\n[.ps]
.       if \\n[#DOC_AUTOLEAD] \{\
.          ie !\\n[#DOC_AUTOLEAD_FACTOR] .nr #AUTOLEADING \\n[#DOC_AUTOLEAD]
.          el .nr #AUTOLEADING \\n[.ps]*\\n[#DOC_AUTOLEAD]/1000-\\n[.ps]
.          nr #DOC_LEAD \\n[.ps]+\\n[#AUTOLEADING]
.          nr #RESET_TRAPS 1
.       \}
.    \}
.    el .if \\n[#AUTO_LEAD] .vs \\n[.ps]u+\\n[#AUTOLEADING]u
.END
\#
\# SIZE (inline)
\# -------------
\# *Arguments:
\#   <point size of type>
\# *Function:
\#   Sets point size to user supplied value in scaled points.
\#   Intended to be called inline with \*[SIZE <n><unit>]
\# *Notes:
\#   Can be used with a unit of measure or not.
\#
.MAC SIZE END
\c
.ps \\$1
.END
\#
\# LEADING
\# -------
\# *Argument:
\#   <leading between lines of text>
\# *Function:
\#   Turns off #AUTOLEAD if it's on.
\#   Sets .vs to user supplied value.
\# *Notes:
\#   Does not require unit of measure.  LS automatically turns off AUTOLEAD.
\#
.MAC LS END
.    br
.    if \\n[#PRINT_STYLE]=1 .return
.    if \\n[#IGNORE] .return
.    if \\n[#AUTO_LEAD] \{\
.       rr #AUTO_LEAD
.       rr #AUTOLEAD_VALUE
.       rr #AUTOLEADING
.    \}
.    vs \\$1
.    if !\\n[#START] \
.       if \\n[.t]<\\n[.v] 'bp
.END
\#
\# AUTOLEAD
\# --------
\# *Argument:
\#   <leading value to add to #PT_SIZE> [FACTOR]
\# *Function:
\#   Stores user supplied auto-lead value in register #AUTOLEAD_VALUE.
\#   Adds #AUT0LEAD_VALUE to #PT_SIZE when invoked to set leading.
\#   All subsequent PT_SIZE requests reset the leading in the same way until
\#   AUTOLEAD is turned off.
\# *Notes:
\#   With the optional FACTOR argument, the current point size is
\#   multiplied by #AUTOLEAD_VALUE/1000 instead of the two being added
\#   together.
\#
.MAC AUTOLEAD END
.    if \\n[#PRINT_STYLE]=1 .return
.    if \\n[#IGNORE] .return
.    nr #AUTO_LEAD 1 \" autolead on or off
.    nr #AUTOLEAD_VALUE (p;\\$1) \" arg x 1000
.    ie '\\$2'FACTOR' \{\
.       if !\\n[#DOCS] .nr #DOC_AUTOLEAD_FACTOR \\n[#AUTOLEAD_VALUE] \" save for DOC_PT_SIZE
.       nr #AUTOLEADING \\n[.ps]*\\n[#AUTOLEAD_VALUE]/1000-\\n[.ps]
.    \}
.    el .nr #AUTOLEADING \\n[#AUTOLEAD_VALUE]
.    vs \\n[.ps]u+\\n[#AUTOLEADING]u
.END
\#
\# STRINGS FOR INLINE CONTROL OF GENERAL TYPE STYLE
\# ------------------------------------------------
.ds ROM  \Ef[R]
.ds IT   \Ef[I]
.ds BD   \Ef[B]
.ds BDI  \Ef[BI]
.ds PREV \Ef[]
.ds S    \Es
\#
\# =====================================================================
\#
\# +++KERNING+++
\#
\# AUTOMATIC PAIRWISE KERNING
\# --------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns automatic pairwise kerning on or off.
\#
.MAC KERN END
.    ie '\\$1'' \{\
.       kern
.       nr #KERN 1
.    \}
.    el \{\
.       kern 0
.       nr #KERN 0
.    \}
.END
\#
\# INLINE KERNING AND HORIZONTAL MOVEMENT
\# --------------------------------------
\#
\# Inline kerning provides a simple way to adjust the amount of
\# space between any two letters.  It's predicated on a unit of
\# measure "U", which, by default, is 1/36 of the current point
\# size as returned by \n[.ps]; e.g., if the current point size is
\# 18, \n[.ps] returns 18000u, therefore U=500u.  Since U remains
\# proportional relative to the current point size, the amount of
\# kerning between two letters as expressed in Us remains visually
\# similar regardless of changes in point size.
\#
\# The default value for U may be changed or reset with the
\# KERN_UNIT macro.
\#
.MAC KERN_UNIT END
.    ie '\\$1'DEFAULT' .ds $KERN_UNIT 36
.    el .ds $KERN_UNIT \\$1
.END
\#
.ds $KERN_UNIT 36
.ds BU   \h'-(\En[.ps]u/\E*[$KERN_UNIT]u*\\$1u)'
.ds FU   \h'(\En[.ps]u/\E*[$KERN_UNIT]u*\\$1u)'
\#
\# Initialize strings for pre-1.1.3c-style BU and FU
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<37 \{\
.   ds BU\n[#LOOP] \h'-(\En[.ps]u/\E*[$KERN_UNIT]u*\n[#LOOP]u)'
.   ds FU\n[#LOOP] \h'(\En[.ps]u/\E*[$KERN_UNIT]u*\n[#LOOP]u)'
.\}
\#
\# Horizontal movements
\# --------------------
\# BP1...12.75 and FP1...12.75 move backwards or forwards inline by the
\# specified number of points.
\#
.ds BCK  \h'-\\$1'
.ds FWD  \h'\\$1'
\#
.ds BP.25    \h'-.25'
.ds BP.5     \h'-.5'
.ds BP.75    \h'-.75'
.ds BP1      \h'-1p'
.ds BP1.25   \h'-1.25p'
.ds BP1.5    \h'-1.5p'
.ds BP1.75   \h'-1.75p'
.ds BP2      \h'-2p'
.ds BP2.25   \h'-2.25p'
.ds BP2.5    \h'-2.5p'
.ds BP2.75   \h'-2.75p'
.ds BP3      \h'-3p'
.ds BP3.25   \h'-3.25p'
.ds BP3.5    \h'-3.5p'
.ds BP3.75   \h'-3.75p'
.ds BP4      \h'-4p'
.ds BP4.25   \h'-4.25p'
.ds BP4.5    \h'-4.5p'
.ds BP4.75   \h'-4.75p'
.ds BP5      \h'-5p'
.ds BP5.25   \h'-5.25p'
.ds BP5.5    \h'-5.5p'
.ds BP5.75   \h'-5.75p'
.ds BP6      \h'-6p'
.ds BP6.25   \h'-6.25p'
.ds BP6.5    \h'-6.5p'
.ds BP6.75   \h'-6.75p'
.ds BP7      \h'-7p'
.ds BP7.25   \h'-7.25p'
.ds BP7.5    \h'-7.5p'
.ds BP7.75   \h'-7.75p'
.ds BP8      \h'-8p'
.ds BP8.25   \h'-8.25p'
.ds BP8.5    \h'-8.5p'
.ds BP8.75   \h'-8.75p'
.ds BP9      \h'-9p'
.ds BP9.25   \h'-9.25p'
.ds BP9.5    \h'-9.5p'
.ds BP9.75   \h'-9.75p'
.ds BP10     \h'-10p'
.ds BP10.25  \h'-10.25p'
.ds BP10.5   \h'-10.5p'
.ds BP10.75  \h'-10.75p'
.ds BP11     \h'-11p'
.ds BP11.25  \h'-11.25p'
.ds BP11.5   \h'-11.5p'
.ds BP11.75  \h'-11.75p'
.ds BP12     \h'-12p'
.ds BP12.25  \h'-12.25p'
.ds BP12.5   \h'-12.5p'
.ds BP12.75  \h'-12.75p'
\#
.ds FP.25    \h'.25'
.ds FP.5     \h'.5'
.ds FP.75    \h'.75'
.ds FP1      \h'1p'
.ds FP1.25   \h'1.25p'
.ds FP1.5    \h'1.5p'
.ds FP1.75   \h'1.75p'
.ds FP2      \h'2p'
.ds FP2.25   \h'2.25p'
.ds FP2.5    \h'2.5p'
.ds FP2.75   \h'2.75p'
.ds FP3      \h'3p'
.ds FP3.25   \h'3.25p'
.ds FP3.5    \h'3.5p'
.ds FP3.75   \h'3.75p'
.ds FP4      \h'4p'
.ds FP4.25   \h'4.25p'
.ds FP4.5    \h'4.5p'
.ds FP4.75   \h'4.75p'
.ds FP5      \h'5p'
.ds FP5.25   \h'5.25p'
.ds FP5.5    \h'5.5p'
.ds FP5.75   \h'5.75p'
.ds FP6      \h'6p'
.ds FP6.25   \h'6.25p'
.ds FP6.5    \h'6.5p'
.ds FP6.75   \h'6.75p'
.ds FP7      \h'7p'
.ds FP7.25   \h'7.25p'
.ds FP7.5    \h'7.5p'
.ds FP7.75   \h'7.75p'
.ds FP8      \h'8p'
.ds FP8.25   \h'8.25p'
.ds FP8.5    \h'8.5p'
.ds FP8.75   \h'8.75p'
.ds FP9      \h'9p'
.ds FP9.25   \h'9.25p'
.ds FP9.5    \h'9.5p'
.ds FP9.75   \h'9.75p'
.ds FP10     \h'10p'
.ds FP10.25  \h'10.25p'
.ds FP10.5   \h'10.5p'
.ds FP10.75  \h'10.75p'
.ds FP11     \h'11p'
.ds FP11.25  \h'11.25p'
.ds FP11.5   \h'11.5p'
.ds FP11.75  \h'11.75p'
.ds FP12     \h'12p'
.ds FP12.25  \h'12.25p'
.ds FP12.5   \h'12.5p'
.ds FP12.75  \h'12.75p'
\#
\# WHOLE LINE (TRACK) KERNING
\# --------------------------
\# *Argument:
\#   <amount of track kerning>
\# *Function:
\#   Invokes .tkf (track kerning) for the current font with
\#   1 as both the upper and lower point size limits, so that
\#   the value entered by the user applies regardless of point
\#   size.  RW ("Reduce Whitespace") reduces the amount of space
\#   between all characters by an equal amount.  EW ("Extra
\#   Whitespace") increases the amount of space.
\# *Notes:
\#   Decimal values are acceptable.
\#
\# A value of 1 will produce an unacceptably tight or loose line
\# at most text point sizes; therefore, effective use of RW and
\# EW is in the fractional range below 1.
\#
\# \n[.f] holds the current font number, which is acceptable to .tkf.
\#
\# RW and EW must be reset to 0 to cancel their effect on subsequent
\# output lines.
\#
.MAC RW END
.    if \\n[#BR_AT_LINE_KERN] \{\
.       ie \\n[#JUSTIFY]=1 .brp
.       el .br
.    \}
.    rr #EW
.    rm $EW
.    nr #RW 1
.    ds $RW \\$1
.    tkf \\n[.f] 1 -\\$1 1 -\\$1
.END
\#
.MAC EW END
.    if \\n[#BR_AT_LINE_KERN] \{\
.       ie \\n[#JUSTIFY]=1 .brp
.       el .br
.    \}
.    rr #RW
.    rm $RW
.    nr #EW 1
.    ds $EW \\$1
.    tkf \\n[.f] 1 \\$1 1 \\$1
.END
\#
\# BREAK AT LINE KERN
\# ------------------
\# *Arguments:
\#   toggle
\# *Function:
\#   Enables/disables .br's before .RW and .EW
\# *Notes:
\#   Mostly, users will want .br's before any kind of line kerning, but
\#   there may be cases where they don't.  BR_AT_LINE_KERN is off by
\#   default and must be invoked explicitly.
\#
.MAC BR_AT_LINE_KERN END
.    ie '\\$1'' .nr #BR_AT_LINE_KERN  1
.    el .rr #BR_AT_LINE_KERN
.END
\#
\# =====================================================================
\#
\# +++HYPHENATION+++
\#
\# AUTO HYPHENATION
\# ----------------
\# *Arguments:
\#   <none> | <anything> | DEFAULT
\#                 or
\#   LINES <n> | MARGIN <n> | SPACE <n>
\# *Function:
\#   Turns auto hyphenation on or off, resets the hyphenation style
\#   to default, or permits the setting of various hyphenation
\#   parameters.
\# *Notes:
\#   HY, by itself, defaults to .hy 14, i.e. no hyphens after the
\#   first two or before the last two characters of a word, and no
\#   hyphenation of the last line prior to a trap (e.g., at the
\#   bottom of a page).
\#
\#   HY DEFAULT resets the hyphenation style to .hy 14 (see
\#   above) if that behaviour is desired after changes have been
\#   made to LINES, MARGIN, or SPACE.
\#
\#   HY LINES <n> sets the number of allowable consecutive hyphenated lines.
\#
\#   HY MARGIN <n> sets the amount of space (ipPcm) allowed at the end
\#   of a line in QUAD mode before hyphenation is tripped (e.g. if there's
\#   only 6 points left, groff won't try to hyphenate the next word).
\#
\#   HY SPACE sets the amount of extra interword space (ipPcm) that can
\#   be added in JUSTIFY mode to prevent a line from being hyphenated.
\#
.MAC HY END
.    ie '\\$1'' \{\
.       hy 14
.       if \\n[#LINES]  .hlm \\n[#LINES]
.       if \\n[#MARGIN] .hym \\n[#MARGIN]]
.       if \\n[#SPACE]  .hys \\n[#SPACE]
.       nr #HYPHENATE 1
.    \}
.    el \{\
.       if !'\\$1'LINES' \{\
.          nh
.          nr #HYPHENATE 0
.       \}
.       if !'\\$1'MARGIN' \{\
.          nh
.          nr #HYPHENATE 0
.       \}
.       if !'\\$1'SPACE' \{\
.          nh
.          nr #HYPHENATE 0
.       \}
.       if !'\\$1'DEFAULT' \{\
.          nh
.          nr #HYPHENATE 0
.       \}
.       if '\\$1'LINES'  \{\
.          hlm \\$2
.          nr #HY_LINES \\$2
.       \}
.       if '\\$1'MARGIN' \{\
.          hym \\$2
.          nr #HY_MARGIN \\$2
.       \}
.       if '\\$1'SPACE'  \{\
.          hys \\$2
.          nr #HY_SPACE \\$2
.       \}
.       if '\\$1'DEFAULT' \{\
.          hlm -1
.          hym 0
.          hys 0
.          rr #HY_LINES
.          rr #HY_SPACE
.          rr #HY_MARGIN
.       \}
.    \}
.END
\#
\# HYPHENATION PARAMETERS
\# ----------------------
\# *Arguments:
\#   <# of lines> | <size of margin> | <amount of interword space>
\# *Function:
\#   Allows user to specify .HY LINES, MARGIN, and SPACE with a single command.
\#
.MAC HY_SET END
.    nr #HY_SET 1
.    hlm \\$1
.    hym \\$2
.    hys \\$3
.END
\#
\# =====================================================================
\#
\# +++VERTICAL SPACING+++
\#
\# ADVANCE LEAD
\# ------------
\# *Argument:
\#   <user supplied lead to advance below current baseline>
\# *Function:
\#   Creates or modifies register #ALD.  Adds user supplied lead
\#   below current baseline.
\# *Notes:
\#   Requires a unit of measure.
\#
.MAC ALD END
.    if '\\$0'ALD' \{\
.       nr #ALD (u;\\$1)
.       sp \\n[#ALD]u
.    \}
.    if '\\$0'ADD_SPACE' \{\
.       vpt 0
.       nr #ALD (u;\\$1)
.       rs
.       nop \&
.       br
.       sp |\\n[#T_MARGIN]u-1v+\\n[#ALD]u
.       rr @TOP
.       nr #SPACE_ADDED 1
.       vpt
.    \}
.    if '\\$0'SPACE' .sp \\$1
.    if '\\$0'SP'    .sp \\$1
.END
\#
\# REVERSE LEAD
\# ------------
\# *Argument:
\#   <user supplied lead to reverse above current baseline>
\# *Function:
\#   Creates or modifies register #RLD.  Reverses user supplied
\#   lead above current baseline.
\# *Notes:
\#   Requires a unit of measure.
\#
.MAC RLD END
.    br
.    nr #RLD (u;\\$1)
.    sp -\\n[#RLD]u
.END
\#
\# ALD/RLD STRINGS
\# ---------------
\# The strings \*[ALD.25]...\*[ALD12.75] and their corresponding
\# \*[RLD] forms have been left in for backward compatibility with
\# documents created using mom-1.1.3c or earlier.  The preferred methods
\# of advancing and reversing on the page inline are \*[UP <n><unit>]
\# and \*[DOWN <n><unit>].
\#
.ds DOWN      \v'\\$1'
.ds UP        \v'-\\$1'
\#
.ds ALD.25    \v'.25p'
.ds ALD.5     \v'.5p'
.ds ALD.75    \v'.75p'
.ds ALD1      \v'1p'
.ds ALD1.25   \v'1.25p'
.ds ALD1.5    \v'1.5p'
.ds ALD1.75   \v'1.75p'
.ds ALD2      \v'2p'
.ds ALD2.25   \v'2.25p'
.ds ALD2.5    \v'2.5p'
.ds ALD2.75   \v'2.75p'
.ds ALD3      \v'3p'
.ds ALD3.25   \v'3.25p'
.ds ALD3.5    \v'3.5p'
.ds ALD3.75   \v'3.75p'
.ds ALD4      \v'4p'
.ds ALD4.25   \v'4.25p'
.ds ALD4.5    \v'4.5p'
.ds ALD4.75   \v'4.75p'
.ds ALD5      \v'5p'
.ds ALD5.25   \v'5.25p'
.ds ALD5.5    \v'5.5p'
.ds ALD5.75   \v'5.75p'
.ds ALD6      \v'6p'
.ds ALD6.25   \v'6.25p'
.ds ALD6.5    \v'6.5p'
.ds ALD6.75   \v'6.75p'
.ds ALD7      \v'7p'
.ds ALD7.25   \v'7.25p'
.ds ALD7.5    \v'7.5p'
.ds ALD7.75   \v'7.75p'
.ds ALD8      \v'8p'
.ds ALD8.25   \v'8.25p'
.ds ALD8.5    \v'8.5p'
.ds ALD8.75   \v'8.75p'
.ds ALD9      \v'9p'
.ds ALD9.25   \v'9.25p'
.ds ALD9.5    \v'9.5p'
.ds ALD9.75   \v'9.75p'
.ds ALD10     \v'10p'
.ds ALD10.25  \v'10.25p'
.ds ALD10.5   \v'10.5p'
.ds ALD10.75  \v'10.75p'
.ds ALD11     \v'11p'
.ds ALD11.25  \v'11.25p'
.ds ALD11.5   \v'11.5p'
.ds ALD11.75  \v'11.75p'
.ds ALD12     \v'12p'
.ds ALD12.25  \v'12.5p'
.ds ALD12.5   \v'12.5p'
.ds ALD12.75  \v'12.75p'
\#
.ds RLD.25    \v'-.25p'
.ds RLD.5     \v'-.5p'
.ds RLD.75    \v'-.75p'
.ds RLD1      \v'-1p'
.ds RLD1.25   \v'-1.25p'
.ds RLD1.5    \v'-1.5p'
.ds RLD1.75   \v'-1.75p'
.ds RLD2      \v'-2p'
.ds RLD2.25   \v'-2.25p'
.ds RLD2.5    \v'-2.5p'
.ds RLD2.75   \v'-2.75p'
.ds RLD3      \v'-3p'
.ds RLD3.25   \v'-3.25p'
.ds RLD3.5    \v'-3.5p'
.ds RLD3.75   \v'-3.75p'
.ds RLD4      \v'-4p'
.ds RLD4.25   \v'-4.25p'
.ds RLD4.5    \v'-4.5p'
.ds RLD4.75   \v'-4.75p'
.ds RLD5      \v'-5p'
.ds RLD5.25   \v'-5.25p'
.ds RLD5.5    \v'-5.5p'
.ds RLD5.75   \v'-5.75p'
.ds RLD6      \v'-6p'
.ds RLD6.25   \v'-6.25p'
.ds RLD6.5    \v'-6.5p'
.ds RLD6.75   \v'-6.75p'
.ds RLD7      \v'-7p'
.ds RLD7.25   \v'-7.25p'
.ds RLD7.5    \v'-7.5p'
.ds RLD7.75   \v'-7.75p'
.ds RLD8      \v'-8p'
.ds RLD8.25   \v'-8.25p'
.ds RLD8.5    \v'-8.5p'
.ds RLD8.75   \v'-8.75p'
.ds RLD9      \v'-9p'
.ds RLD9.25   \v'-9.25p'
.ds RLD9.5    \v'-9.5p'
.ds RLD9.75   \v'-9.75p'
.ds RLD10     \v'-10p'
.ds RLD10.25  \v'-10.25p'
.ds RLD10.5   \v'-10.5p'
.ds RLD10.75  \v'-10.75p'
.ds RLD11     \v'-11p'
.ds RLD11.25  \v'-11.25p'
.ds RLD11.5   \v'-11.5p'
.ds RLD11.75  \v'-11.75p'
.ds RLD12     \v'-12p'
.ds RLD12.25  \v'-12.5p'
.ds RLD12.5   \v'-12.5p'
.ds RLD12.75  \v'-12.75p'
\#
\# =====================================================================
\#
\# +++REFINEMENTS+++
\#
\# AUTOMATIC LIGATURES
\# -------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns automatic ligature generation on or off.
\# *Notes:
\#   Ligatures may be supplied manually with \[fi], \[fl], etc.
\#
.MAC LIGATURES END
.    ie '\\$1'' \{\
.       lg
.       nr #LIGATURES 1
.    \}
.    el \{\
.       lg 0
.       nr #LIGATURES 0
.    \}
.END
\#
\# SMARTQUOTES
\# -----------
\# *Arguments:
\#   [ ,, ] | [ << ] | [ >> ] | <anything>
\#   or
\#   [ DA | DE | EN | ES | FR | IT | NL | NO | PT | SV ] | <anything>
\# *Function:
\#   Turns smartquotes on (optionally with a quoting style from the
\#   argument list, or off).
\#   If no quoting style is given, then EN (English) is used by default.
\#   If no quoting style is given and smart quotes have been turned off
\#   previously, the old quoting style will be restored.
\# *Notes:
\#   The " character is read outside the macro when mom is
\#   processed.  The strings for open/close ($QUOTE<n>) are then
\#   defined in the macro.
\#
.char " \\*[$QUOTE\\n[#OPEN_CLOSE]]\R'#OPEN_CLOSE (1-\\n[#OPEN_CLOSE])'
.nr #SQ_ON 0
\#
.MAC SMARTQUOTES END
.\" First " will be translated to $QUOTE0
.    nr #OPEN_CLOSE 0
.    if '\\$1'' \{\
.       if !'\\*[$RESTORE_SQ]'' \{\
.          SMARTQUOTES \\*[$RESTORE_SQ]
.          return
.       \}
.\" Default smart quotes (English)
.       ds $QUOTE0 \[lq]
.       ds $QUOTE1 \[rq]
.       ds $RESTORE_SQ EN
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1',,' \{\
.       ds $QUOTE0 \[Bq]
.       ds $QUOTE1 \[lq]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'<<' \{\
.       ds $QUOTE0 \[Fo]
.       ds $QUOTE1 \[Fc]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'>>' \{\
.       ds $QUOTE0 \[Fc]
.       ds $QUOTE1 \[Fo]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'DA' \{\
.       ds $QUOTE0 \[Fc]
.       ds $QUOTE1 \[Fo]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'DE' \{\
.       ds $QUOTE0 \[Bq]
.       ds $QUOTE1 \[lq]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'EN' \{\
.       ds $QUOTE0 \[lq]
.       ds $QUOTE1 \[rq]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'ES' \{\
.       ds $QUOTE0 \[lq]
.       ds $QUOTE1 \[rq]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'FR' \{\
.       ds $QUOTE0 \[Fo]\|
.       ds $QUOTE1 \|\[Fc]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'IT' \{\
.       ds $QUOTE0 \[Fo]\|
.       ds $QUOTE1 \|\[Fc]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'NL' \{\
.       ds $QUOTE0 \[rq]
.       ds $QUOTE1 \[rq]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'NO' \{\
.       ds $QUOTE0 \[Fo]
.       ds $QUOTE1 \[Fc]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'PT' \{\
.       ds $QUOTE0 \[Fo]
.       ds $QUOTE1 \[Fc]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.    if '\\$1'SV' \{\
.       ds $QUOTE0 \[Fc]
.       ds $QUOTE1 \[Fc]
.       ds $RESTORE_SQ \\$1
.       nr #SQ_ON 1
.       return
.    \}
.\" None of the above -> turn smartquotes off
.    ds $QUOTE0 \[dq]
.    ds $QUOTE1 \[dq]
.    nr #SQ_ON 0
.END
\#
.ds $QUOTE0 \[lq]
.ds $QUOTE1 \[rq]
\#
\# Strings for foot and inch marks
\#
.ds FOOT \[fm]
.ds INCH \[fm]\[fm]
\#
\# =====================================================================
\#
\# +++LINE BREAKS+++
\#
\# NO-SPACE BREAK
\# --------------
\# *Argument:
\#   <none>
\# *Function:
\#   Breaks a line without advancing.
\# *Notes:
\#   EL is the mnemonic used on older, dedicated typesetting machines
\#   to indicate "process the line, without advancing the galley
\#   medium."  It stands for End Line.
\#
\#   The \c inline must be appended to the end of input lines when in
\#   nofill mode; in fill modes, the \c inline must not be used.
\#
.MAC EL END
.    TRAP OFF
.    if \\n[#PSEUDO_FILL]=1 \&
.    br
.    sp -1v
.    TRAP
.END
\#
\# An inline escape to accomplish the same thing.
\# Preferable, since it works with filled and non-filled copy and
\# doesn't require the user to remember whether to use (or not use)
\# \c.
\#
.ds B \h'|0'\R'#NO_ADVANCE 1'\c
\#
\# =====================================================================
\#
\# +++FILLING/QUADDING/JUSTIFYING+++
\#
\# JUSTIFY
\# -------
\# *Argument:
\#   <none>
\# *Function:
\#   Turns fill on and sets .ad to b.
\# *Notes:
\#   Justifies text left and right.
\#
.MAC JUSTIFY END
.    if \\n[#TAB_ACTIVE]=0 \{\
.       nr #QUAD 1
.       ds $RESTORE_QUAD_VALUE \\*[$QUAD_VALUE]
.    \}
'    ce 0
.    QUAD J
.    if \\n[#PRINT_STYLE]=1 .QUAD L
.    nr #PSEUDO_FILL 0
.END
\#
\# QUAD
\# ----
\# *Arguments:
\#   L | LEFT | R | RIGHT | C | CENTER/CENTRE
\# *Function:
\#   Turns fill on and sets .ad to l, r, or c.
\# *Notes:
\#   Terminology is a problem here.  Some people call quad left
\#   left justified, flush left, or flush left/rag right (and the
\#   reverse for quad right).  Quad center is sometimes called rag
\#   both.  For our purposes, all "quad" modes mean that groff fill
\#   mode is enabled.
\#
.MAC QUAD END
.    br
.    if \\n[#COVERTEXT_PP] \
.       ds $RESTORE_DOC_QUAD \\*[$QUAD_VALUE]
.    ds $QUAD_VALUE \\$1
.    substring $QUAD_VALUE 0 0
.    if \\n[#TAB_ACTIVE]=0 \{\
.       nr #QUAD 1
.       ds $RESTORE_QUAD_VALUE \\*[$QUAD_VALUE]
.    \}
'    ce 0
'    fi
.    if '\\*[$QUAD_VALUE]'L' \{\
.       nr #JUSTIFY 0
.       ad l
.    \}
.    if '\\*[$QUAD_VALUE]'R' \{\
.       nr #JUSTIFY 0
.       ad r
.    \}
.    if '\\*[$QUAD_VALUE]'C' \{\
.       nr #JUSTIFY 0
.       ad c
.    \}
.    if '\\*[$QUAD_VALUE]'J' \{\
.       nr #JUSTIFY 1
.       ad b
.    \}
.    nr #PSEUDO_FILL 0
.END
\#
\# LEFT, RIGHT, AND CENTER
\# -----------------------
\# The purpose of these macros is to allow the user to enter lines
\# of text that will be quadded LRC without having to stick .BR
\# or .br between lines.  For the sake of consistency, all three
\# appear to behave similarly (from the point of view of the user),
\# although the underlying primitives don't.  For this reason, LEFT,
\# RIGHT, and CENTER must be followed by .QUAD [L R C J] or .JUSTIFY
\# to restore text to fill mode.
\#
\# LEFT
\# ----
\# *Argument:
\#   <none>
\# *Function:
\#   Turns fill mode off.  Allows user to quad lines left without
\#   requiring the .BR or .br macro.
\# *Notes:
\#   LEFT simply turns fill off.  Lines that exceed the current LL
\#   will not be broken.  Note that this behaviour differs from the
\#   RIGHT and CENTER macros.
\#
.MAC LEFT END
.    if \\n[#TAB_ACTIVE]=0 \{\
.       rr #QUAD
.       ds $RESTORE_QUAD_VALUE LEFT
.    \}
.    ce 0
.    nf
.    nr #PSEUDO_FILL 1
.\" Fix for a little conflict with DOCTYPE LETTER
.    if '\\n[.z]'LETTERHEAD1' .rr #DATE_FIRST
.END
\#
\# RIGHT
\# -----
\# *Argument:
\#   <none>
\# *Function:
\#   Turns fill on.  Allows user to quad lines right without
\#   requiring the .BR or .br macro.
\# *Notes:
\#   Lines that exceed the current LL will be broken, with the excess
\#   text quadded right.
\#
.MAC RIGHT END
.    if \\n[#TAB_ACTIVE]=0 \{\
.       rr #QUAD
.       ds $RESTORE_QUAD_VALUE RIGHT
.    \}
.    nf
.    rj 100000
.    nr #PSEUDO_FILL 1
.END
\#
\# CENTER
\# ------
\# *Argument:
\#   <none>
\# *Function:
\#   Turns fill off.  Allows user to center lines without
\#   requiring the .BR or .br macro.
\# *Notes:
\#   Lines that exceed the current LL will be broken, with the excess
\#   text centered.
\#
.MAC CENTER END
.    if \\n[#TAB_ACTIVE]=0 \{\
.       rr #QUAD
.       ds $RESTORE_QUAD_VALUE CENTER
.    \}
.    nf
.    ce 100000
.    nr #PSEUDO_FILL 1
.END
\#
\# CENTER BLOCKS OF TYPE
\# ---------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Allows users to centre blocks of type on the page without
\#   altering their quad.
\#
.MAC CENTER_BLOCK END
.    br
.    ie !\\n[.$] .di CENTER*BLOCK
.    el \{\
.       di
.       in \\n[.l]u-\\n[dl]u/2u
.       if \\n[.u] .nr #FILLED 1
.       nf
.       CENTER*BLOCK
.       if \\n[#FILLED] .fi
.       rr #FILLED
.       in
.    \}
.END
\#
.ALIAS CENTRE_BLOCK CENTER_BLOCK
\#
\# =====================================================================
\#
\# +++TABS+++
\#
\# There are two different kinds of tabs: typesetting tabs and
\# string tabs.
\#
\# Typesetting tabs are set with TAB_SET, which requires a tab number,
\# an indent (offset) from the left margin and a length (optionally
\# with a quad direction and an instruction to fill lines).  After tabs
\# are set with TAB_SET, they are called with .TAB n, where "n"
\# corresponds to the number passed to TAB_SET as a valid tab number.
\#
\# String tabs allow the user to mark off tab positions inline.  Tab
\# indents and lengths are calculated from the beginning and end
\# positions of the marks.  Up to 19 string tabs may be created,
\# numbered 1-19.  Once created, they are called with .TAB n,
\# just like typesetting tabs.
\#
\# Setting up string tabs is a two-step procedure.  First, the user
\# enters an input line in which s/he wants to mark off string tabs.
\# The beginning of a tab is marked with \*[STn], where "n" is
\# the desired number of the tab.  The end of the tab is marked
\# with \*[STnX].  All ST's must have a matching STX.  String tabs
\# may be nested.
\#
\# Next, the user invokes .ST n for every string tab defined, and
\# optionally passes quad information to it.  That done, string tabs
\# can be called just like typesetting tabs.
\#
\# Strings for string tab inlines
\# ------------------------------
\# Initialize string tab markers numbered 1 to 19.
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<20 \{\
.   ds ST\n[#LOOP] \Ek[#ST\n[#LOOP]_OFFSET]
.\}
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<20 \{\
.   ds ST\n[#LOOP]X \Ek[#ST\n[#LOOP]_MARK]
.\}
.rr #LOOP
\#
\# These are reserved ST numbers for internal use
.ds ST100  \Ek[#ST100_OFFSET]
.ds ST100X \Ek[#ST100_MARK]
.ds ST101  \Ek[#ST101_OFFSET]
.ds ST101X \Ek[#ST101_MARK]
.ds ST102  \Ek[#ST102_OFFSET]
.ds ST102X \Ek[#ST102_MARK]
.ds ST103  \Ek[#ST103_OFFSET]
.ds ST103X \Ek[#ST103_MARK]
\#
\# QUAD AND SET STRING TABS
\# ------------------------
\# *Arguments:
\#   <stringtab number>  L | R | C | J  [QUAD]
\# *Function:
\#   Creates strings $ST<#>_QUAD_DIR and $ST<#>_FILL, then sets up a
\#   tab based on the collected information.
\# *Notes:
\#   Like TAB_SET, ST invoked without a quad direction will default to LEFT.
\#   If lines should be filled and quadded, use the optional argument QUAD.
\#   N.B. -- indents *must* be turned off before setting string tabs
\#   inside .PAD
\#
.MAC ST END
.    ds $ST\\$1_QUAD_DIR \\$2
.    if \\n[#NUM_ARGS]=3 .ds $ST\\$1_FILL QUAD
.    nr #ST\\$1_LENGTH \\n[#ST\\$1_MARK]-\\n[#ST\\$1_OFFSET]
.    ie \\n[#IN_TAB] \
.       TAB_SET \\$1 \\n[#ST\\$1_OFFSET]u+\\n[#ST_OFFSET]u \
          \\n[#ST\\$1_LENGTH]u \\*[$ST\\$1_QUAD_DIR] \\*[$ST\\$1_FILL]
.    el \
.       TAB_SET \\$1 \\n[#ST\\$1_OFFSET]u \\n[#ST\\$1_LENGTH]u \
          \\*[$ST\\$1_QUAD_DIR] \\*[$ST\\$1_FILL]
.END
\#
\# TAB SET
\# -------
\# *Arguments:
\#   <n>  ident(ipPcm)  length(ipPcm)  [L | R | C | J [QUAD]]
\# *Function:
\#   Creates macros TABn and TAB n, where "n" is any arbitrary number.
\#   TABn is a typesetting tab (i.e. a tab defined as an indent
\#   from the page left offset plus a line length.)
\# *Notes:
\#   n      = arbitrary digit to identify the tab
\#   indent = indent from left margin; unit of measure required
\#   length = length of tab (unit of measure required; can be
\#            \w'<string>'u--if more than one word in string, surround
\#            with double quotes "\w'<three word string>'"
\#   LRCJ   = quad for tab (left, right, center, justified)
\#            If option QUAD afterwards is not given, quad is line for line
\#            (no fill mode), meaning that there's no need for .BR or .br
\#            between lines.
\#   QUAD   = fill tab (so it behaves as if .QUAD LRC or .JUSTIFY
\#            had been given).
\#
\#   N.B. -- indents *must* be turned off before setting tabs
\#
\# Tabs are not columnar in behaviour.  .TN and \*[TB+] permit
\# bottom-line to bottom-line tab movement.
\#
\# When resetting tabs, .TQ must be invoked before .TAB_SET.
\#
\# Indents are turned off automatically whenever a new tab is called
\# with TAB <n>.
\#
\# Generally, it's a good idea to make sure all indents are off
\# before setting tabs.
\#
.MAC TAB_SET END
.    br
.    nr #TAB_NUMBER \\$1
.    ds $CURRENT_TAB \\n[#TAB_NUMBER]
.    nr #TAB_OFFSET (\\$2)
.    nr #TAB_LENGTH (\\$3)
.    MAC TAB\\n[#TAB_NUMBER]
.        if !\\\\n[#TB+]=1 .br
.        if \\\\n[#TB+]=1 \{\
.           EL
.           vpt 0
.           rr #TB+
.        \}
.        in 0
.        nr #TAB_ACTIVE 1
.        nr #CURRENT_TAB \\n[#TAB_NUMBER]
.        ds $CURRENT_TAB \\*[$CURRENT_TAB]
.        nr #TAB_OFFSET\\*[$CURRENT_TAB] \\n[#TAB_OFFSET]
.        nr #ST_OFFSET \\n[#TAB_OFFSET]
.        ie !'\\\\n[.z]'' \
\!.         po \\\\\\\\n[#L_MARGIN]u+\\\\n[#TAB_OFFSET\\\\*[$CURRENT_TAB]]u
.        el \
.           po \\\\n[#L_MARGIN]u+\\\\n[#TAB_OFFSET\\\\*[$CURRENT_TAB]]u
.        ll \\n[#TAB_LENGTH]u
.        ta \En[.l]u
.        ie '\\$5'QUAD' \{\
.           if '\\$4'L' .QUAD L
.           if '\\$4'R' .QUAD R
.           if '\\$4'C' .QUAD C
.           if '\\$4'J' .JUSTIFY
.        \}
.        el \{\
.           if '\\$4''  .LEFT
.           if '\\$4'L' .LEFT
.           if '\\$4'R' .RIGHT
.           if '\\$4'C' .CENTER
.           if '\\$4'J' .JUSTIFY
.        \}
.        if \\\\n[#TN]=1 \{\
.           TRAP
.           rr #TN
.        \}
..
.    rr #TAB_ACTIVE
.END
\#
\# TAB
\# ---
\# *Arguments:
\#   <tab number to tab into>
\# *Function:
\#   Moves to tab number passed as an argument.
\#
.MAC TAB END
.    ds $TAB_NUMBER \\$1
.    TAB\\*[$TAB_NUMBER]
.    nr #IN_TAB 1
.END
\#
\# TAB NEXT
\# --------
\# *Argument:
\#   <none>
\# *Function:
\#   Automatically moves to TAB<n+1> on the same line as the last
\#   line of the previous tab.
\# *Notes:
\#   The \c inline must be appended to the end of input lines when in
\#   nofill mode; in fill modes, the \c inline must not be used.
\#
.MAC TN END
.    nr #TN 1
.    vpt 0
.    sp -1v
.    nr #NEXT_TAB \\n[#CURRENT_TAB]+1
.    TAB\\n[#NEXT_TAB]
.    vpt
.END
\#
\# An inline escape to accomplish the same thing.  Preferable, since
\# it works with filled and non-filled copy and doesn't require the
\# user to remember to use (or not use) the \c.
\#
.ds TB+ \
"\c\R'#TB+ 1'\R'#TN 1'\R'#NEXT_TAB \\n[#CURRENT_TAB]+1'\\*[TAB\\n[#NEXT_TAB]]\c
\#
\# TAB QUIT
\# --------
\# *Argument:
\#   <none>
\# *Function:
\#   Sets #TAB_ACTIVE to "0" (off).
\#   Resets left margin to value in effect prior to tabs.
\#   Resets line length to value in effect prior to tabs.
\#   Checks #QUAD to see if we were in flush or quad mode
\#   prior to tabs (0=off, 1=on).
\#   Resets QUAD [ L|R|C ], LEFT, RIGHT, CENTER, or JUSTIFY
\#   in effect prior to tabs.
\# *Notes:
\#   TQ must precede setting new tabs to get the tabs' indents
\#   measured from page left.  Otherwise, the tabs' indents are
\#   measured from the left margin of the currently active tab.
\#
.MAC TQ END
.    br
.    rr #TAB_ACTIVE
.    rr #IN_TAB
.    nr #LOOP 0 1
.    while \\n+[#LOOP]<20 \{\
.       rm $ST\\n[#LOOP]_FILL
.    \}
.    rr #LOOP
.    ie '\\n[.z]'FLOAT*DIV' \{\
\!.     po \\n[#L_MARGIN]u
\!.     ll \\n[#L_LENGTH]u
.    \}
.    el \{\
.       po \\n[#L_MARGIN]u
.       ll \\n[#L_LENGTH]u
.    \}
.    ll \\n[#L_LENGTH]u
.    ta \\n[.l]u
.    ie \\n[#QUAD] \{\
.       ie '\\*[$RESTORE_QUAD_VALUE]'J' .JUSTIFY
.       el .QUAD \\*[$RESTORE_QUAD_VALUE]
.    \}
.    el \{\
.       if '\\*[$RESTORE_QUAD_VALUE]'LEFT' .LEFT
.       if '\\*[$RESTORE_QUAD_VALUE]'RIGHT' .RIGHT
.       if '\\*[$RESTORE_QUAD_VALUE]'CENTER' .CENTER
.    \}
.END
\#
\# ====================================================================
\#
\# COLOR HANDLING
\# ==============
\#
\# COLOR
\# -----
\# *Arguments:
\#   <pre-defined NEWCOLOR or XCOLOR>
\# *Function:
\#   Allows the inline escape for setting color to be called
\#   as a macro.
\#
.MAC COLOR END
.    ie \\n[.u]=1 \{\
\c
\\*[\\$1]\c
.    \}
.    el \\*[\\$1]
.END
\#
\# NEWCOLOR
\# --------
\# *Arguments:
\#   <color name> [<color scheme>] <color definition>
\# *Function:
\#   Based on .defcolor, allows users to name and define colors using
\#   one of the four color schemes rgb, cmy, cmyk and grey.  The new
\#   color is then defined as a string so that it can be called inline
\#   with \*[COLORNAME] or with .COLOR.
\# *Notes:
\#   With only two args, the default color scheme is rgb.
\#
\#   It is highly recommended that users define new colors as
\#   all-cap strings, to differentiate them from x colors, which must
\#   be in lower case.
\#
.MAC NEWCOLOR END
.    if \\n[#NUM_ARGS]=2 .defcolor \\$1 rgb \\$2
.    if \\n[#NUM_ARGS]=3 \{\
.       if '\\$2'RGB' .ds $COLOR_SCHEME rgb
.       if '\\$2'CYM' .ds $COLOR_SCHEME cym
.       if '\\$2'CMYK' .ds $COLOR_SCHEME cmyk
.       if '\\$2'GRAY' .ds $COLOR_SCHEME gray
.       if '\\$2'GREY' .ds $COLOR_SCHEME gray
.       defcolor \\$1  \\*[$COLOR_SCHEME] \\$3
.    \}
.    ds \\$1 \\m[\\$1]
.END
\#
\# XCOLOR
\# ------
\# *Arguments:
\#   <x color name> [<alias>]
\# *Function:
\#   Defines a string of x color name (i.e. a predefined x
\#   color).  If <alias> is given, creates a string of <alias name>
\#   that references the x color name of the first argument.
\# *Notes:
\#   The color name must be a valid color name from rgb.txt, and
\#   must be given entirely in lower case, all one word.
\#
.MAC XCOLOR END
.    ds \\$1 \m[\\$1]
.    if \\n[#NUM_ARGS]=2 \{\
.       ds \\$2 \m[\\$1]
.       ds $\\$2_FILL \\$1
.       ds COLAL_\\$2 \\$1
.    \}
.END
\#
\# Pre-define xcolors black and white
\#
.ds black   \m[black]
.ds BLACK   \m[black]
.ds white   \m[white]
.ds WHITE   \m[white]
.ds default black
\#
\# =====================================================================
\#
\# +++MISCELLANEOUS USEFUL MACROS AND STRINGS+++
\#
.nr _w 500
.nr _d 1250
\#
\# These string are used for creating aliases within loops that set
\# style for doc-cover, cover, and docheader items.  They're defined
\# here because underscoring needs them.
\#
.ds TITLE_TYPE_1  ATTRIBUTE
.ds TITLE_TYPE_2  AUTHOR
.ds TITLE_TYPE_3  CHAPTER
.ds TITLE_TYPE_4  CHAPTER_TITLE
.ds TITLE_TYPE_5  COVERTITLE
.ds TITLE_TYPE_6  DOCTITLE
.ds TITLE_TYPE_7  DOCTYPE
.ds TITLE_TYPE_8  DOC_COVERTITLE
.ds TITLE_TYPE_9  SUBTITLE
.ds TITLE_TYPE_10 TITLE
.ds TITLE_TYPE_11 MISC
.ds TITLE_TYPE_12 COPYRIGHT
.ds TITLE_TYPE_13 DOC_COVER_TITLE
.ds TITLE_TYPE_14 COVER_TITLE
\#
\# UNDERLINE
\# ---------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Simulates typewriter-style underlining of italic passages.
\# *Notes:
\#   Defaults for rule weight and distance from baseline are below.
\#   UNDERLINE_SPECS lets user change them
\#
.MAC UNDERLINE_SPECS END
.    ie \B'\\$1' .nr _w (u;\\$1)
.    el \{\
.       ie '\\$1'DEFAULT' .nr _w 500
.       el \{\
.          nr _w 500
.          tm1 "[mom]: The first argument to \\$0 must be a numeric
.          tm1 "       argument with a unit of measure appended, or DEFAULT.
.          tm1 "       Setting underline weight to DEFAULT.
.       \}
.    \}
.    shift
.    ie \B'\\$1' .nr _d (u;\\$1)
.    el \{\
.       ie '\\$1'DEFAULT' .nr _d 1250
.       el \{\
.          nr _d 1250
.          tm1 "[mom]: The second argument to \\$0 must be a numeric
.          tm1 "       argument with a unit of measure appended, or DEFAULT.
.          tm1 "       Setting underline distance from baseline to DEFAULT.
.       \}
.    \}
.END
\#
.MAC UNDERLINE END
\c
.    ds $SAVED_SS_VAR \\*[$SS_VAR]
.    ie '\\$1'' \{\
.       nr #UNDERLINE_ON 1
.       ss \\n[.ss] (\\n[.ss]-\\n[.ss])
.       ie !n .nop \X'ps: exec \\n[_w] \\n[_d] decorline'\c
.       el .ul 1000
.    \}
.    el \{\
.       nr #UNDERLINE_ON 0
.       if !'\\*[$SAVED_SS_VAR]'' .SS \\*[$SAVED_SS_VAR]
.       ie !n .nop \X'ps: exec decornone'\c
.       el .ul 0
.    \}
.END
\#
\# UL/ULX
\# ------
\# *Arguments:
\#   <none>
\# *Function:
\#   Simulates typewriter-style underlining of italic passages.
\# *Notes:
\#   Intended to be called with inline escapes \*[UL] (underline
\#   on) and \*[ULX] (underline off).
\#
.MAC UL END
\c
.    ds $SAVED_SS_VAR \\*[$SS_VAR]
.    ss \\n[.ss] (\\n[.ss]-\\n[.ss])
.    ie !'\\n[.z]'' \{\
\c
.       ie !n \{\
.          if !\\n[.k]=0 \?\h'-\w'\\n[.ss]'u'\?
\?\R'#UNDERLINE_ON 1'\X'ps: exec \\n[_w] \\n[_d] decorline'\?\c
.       \}
.       el \{\
\?\R'#UNDERLINE_ON 1'\?\c
.          ul 1000
.       \}
.    \}
.    el \{\
.       ie !n \{\
.          nr #UNDERLINE_ON 1
.          nop \X'ps: exec \\n[_w] \\n[_d] decorline'\c
.       \}
.       el \{\
\R'#UNDERLINE_ON 1'\c
.          ul 1000
.       \}
.    \}
.END
\#
.MAC ULX END
\c
.    SS \\*[$SAVED_SS_VAR]
.    rm $SAVED_SS_VAR
.    ie !'\\n[.z]'' \{\
\c
.       ie !n \{\
\?\R'#UNDERLINE_ON 0'\X'ps: exec decornone'\?\c
.       \}
.       el \{\
\?\R'#UNDERLINE_ON 0'\?\c
.          ul 0
.       \}
.    \}
.    el \{\
.       ie !n \{\
.          nr #UNDERLINE_ON 0
.          nop \X'ps: exec decornone'\c
.       \}
.       el \{\
.          nr #UNDERLINE_ON 0
.          ul 0
.       \}
.    \}
.END
\#
\# UNDERSCORE
\# ----------
\# *Arguments:
\#   [<points below baseline>] "text"
\# *Function:
\#   Places an underscore 2 points under the string if no lead given,
\#   otherwise places underscore under string by user specified amount.
\# *Notes:
\#   When using this macro, the string to be underscored must begin
\#   with double-quotes ("), regardless of whether it's the sole
\#   argument or the second.
\#   E.g.:
\#      .UNDERSCORE "Text to be underscored
\#         or
\#      .UNDERSCORE 2p "Text to be underscored
\#
\#   UNDERSCORE does not work across line breaks.  Each line of text
\#   must be entered separately.  If the UNDERSCORE begins in the
\#   middle of a line and crosses over a break, the portion before
\#   the break and the portion afterwards must be entered
\#   separately.
\#
.MAC UNDERSCORE END
.    nr #SAVED_UNDERSCORE_WEIGHT     \\n[#UNDERSCORE_WEIGHT]
.    nr #SAVED_UNDERSCORE_WEIGHT_ADJ \\n[#UNDERSCORE_WEIGHT_ADJ]
.    ds $SAVED_UNDERSCORE_GAP        \\*[$UNDERSCORE_GAP]
.    if \\n[#NUM_ARGS]=2 \{\
.       ds $UNDERSCORE_GAP \\$1
.       shift
.    \}
.    if !'\\*[$TITLE_TYPE]'' \{\
.       nr #UNDERSCORE_WEIGHT     \\n[#\\*[$TITLE_TYPE]_UNDERLINE_WEIGHT]
.       nr #UNDERSCORE_WEIGHT_ADJ \\n[#\\*[$TITLE_TYPE]_UNDERLINE_WEIGHT_ADJ]
.       ds $UNDERSCORE_GAP        \\*[$\\*[$TITLE_TYPE]_UNDERLINE_GAP]
.    \}
.    nr #TEXT_WIDTH \w'\\$1'
.    ie \\n[.u]=1 \{\
\Z'\\$1'\
\Z'\D't \\n[#UNDERSCORE_WEIGHT]''\
\v'\\*[$UNDERSCORE_GAP]+\\n[#UNDERSCORE_WEIGHT_ADJ]u'\
\D'l \\n[#TEXT_WIDTH]u 0'\
\Z'\D't \\n[#RULE_WEIGHT]''\
\v'-(\\*[$UNDERSCORE_GAP]+\\n[#UNDERSCORE_WEIGHT_ADJ]u)'\c
.       nop
.    \}
.    el \{\
\Z'\\$1'\
\Z'\D't \\n[#UNDERSCORE_WEIGHT]''\
\v'\\*[$UNDERSCORE_GAP]+\\n[#UNDERSCORE_WEIGHT_ADJ]u'\
\D'l \\n[#TEXT_WIDTH]u 0'\
\Z'\D't \\n[#RULE_WEIGHT]''\
\v'-(\\*[$UNDERSCORE_GAP]+\\n[#UNDERSCORE_WEIGHT_ADJ]u)'
.    \}
.    nr #UNDERSCORE_WEIGHT     \\n[#SAVED_UNDERSCORE_WEIGHT]
.    nr #UNDERSCORE_WEIGHT_ADJ \\n[#SAVED_UNDERSCORE_WEIGHT_ADJ]
.    ds $UNDERSCORE_GAP        \\*[$SAVED_UNDERSCORE_GAP]
.    rr #SAVED_UNDERSCORE_WEIGHT
.    rr #SAVED_UNDERSCORE_WEIGHT_ADJ
.    rm $SAVED_UNDERSCORE_GAP
.    rm $TITLE_TYPE
.END
\#
\# DOUBLE UNDERSCORE
\# -----------------
\# *Arguments:
\#   [points below baseline] [points distance between rules] "text"
\# *Function:
\#   Same as UNDERSCORE, except it produces a double underscore.  The default
\#   distance between the rules is 2 points.
\# *Notes:
\#   The same double-quote requirement as UNDERSCORE.
\#
.MAC UNDERSCORE2 END
.    nr #SAVED_UNDERSCORE_WEIGHT     \\n[#UNDERSCORE_WEIGHT]
.    nr #SAVED_UNDERSCORE_WEIGHT_ADJ \\n[#UNDERSCORE_WEIGHT_ADJ]
.    ds $SAVED_UNDERSCORE_GAP        \\*[$UNDERSCORE_GAP]
.    ds $SAVED_RULE_GAP              \\*[$RULE_GAP]
.    if \\n[#NUM_ARGS]=2 \{\
.       ds $UNDERSCORE_GAP \\$1
.       shift
.    \}
.    if \\n[#NUM_ARGS]=3 \{\
.       ds $UNDERSCORE_GAP \\$1
.       ds $RULE_GAP \\$2
.       shift 2
.    \}
.    if !'\\*[$TITLE_TYPE]'' \{\
.       nr #UNDERSCORE_WEIGHT     \\n[#\\*[$TITLE_TYPE]_UNDERLINE_WEIGHT]
.       nr #UNDERSCORE_WEIGHT_ADJ \\n[#\\*[$TITLE_TYPE]_UNDERLINE_WEIGHT_ADJ]
.       ds $UNDERSCORE_GAP        \\*[$\\*[$TITLE_TYPE]_UNDERLINE_GAP]
.       ds $RULE_GAP              \\*[$\\*[$TITLE_TYPE]_RULE_GAP]
.    \}
.    nr #TEXT_WIDTH \w'\\$1'
.    ie \\n[.u]=1 \{\
\Z'\\$1'\
\Z'\D't \\n[#UNDERSCORE_WEIGHT]''\
\v'\\*[$UNDERSCORE_GAP]+\\n[#UNDERSCORE_WEIGHT_ADJ]u'\
\Z'\D'l \\n[#TEXT_WIDTH]u 0''\
\v'\\*[$RULE_GAP]+\\n[#UNDERSCORE_WEIGHT]u'\
\D'l \\n[#TEXT_WIDTH]u 0'\
\Z'\D't \\n[#RULE_WEIGHT]''\
\v'-(\\*[$UNDERSCORE_GAP]+\\*[$RULE_GAP])-(\\n[#UNDERSCORE_WEIGHT]u*2u)'\c
.    \}
.    el \{\
\Z'\\$1'\
\Z'\D't \\n[#UNDERSCORE_WEIGHT]''\
\v'\\*[$UNDERSCORE_GAP]+\\n[#UNDERSCORE_WEIGHT_ADJ]u'\
\Z'\D'l \\n[#TEXT_WIDTH]u 0''\
\v'\\*[$RULE_GAP]+\\n[#UNDERSCORE_WEIGHT]u'\
\D'l \\n[#TEXT_WIDTH]u 0'\
\Z'\D't \\n[#RULE_WEIGHT]''\
\v'-(\\*[$UNDERSCORE_GAP]+\\*[$RULE_GAP])-(\\n[#UNDERSCORE_WEIGHT]u*2u)'
.    \}
.    nr #UNDERSCORE_WEIGHT     \\n[#SAVED_UNDERSCORE_WEIGHT]
.    nr #UNDERSCORE_WEIGHT_ADJ \\n[#SAVED_UNDERSCORE_WEIGHT_ADJ]
.    ds $UNDERSCORE_GAP        \\*[$SAVED_UNDERSCORE_GAP]
.    rr #SAVED_UNDERSCORE_WEIGHT
.    rr #SAVED_UNDERSCORE_WEIGHT_ADJ
.    rm $SAVED_UNDERSCORE_GAP
.    rm $SAVED_RULE_GAP
.    rm $TITLE_TYPE
.END
\#
\# Default underscoring underline and rule gaps
\#
.ds $BIB_STRING_RULE_GAP      2p
.ds $BIB_STRING_UNDERLINE_GAP 2p
.ds $EN_STRING_RULE_GAP       2p
.ds $EN_STRING_UNDERLINE_GAP  2p
.ds $EN_TITLE_UNDERLINE_GAP   2p
.ds $RULE_GAP                 2p
.ds $TOC_HEADER_RULE_GAP      2p
.ds $TOC_HEADER_UNDERLINE_GAP 2p
.ds $UNDERSCORE_GAP           2p
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<=14 \{\
. ds $\*[TITLE_TYPE_\n[#LOOP]]_RULE_GAP                2p
. ds $COVER_\*[TITLE_TYPE_\n[#LOOP]]_RULE_GAP          2p
. ds $DOC_COVER_\*[TITLE_TYPE_\n[#LOOP]]_RULE_GAP      2p
. ds $\*[TITLE_TYPE_\n[#LOOP]]_UNDERLINE_GAP           2p
. ds $COVER_\*[TITLE_TYPE_\n[#LOOP]]_UNDERLINE_GAP     2p
. ds $DOC_COVER_\*[TITLE_TYPE_\n[#LOOP]]_UNDERLINE_GAP 2p
.\}
\#
\# SUPERSCRIPT
\# -----------
\# *Function:
\#   Prints everything after inline invocation as superscript.
\# *Notes:
\#   \*[SUP] and \*[SUPX] turn superscript on and off respectively.
\#   If running type is pseudo-condensed/expanded, invoke the superscript
\#   strings as \*[CONDSUP] or \*[EXTSUP] and turn off with \*[CONDSUPX]
\#   and \*[EXTSUPX] respectively.
\#
\# Default raise/lower amount
.ds $SUP_RAISE \v'-.3m'
.ds $SUP_LOWER \v'.3m'
\#
\# SUPERSCRIPT RAISE
\# -----------------
\# *Argument:
\#   <amount to raise superscript>
\# *Function:
\#   Defines strings $SUP_RAISE and $SUP_LOWER for use with \*[SUP],
\#   \*[CONDSUP] and \*[EXTSUP].
\#
.MAC SUPERSCRIPT_RAISE_AMOUNT END
.    ds $SUP_RAISE_AMOUNT \\$1
.    ds $SUP_RAISE \v'-\\*[$SUP_RAISE_AMOUNT]'
.    ds $SUP_LOWER \v'\\*[$SUP_RAISE_AMOUNT]'
.END
\#
.ds SUP \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#SUP_PT_SIZE \En[#PT_SIZE_IN_UNITS]u*6u/10u'\
\s[\En[#PT_SIZE_IN_UNITS]u]\E*[$SUP_RAISE]\s[\En[#SUP_PT_SIZE]u]
\#
.ds SUPX \s[\En[#PT_SIZE_IN_UNITS]u]\E*[$SUP_LOWER]
\#
.ds CONDSUP \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#SUP_PT_SIZE \En[#PT_SIZE_IN_UNITS]u*6u/10u'\
\s[\En[#PT_SIZE_IN_UNITS]u]\E*[$SUP_RAISE]\s[\En[#SUP_PT_SIZE]u]\E*[COND_FOR_SUP]
\#
.ds CONDSUPX \s[\En[#PT_SIZE_IN_UNITS]u]\E*[$SUP_LOWER]\E*[COND]
\#
.ds EXTSUP \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#SUP_PT_SIZE \En[#PT_SIZE_IN_UNITS]u*6u/10u'\
\s[\En[#PT_SIZE_IN_UNITS]u]\E*[$SUP_RAISE]\s[\En[#SUP_PT_SIZE]u]\E*[EXT_FOR_SUP]
\#
.ds EXTSUPX \s[\En[#PT_SIZE_IN_UNITS]u]\E*[$SUP_LOWER]\E*[EXT]
\#
\# SLANT
\# -----
\#
\# SETSLANT
\# --------
\# *Arguments:
\#   <number of degrees> | RESET
\# *Function:
\#   Modifies register #DEGREES for use with \*[SLANT], or resets
\#   it to the default.  Defines string \*[SLANTX]
\# *Notes:
\#   \*[SLANT] permits pseudo-italicizing of a font in cases where
\#   no italic font exists in a particular family.
\#
\#   Default # of degrees is 15.
\#
\#   Do not use unit of measure with arg to SETSLANT.
\#
\#   It may be necessary to adjust the spacing on either side of
\#   [SLANT] and [SLANTX].
\#
\#   In docs, SLANT carries over from para to para.
\#
.nr #DEGREES 15
.ds SLANT \ER'#SLANT_ON 1'\ES'\En[#DEGREES]'
.ds SLANTX \ER'#SLANT_ON 0'\ES'0'
\#
.MAC SETSLANT END
.    ie '\\$1'RESET' \{\
.       nr #DEGREES 15
.       if \\n[#PRINT_STYLE]=1 \
.          if \\n[#UNDERLINE_SLANT] .return
.       ds SLANT \ER'#SLANT_ON 1'\ES'\En[#DEGREES]'
.    \}
.    el \{\
.       nr #DEGREES \\$1
.       if \\n[#PRINT_STYLE]=1 \
.          if \\n[#UNDERLINE_SLANT] .return
.       ds SLANT \ER'#SLANT_ON 1'\ES'\En[#DEGREES]'
.    \}
.    ds SLANTX \ER'#SLANT_ON 0'\ES'0'
.END
\#
\# BOLDER
\# ------
\#
\# SETBOLDER
\# ---------
\# *Arguments:
\#   <amount of emboldening> | RESET
\# *Function:
\#   Modifies register #BOLDER_UNITS for use with \*[BOLDER], or resets
\#   it to the default 700 units.
\# *Notes:
\#   \*[BOLDER] allows pseudo-emboldening of a font where no bold
\#   font exists in a particular family.
\#
\#   Default for SETBOLDER is 700 units.  Do not use unit of measure
\#   with arg to SETBOLDER.
\#
.nr #BOLDER_UNITS 700
\#
.MAC SETBOLDER END
.    if \\n[#IGNORE]=1 .return
.    ie '\\$1'RESET' .nr #BOLDER_UNITS 700
.    el              .nr #BOLDER_UNITS \\$1
.END
\#
.MAC BOLDER END
\c
.bd \\n[.f] \\n[#BOLDER_UNITS]
.END
\#
.MAC BOLDERX END
\c
.bd \\n[.f]
.END
\#
\# +++CONDENSE/EXTEND+++
\#
\# CONDENSE/EXTEND
\# ---------------
\# *Arguments:
\#   <percentage to condense/expand type size>
\# *Function:
\#   Stores current point size in z's in #PT_SIZE_IN_UNITS, figures out
\#   new point size (for character width) from arg, and defines string
\#   COND or EXT, which set the type size to the new character width,
\#   and sets the height of type to the value stored in CURRENT_PT_SIZE
\# *Notes:
\#   CONDENSE_OR_EXTEND is invoked from the aliases
\#   CONDENSE and EXTEND.  CONDENSE implies <100, EXTEND
\#   implies >100.  Do not use a percent sign in the argument.
\#
\#   There is no default setting for CONDENSE or EXTEND.
\#   80 is a good approximation of condensed type, 120 is okay
\#   for extended.
\#
\#   The value set by CONDENSE or EXTEND applies to all
\#   subsequent \*[COND] or \*[EXT] escapes until a new value is set.
\#
\#  \*[COND] or \*[EXT] must be turned off before all changes of point
\#  size, and reinvoked afterwards (if so desired).  This refers to
\#  changes of point size via control lines AND via inlines.
\#
.MAC CONDENSE_OR_EXTEND END
.    if '\\$0'CONDENSE' \{\
.       ds $COND_PERCENT \\$1
.       if \\n[#PRINT_STYLE]=1 \{\
.          rm $COND_PERCENT
.          ds $COND_PERCENT 100
.       \}
.       ds COND \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#CONDENSE 1'\
\R'#COND_WIDTH (\En[#PT_SIZE_IN_UNITS]u*\E*[$COND_PERCENT]u)/100'\
\Es[\En[#COND_WIDTH]u]\EH'\En[#PT_SIZE_IN_UNITS]u'
.       ds COND_FOR_SUP \
\R'#COND_WIDTH (\En[#SUP_PT_SIZE]u*\E*[$COND_PERCENT]u)/100'\
\Es[\En[#COND_WIDTH]u]\H'\En[#SUP_PT_SIZE]u'
.    \}
.    if '\\$0'EXTEND' \{\
.       ds $EXT_PERCENT \\$1
.       if \\n[#PRINT_STYLE]=1 \{\
.          rm $EXT_PERCENT
.          ds $EXT_PERCENT 100
.       \}
.       ds EXT \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#EXTEND 1'\
\R'#EXT_WIDTH (\En[#PT_SIZE_IN_UNITS]u*\E*[$EXT_PERCENT]u)/100'\
\Es[\En[#EXT_WIDTH]u]\EH'\En[#PT_SIZE_IN_UNITS]u'
.       ds EXT_FOR_SUP \
\R'#EXT_WIDTH (\En[#SUP_PT_SIZE]u*\E*[$EXT_PERCENT]u)/100'\
\Es[\En[#EXT_WIDTH]u]\H'\En[#EXT_PT_SIZE]u'
.    \}
.END
\#
.ds CONDX \
\ER'#CONDENSE 0'\Es[0]\R'#PT_SIZE_IN_UNITS \En[.ps]'\H'\En[#PT_SIZE_IN_UNITS]u'
.ds EXTX  \
\ER'#EXTEND   0'\Es[0]\R'#PT_SIZE_IN_UNITS \En[.ps]'\H'\En[#PT_SIZE_IN_UNITS]u'
\#
\# +++PAD LINES+++ (insert space)
\#
\# PAD MARKER
\# ----------
\# *Arguments:
\#   <character to use for marking pad points>
\# *Function:
\#   Defines string $PAD_MARKER, used in PAD
\# *Notes:
\#   $PAD_MARKER is normally # (the pound sign).
\#
.MAC PAD_MARKER END
.    ds $PAD_MARKER \\$1
.END
\#
\# PAD
\# ---
\# *Arguments:
\#   "<string of text with padding markers inserted>"
\#   "<id of bookmark created by .PDF_BOOKMARK>"
\# *Function:
\#   Defines and redefines padding character (default=pound sign
\#   unless padding character has been set with PAD_MARKER)
\#   several times so that when the string is output at the end
\#   of the macro, every # has been converted to an equal-sized
\#   amount of padding (blank space) on a line.
\# *Notes:
\#   String tabs may be marked off during PAD.
\#
.MAC PAD END
.    if \\n[.u]=1 .nr fill 1
.    nf
.    if !d$PAD_MARKER .ds $PAD_MARKER #
.    char \\*[$PAD_MARKER] \R'#PAD_COUNT \En[#PAD_COUNT]+1'
.    ds $FAMILY_FOR_PAD \\n[.fam]
.\" .if !n .fp \\n[.fp] \\n[.sty]
.    ds $FONT_FOR_PAD   \\n[.sty]
.    nr #SIZE_FOR_PAD   \\n[.ps]
.    ds $PAD_STRING \\$1
.    as $PAD_STRING \Ekp
.    di PAD_STRING
.    fam \\*[$FAMILY_FOR_PAD]
\f[\\*[$FONT_FOR_PAD]]\s[\\n[#SIZE_FOR_PAD]u]\\*[$PAD_STRING]
.    br
.    di
.    if \\n[#INDENT_ACTIVE] \{\
.       if \\n[#INDENT_LEFT_ACTIVE]  .ll -\\n[#L_INDENT]u
.       if \\n[#INDENT_RIGHT_ACTIVE] .ll -\\n[#R_INDENT]u
.       if \\n[#INDENT_BOTH_ACTIVE]  .ll -\\n[#BR_INDENT]u
.    \}
.    char \\*[$PAD_MARKER] \
\R'#SPACE_TO_END \En[.l]-\En[p]'\R'#PAD_SPACE \En[#SPACE_TO_END]/\En[#PAD_COUNT]'
.    di PAD_STRING
.    fam \\*[$FAMILY_FOR_PAD]
\f[\\*[$FONT_FOR_PAD]]\s[\\n[#SIZE_FOR_PAD]u]\\*[$PAD_STRING]
.    br
.    di
.    if \\n[#INDENT_ACTIVE] \
.       if (\\n[#INDENT_LEFT_ACTIVE]=1):(\\n[#INDENT_BOTH_ACTIVE]) .ll
.    char \\*[$PAD_MARKER] \h'\En[#PAD_SPACE]u'
.    if \\n[#SILENT] .SILENT
.    fam \\*[$FAMILY_FOR_PAD]
\f[\\*[$FONT_FOR_PAD]]\s[\\n[#SIZE_FOR_PAD]u]
.    ie '\\$2'' .nop \\*[$PAD_STRING]
.    el \{\
.       ie !'\\$2'NOBREAK' .pdfhref L -D "\\$2" -E -- \&\\*[$PAD_STRING]
.       el .nop \\*[$PAD_STRING]
.    \}
.    if \\n[#SILENT] .SILENT OFF
.    br
.    if \\n[fill] \{\
.       fi
.       rr fill
.    \}
.    rr #PAD_COUNT
.    rr #SPACE_TO_END
.    rr #PAD_SPACE
.    rm $PAD_STRING
.    rm PAD_STRING
.    rchar \\*[$PAD_MARKER]
.    if '\\$2'NOBREAK' \{\
.       TRAP OFF
.       EOL
.       TRAP
.    \}
.END
\#
\# +++LEADERS+++
\#
\# The leader mechanism is primitive, but it works.  Basically, every
\# macro in this set that includes a line length also sets a single
\# groff tab stop at the right hand end of the line.  That way,
\# whenever Ctrl-A is invoked (always at the end of an input line),
\# leader of the correct length gets deposited.  Ctrl-A is accessed by
\# the string LEADER (i.e. inline, as \*[LEADER]).  Leaders within tabs
\# get their length from the tab line length.
\#
\# SET LEADER CHARACTER
\# --------------------
\# *Arguments:
\#   <character to use whenever \*[LEADER] is invoked>
\# *Function:
\#   Set leader character.
\#
.MAC LEADER_CHARACTER END
.    lc \\$1
.END
\#
.ds LEADER 
\#
\# +++DROP CAPS+++
\#
\# DROP CAP FAMILY
\# ---------------
\# *Argument:
\#   <family of drop cap>
\# *Function:
\#   Creates or modifies string $DC_FAM.
\#
.MAC DROPCAP_FAMILY END
.    ds $DC_FAM \\$1
.END
\#
\# DROP CAP FONT
\# -------------
\# *Argument:
\#   <font of drop cap>
\# *Function:
\#   Creates or modifies string $DC_FT.
\#
.MAC DROPCAP_FONT END
.    ds $DC_FT \\$1
.END
\#
\# DROPCAP COLOR
\# -------------
\# *Arguments:
\#   <pre-defined XCOLOR or NEWCOLOR>
\# *Function:
\#   Defines string $DC_COLOR to argument.
\# *Notes:
\#   User must define an XCOLOR or NEWCOLOR before using
\#   DC_COLOR.
\#
.MAC DROPCAP_COLOR END
.    if \\n[#PRINT_STYLE]=1 .return
.    nr #DC_COLOR 1
.    ds $DC_COLOR \\$1
.END
\#
\# DROP CAP GUTTER
\# ---------------
\# *Argument:
\#   <width of gutter between drop cap and indented text>
\# *Function:
\#   Creates or modifies register #DC_GUT.
\# *Notes:
\#   Requires unit of measure.  Default is 3p.
\#
.MAC DROPCAP_GUTTER END
.    nr #DC_GUT (\\$1)
.END
\#
\# DROP CAP ADJUST
\# ---------------
\# *Argument:
\#   <+|- # of points to in/decrease point size of drop cap letter>
\# *Function:
\#   Creates or modifies string $DC_ADJUST.
\# *Notes:
\#   Despite its best efforts, DROPCAP doesn't always get the point
\#   size of the drop cap critically perfect.  DROPCAP_ADJUST lets
\#   the user add or subtract points (or fractions of points) to
\#   get the size right.
\#
\#   Requires the + or - sign.
\#
.MAC DROPCAP_ADJUST END
.    ds $DC_ADJUST \\$1
.END
\#
\# DROP CAP
\# --------
\# *Arguments:
\#   <dropcap letter> <# of lines> [COND <% to condense> | EXT <% to extend>]
\# *Function:
\#   Calculates point size of dropcap based on # of lines passed as
\#   arg 2.  Sets indent for text based on dropcap width+gutter.
\#   Advances and prints dropcap; reverses and prints indented text
\#   to bottom of dropcap, then resets indent to left margin (plus
\#   any indent that was in effect prior to invoking DROPCAP).
\# *Notes:
\#   Drop caps when using the doc processing macro PP only work with
\#   initial paragraphs (i.e. at doc start, or after heads), only when
\#   DROPCAPS comes immediately after PP, and only when the PRINTSTYLE
\#   is TYPESET.  If these conditions aren't met, DROPCAPS is silently
\#   ignored.
\#
\#   The COND or EXT argument are processed separately from all
\#   other COND or EXT inlines or macros, hence passing COND or
\#   EXT has no effect on running type.
\#
.MAC DROPCAP END
.    if \\n[#IGNORE]=1 \{\
.       PRINT \\$1\c
.       return
.    \}
.    br
.    if n \{\
.       PRINT \\$1\c
.       return
.    \}
.    if \\n[#DOCS] \{\
.       if \\n[#PRINT_STYLE]=1 \{\
.          PRINT \\$1\c
.          return
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          sp -1
.          if \\n[#PP_STYLE]=2 \{\
.             PRINT \\$1\c
.             return
.          \}
.          if \\n[#PP]>1 \{\
.             if \\n[#PP_INDENT] .ti \\n[#PP_INDENT]u
.             PRINT \\$1\c
.             return
.          \}
.          ti 0
.       \}
.    \}
.    ds $DROPCAP         \\$1
.    nr #DC_LINES        \\$2-1
.    if \\n[#CONDENSE]=1 \{\
.       ds $RESTORE_COND \\*[$COND_PERCENT]
\\*[CONDX]
.       nr #CONDENSE_WAS_ON 1
.    \}
.    if \\n[#EXTEND]=1 \{\
.       ds $RESTORE_EXT \\*[$EXT_PERCENT]
\\*[EXTX]
.       nr #EXTEND_WAS_ON 1
.    \}
.    if '\\$3'COND' .CONDENSE \\$4
.    if '\\$3'EXT' .EXTEND \\$4
.    if !r#DC_GUT .nr #DC_GUT 3p
.    ie \\n[#DOCS] .ds $RESTORE_FAM \\*[$DOC_FAM]
.    el .ds $RESTORE_FAM \\n[.fam]
.    ie \\n[#DOCS] .ds $RESTORE_FT  \\*[$PP_FT]
.    el .ds $RESTORE_FT  \\*[$FONT]
.    nr #RESTORE_PT_SIZE \\n[#PT_SIZE]
.    nr #RESTORE_INDENT  \\n[.i]
.    SIZESPECS
.    nr #DC_HEIGHT \\n[#DC_LINES]*\\n[#LEAD]+\\n[#CAP_HEIGHT]
.    ie !d$DC_FAM .FAM \\n[.fam]
.    el .FAM \\*[$DC_FAM]
.    ie !d$DC_FT .FT \\*[$FONT]
.    el .FT \\*[$DC_FT]
.    while \\n[#GET_DC_HEIGHT]<\\n[#DC_HEIGHT] \{\
.       ps \\n[#PT_SIZE]u+100u
.       SIZESPECS
.       nr #GET_DC_HEIGHT \\n[#CAP_HEIGHT]
.    \}
.    if d$DC_ADJUST .ps \\*[$DC_ADJUST]p
.    nr #DC_LINES +1
.    if \\n[#DC_LINES]v>\\n[.t] \{\
.       nr pgnum \\n%+\\n[#PAGE_NUM_ADJ] 1
.       if \\n[#COLUMNS]=1 .ds col-num ", column \\n[#COL_NUM]
.       tm1 \
"[mom]: Dropcap at line \\n[.c] does not fit on page \\n[pgnum]\\*[col-num].
.       tm1 \
"       Shifting paragraph to next page or column.
.       ie \\n[#COLUMNS] .COL_NEXT
.       el .NEWPAGE
.    \}
.    ie \\n[#DC_COLOR]=1 \{\
.       ie !'\\$3'' \{\
.          ie '\\$3'COND' \
.             PRINT \
\\*[DOWN \\n[#DC_LINES]v]\
\m[\\*[$DC_COLOR]]\\*[COND]\\*[$DROPCAP]\\*[CONDX]\m[]\\*[UP \\n[#DC_LINES]v]
.          el \
.             PRINT \
\\*[DOWN \\n[#DC_LINES]v]\
\m[\\*[$DC_COLOR]]\\*[EXT]\\*[$DROPCAP]\\*[EXTX]\m[]\\*[UP \\n[#DC_LINES]v]
.       \}
.       el .PRINT \
\\*[DOWN \\n[#DC_LINES]v]\
\m[\\*[$DC_COLOR]]\\*[$DROPCAP]\m[]\\*[UP \\n[#DC_LINES]v]
.    \}
.    el \{\
.       ie !'\\$3'' \{\
.          ie '\\$3'COND' \
.             PRINT \
\\*[DOWN \\n[#DC_LINES]v]\
\\*[COND]\\*[$DROPCAP]\\*[CONDX]\\*[UP \\n[#DC_LINES]v]
.          el \
.             PRINT \
\\*[DOWN \\n[#DC_LINES]v]\
\\*[EXT]\\*[$DROPCAP]\\*[EXTX]\\*[UP \\n[#DC_LINES]v]
.       \}
.       el .PRINT \
\\*[DOWN \\n[#DC_LINES]v]\
\\*[$DROPCAP]\\*[UP \\n[#DC_LINES]v]
.    \}
.    if '\\$3'COND' \E*[COND]
.    if '\\$3'EXT' \E*[EXT]
.    ie \\n[.i] \{\
.       vs 0
.       br
.       in +\w'\\*[$DROPCAP]'u+\\n[#DC_GUT]u
.       vs
.    \}
.    el \{\
.       vs 0
.       br
.       in \w'\\*[$DROPCAP]'u+\\n[#DC_GUT]u
.       vs
.    \}
.    if '\\$3'COND' \E*[CONDX]\c
.    if '\\$3'EXT' \E*[EXTX]\c
.    FAM \\*[$RESTORE_FAM]
.    FT  \\*[$RESTORE_FT]
.    ps \\n[#RESTORE_PT_SIZE]u
.    if \\n[#CONDENSE_WAS_ON] \{\
.       CONDENSE \\*[$RESTORE_COND]
\\*[COND]\c
.    \}
.    if \\n[#EXTEND_WAS_ON] \{\
.       EXTEND \\*[$RESTORE_EXT]
\\*[EXT]\c
.    \}
.    ie \\n[.u] .wh \\n[.d]u+\\n[#DC_HEIGHT]u-1v DROPCAP_OFF
.    el .wh \\n[.d]u+\\n[#DC_HEIGHT]u DROPCAP_OFF
.    rr #CONDENSE_WAS_ON
.    rr #EXTEND_WAS_ON
.    rm $DROPCAP
.    rr #DC_LINES
.    rm $RESTORE_COND
.    rm $RESTORE_EXT
.    rm $RESTORE_FAM
.    rm $RESTORE_FT
.    rr #RESTORE_PT_SIZE
.    rr #RESTORE_INDENT
.    rr #DC_HEIGHT
.    rr #GET_DC_HEIGHT
.    rr x
.END
\#
.MAC DROPCAP_OFF END
'    in \\n[#RESTORE_INDENT]u
.    ch DROPCAP_OFF
.END
\#
\# =====================================================================
\#
\# +++GRAPHICAL OBJECTS+++
\#
\# Set params for graphical objects.
\#
.MAC GRAPHICAL_OBJ END
.    rr #FILLED
.    rr #FILL_MODE
.    rr #NOFILL
.    rr #NOFILL_MODE
.    if \\n[.vpt]=1 \{\
.       vpt 0
.       nr #RESTORE_TRAP 1
.    \}
.    ie !\\n[#NO_ADVANCE]=1 .br
.    el \{\
.       sp -1v
.       rr #NO_ADVANCE
.    \}
.    ie \\n[.u]=1 \{\
.       nr #FILLED 1
.       nr #FILL_MODE \\n[.j]
.    \}
.    el \{\
.       nr #NOFILL 1
.       if \\n[.ce]>0 .nr #NOFILL_MODE 3
.       if \\n[.rj]>0 .nr #NOFILL_MODE 5
.       ce 0
.       rj 0
.    \}
.    nf
.END
\#
\# HORIZONTAL RULE - DRH
\# ---------------------
\# *Arguments:
\#   <none> | <rule weight> <indent> <length> [ <color> ]
\# *Function:
\#   With no arg, draws a full measure rule.  With args, draws
\#   described horizontal rule.
\# *Notes:
\#   Rules are drawn left-to-right, from the baseline down, and
\#   return to their point of origin.  Color must be set in the
\#   macro; otherwise the color will be black, regardless of current
\#   .gcolor.  If no arg given, the rule weight is the one set by
\#   RULE_WEIGHT.
\#
.MAC DRH END
.    GRAPHICAL_OBJ
.    ds $RL_WEIGHT \\$1
.    ds $RL_INDENT \\$2
.    ds $RL_LENGTH \\$3
.    ie !'\\$4'' .ds $RL_COLOR  \\$4
.    el          .ds $RL_COLOR \\*[default]
.    nr #SAVED_WEIGHT     \\n[#RULE_WEIGHT]
.    nr #SAVED_WEIGHT_ADJ \\n[#RULE_WEIGHT_ADJ]
.    di NULL
.       if \\n[#NUM_ARGS]>=1 .RULE_WEIGHT \\*[$RL_WEIGHT]
.    di
.    COLOR \\*[$RL_COLOR]
.    ie \\n[#NUM_ARGS]=0 \{\
.       ie \\n[#INDENT_ACTIVE] \{\
.          nr #RESTORE_L_LENGTH \\n[.l]
.          if \\n[#INDENT_BOTH_ACTIVE] .ll \\n[.l]u-\\n[#BL_INDENT]u
.          if \\n[#INDENT_LEFT_ACTIVE] .ll \\n[.l]u-\\n[#L_INDENT]u
\D't \\n[#RULE_WEIGHT]'\
\h'\\*[$RL_INDENT]-\\n[#RULE_WEIGHT]u'\
\v'\\n[#RULE_WEIGHT_ADJ]u'\
\D'l \En[.l]u 0'\v'-\\n[#RULE_WEIGHT_ADJ]u'\
\v'-\\n[#RULE_WEIGHT_ADJ]u'\
\D't \\n[#SAVED_RULE_WEIGHT]'
.          ll \\n[#RESTORE_L_LENGTH]u
.          rr #RESTORE_L_LENGTH
.       \}
.       el \{\
\D't \\n[#RULE_WEIGHT]'\
\h'\\*[$RL_INDENT]-\\n[#RULE_WEIGHT]u'\
\v'\\n[#RULE_WEIGHT_ADJ]u'\
\D'l \En[.l]u 0'\v'-\\n[#RULE_WEIGHT_ADJ]u'\
\v'-\\n[#RULE_WEIGHT_ADJ]u'\
\D't \\n[#SAVED_RULE_WEIGHT]'
.       \}
.    \}
.    el \{\
\D't \\n[#RULE_WEIGHT]'\
\h'\\*[$RL_INDENT]-\\n[#RULE_WEIGHT]u'\
\v'\\n[#RULE_WEIGHT_ADJ]u'\
\D'l \\*[$RL_LENGTH] 0'\
\v'-\\n[#RULE_WEIGHT_ADJ]u'\
\D't \\n[#SAVED_RULE_WEIGHT]'
.          rr #RESTORE_L_LENGTH
.    \}
.    if \\n[#FILLED]=1 \{\
.       if \\n[#FILL_MODE]=0 .QUAD LEFT
.       if \\n[#FILL_MODE]=1 .JUSTIFY
.       if \\n[#FILL_MODE]=3 .QUAD CENTER
.       if \\n[#FILL_MODE]=5 .QUAD RIGHT
.       rr #FILLED
.    \}
.    sp -1v
.    if \\n[#NOFILL]=1 \{\
.       if \\n[#NOFILL_MODE]=3 .CENTER
.       if \\n[#NOFILL_MODE]=5 .RIGHT
.    \}
.    gcolor
.    nr #RULE_WEIGHT     \\n[#SAVED_WEIGHT]
.    nr #RULE_WEIGHT_ADJ \\n[#SAVED_WEIGHT_ADJ]
.    rr #SAVED_WEIGHT
.    rr #SAVED_WEIGHT_ADJ
.    if \\n[#RESTORE_TRAP]=1 \{\
.       vpt
.       rr #RESTORE_TRAP
.    \}
.    if '\\n[.z]'FLOAT*DIV' \
.       if !(\\n[.d]+\\n[#WEIGHT])<\\n[D-float] .nr D-float \\n[.d]+\\n[#WEIGHT]
.END
\#
\# RULE
\# ----
\# *Argument:
\#   <none>
\# *Function:
\#   Draws a rule the length of the current measure.
\# *Notes:
\#   A convenience macro.  DRH with no argument does the same thing.
\#   Kept in for backward compatibility.
\#
.MAC RULE END
.    if \\n[.u]=1 \{\
.       nr fill 1
.       ds $CURRENT_QUAD \\*[$QUAD_VALUE]
.       nf
.    \}
.    ie \\n[#INDENT_ACTIVE] \{\
.       if \\n[#INDENT_BOTH_ACTIVE] .ll \\n[.l]u-\\n[#BL_INDENT]u
.       if \\n[#INDENT_LEFT_ACTIVE] .ll \\n[.l]u-\\n[#L_INDENT]u
.       PRINT \
\D't \\n[#RULE_WEIGHT]'\v'\\n[#RULE_WEIGHT_ADJ]u'\
\h'-\\n[#RULE_WEIGHT]u'\
\D'l \En[.l]u 0'\v'-\\n[#RULE_WEIGHT_ADJ]u'\h'|0'\c
.       ll
.       rr #RESTORE_L_LENGTH
.    \}
.    el \{\
.       PRINT \
\D't \\n[#RULE_WEIGHT]'\v'\\n[#RULE_WEIGHT_ADJ]u'\
\h'-\\n[#RULE_WEIGHT]u'\
\D'l \En[.l]u 0'\v'-\\n[#RULE_WEIGHT_ADJ]u'\h'|0'\c
.    \}
.    if \\n[fill] \{\
.       fi
.       rr fill
.       QUAD \\*[$CURRENT_QUAD]
.       rm $CURRENT_QUAD
.    \}
.    EOL
.END
\#
\# VERTICAL RULE - DRV
\# -------------------
\# *Arguments:
\#   <rule weight> <indent> <depth> [ <color> ]
\# *Function:
\#   Draws described vertical rule.
\# *Notes:
\#   Rules are drawn left-to-right, from the baseline down, and
\#   return to their point of origin.  Color must be set in the
\#   macro; otherwise the color will be black, regardless of current
\#   .gcolor.
\#
.MAC DRV END
.    GRAPHICAL_OBJ
.    ds $RL_WEIGHT \\$1
.    ds $RL_INDENT \\$2
.    ds $RL_DEPTH  \\$3
.    ie !'\\$4'' \
.       ds $RL_COLOR  \\$4
.    el .ds $RL_COLOR \\*[default]
.    nr #SAVED_WEIGHT     \\n[#RULE_WEIGHT]
.    nr #SAVED_WEIGHT_ADJ \\n[#RULE_WEIGHT_ADJ]
.    RULE_WEIGHT \\*[$RL_WEIGHT]
.    COLOR \\*[$RL_COLOR]
\D't \\n[#RULE_WEIGHT]'\
\h'\\*[$RL_INDENT]-\\n[#RULE_WEIGHT_ADJ]u'\
\D'l 0 \\*[$RL_DEPTH]'\
\D't \\n[#SAVED_RULE_WEIGHT]'
.    if \\n[#FILLED]=1 \{\
.       if \\n[#FILL_MODE]=0 .QUAD LEFT
.       if \\n[#FILL_MODE]=1 .JUSTIFY
.       if \\n[#FILL_MODE]=3 .QUAD CENTER
.       if \\n[#FILL_MODE]=5 .QUAD RIGHT
.       rr #FILLED
.    \}
.    sp -1v
.    if \\n[#NOFILL]=1 \{\
.       if \\n[#NOFILL_MODE]=3 .CENTER
.       if \\n[#NOFILL_MODE]=5 .RIGHT
.    \}
.    gcolor
.    nr #RULE_WEIGHT     \\n[#SAVED_WEIGHT]
.    nr #RULE_WEIGHT_ADJ \\n[#SAVED_WEIGHT_ADJ]
.    if \\n[#RESTORE_TRAP]=1 \{\
.       vpt
.       rr #RESTORE_TRAP
.    \}
.    if '\\n[.z]'FLOAT*DIV' \
.       if !(\\n[.d]+\\*[$RL_DEPTH])<\\n[D-float] .nr D-float \\n[.d]+\\*[$RL_DEPTH]
.END
\#
\# BOXES - DBX
\# -----------
\# *Arguments:
\#   <rule weight> | SOLID> <indent> <length> <depth> [ <color> ]
\# *Function:
\#   Draws described box.
\# *Notes:
\#   Boxes are drawn left-to-right, from the baseline down, and
\#   return to their point of origin.  Box rules are drawn from the
\#   perimeter inwards.  Color must be set in the macro; otherwise
\#   the color will be black, regardless of current .gcolor.  If no
\#   arg given, the rule weight is the one set by RULE_WEIGHT.
\#
.MAC DBX END
.    GRAPHICAL_OBJ
.    ie '\\$1'SOLID' .nr #BX_SOLID 1
.    el              .ds $BX_WEIGHT \\$1
.    ds $BX_INDENT \\$2
.    ds $BX_WIDTH  \\$3
.    ds $BX_DEPTH  \\$4
.    ie !'\\$5'' \{\
.       ie d$\\$5_FILL .ds $BX_COLOR \\*[$\\$5_FILL]
.       el             .ds $BX_COLOR \\$5
.    \}
.    el .ds $BX_COLOR \\*[default]
.    nr #SAVED_WEIGHT     \\n[#RULE_WEIGHT]
.    nr #SAVED_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.    if !'\\$1'SOLID' .RULE_WEIGHT \\*[$BX_WEIGHT]
.    ds $BX_INDENT \\*[$BX_INDENT]-\\n[#WEIGHT_ADJ]u
.    ie \\n[#BX_SOLID]=1 \{\
.       fcolor \\*[$BX_COLOR]
\h'\\*[$BX_INDENT]'\
\D'P \\*[$BX_WIDTH] 0 0 \\*[$BX_DEPTH] -\\*[$BX_WIDTH] 0 0 -\\*[$BX_DEPTH]'
.       fcolor
.       rr #BX_SOLID
.    \}
.    el \{\
.       COLOR \\*[$BX_COLOR]
\D't \\n[#RULE_WEIGHT]'\
\h'\\*[$BX_INDENT]'\
\v'\\n[#WEIGHT_ADJ]u'\
\D'p \\*[$BX_WIDTH]-\\n[#RULE_WEIGHT]u 0 0 \\*[$BX_DEPTH]-\\n[#RULE_WEIGHT]u -\\*[$BX_WIDTH]+\\n[#RULE_WEIGHT]u 0 0 -\\*[$BX_DEPTH]+\\n[#RULE_WEIGHT]u'\
\v'-\\n[#WEIGHT_ADJ]u'\
\D't \\n[#SAVED_RULE_WEIGHT]'
.       gcolor
.    \}
.    sp -1v
.    if \\n[#FILLED]=1 \{\
.       if \\n[#FILL_MODE]=0 .QUAD LEFT
.       if \\n[#FILL_MODE]=1 .JUSTIFY
.       if \\n[#FILL_MODE]=3 .QUAD CENTER
.       if \\n[#FILL_MODE]=5 .QUAD RIGHT
.    \}
.    if \\n[#NOFILL]=1 \{\
.       if \\n[#NOFILL_MODE]=3 .CENTER
.       if \\n[#NOFILL_MODE]=5 .RIGHT
.    \}
.    nr #RULE_WEIGHT \\n[#SAVED_WEIGHT]
.    nr #WEIGHT_ADJ  \\n[#SAVED_WEIGHT_ADJ]
.    rr #SAVED_WEIGHT
.    rr #SAVED_WEIGHT_ADJ
.    if \\n[#RESTORE_TRAP]=1 \{\
.       vpt
.       rr #RESTORE_TRAP
.    \}
.    if '\\n[.z]'FLOAT*DIV' \
.       if !(\\n[.d]+\\*[$BX_DEPTH])<\\n[D-float] .nr D-float \\n[.d]+\\*[$BX_DEPTH]
.END
\#
\# ELLIPSES - DCL
\# --------------
\# *Arguments:
\#   <rule weight> | SOLID> <indent> <width> <depth> [ <color> ]
\# *Function:
\#   Draws described ellipses.
\# *Notes:
\#   Ellipses (circles) are drawn left-to-right, from the baseline
\#   down, and return to their point of origin.  Ellipse rules are
\#   drawn from the perimeter inwards.  Color must be set in the
\#   macro; otherwise the color will be black, regardless of current
\#   .gcolor.  If no arg given, the rule weight is the one set by
\#   RULE_WEIGHT.
\#
.MAC DCL END
.    GRAPHICAL_OBJ
.    ie '\\$1'SOLID' .nr #CL_SOLID 1
.    el              .ds $CL_WEIGHT \\$1
.    ds $CL_INDENT \\$2
.    ds $CL_WIDTH  \\$3
.    ds $CL_DEPTH  \\$4
.    ie !'\\$5'' \{\
.       ie d$\\$5_FILL .ds $CL_COLOR \\*[$\\$5_FILL]
.       el             .ds $CL_COLOR \\$5
.    \}
.    el .ds $CL_COLOR \\*[default]
.    nr #SAVED_WEIGHT     \\n[#RULE_WEIGHT]
.    nr #SAVED_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.    if !'\\$1'SOLID' .RULE_WEIGHT \\*[$CL_WEIGHT]
.    ds $CL_INDENT \\*[$CL_INDENT]-\\n[#WEIGHT_ADJ]u
.    ie \\n[#CL_SOLID]=1 \{\
.       fcolor \\*[$CL_COLOR]
\h'\\*[$CL_INDENT]'\
\v'\\*[$CL_DEPTH]/2u'\
\D'E \\*[$CL_WIDTH]-\\n[#RULE_WEIGHT]u \\*[$CL_DEPTH]-\\n[#RULE_WEIGHT]u'\
\v'-\\*[$CL_DEPTH]/2u'
.       fcolor
.       rr #CL_SOLID
.    \}
.    el \{\
.       COLOR \\*[$CL_COLOR]
\D't \\n[#RULE_WEIGHT]'\
\h'\\*[$CL_INDENT]'\
\v'\\*[$CL_DEPTH]/2u'\
\D'e \\*[$CL_WIDTH]-\\n[#RULE_WEIGHT]u \\*[$CL_DEPTH]-\\n[#RULE_WEIGHT]u'\
\v'-(\\*[$CL_DEPTH]/2u)'\
\D't \\n[#SAVED_RULE_WEIGHT]'
.       gcolor
.    \}
.    sp -1v
.    if \\n[#FILLED]=1 \{\
.       if \\n[#FILL_MODE]=0 .QUAD LEFT
.       if \\n[#FILL_MODE]=1 .JUSTIFY
.       if \\n[#FILL_MODE]=3 .QUAD CENTER
.       if \\n[#FILL_MODE]=5 .QUAD RIGHT
.       rr #FILLED
.    \}
.    if \\n[#NOFILL]=1 \{\
.       if \\n[#NOFILL_MODE]=3 .CENTER
.       if \\n[#NOFILL_MODE]=5 .RIGHT
.    \}
.    nr #RULE_WEIGHT \\n[#SAVED_WEIGHT]
.    nr #WEIGHT_ADJ  \\n[#SAVED_WEIGHT_ADJ]
.    rr #SAVED_WEIGHT
.    rr #SAVED_WEIGHT_ADJ
.    if \\n[#RESTORE_TRAP]=1 \{\
.       vpt
.       rr #RESTORE_TRAP
.    \}
.    if '\\n[.z]'FLOAT*DIV' \
.       if !(\\n[.d]+\\*[$CL_DEPTH])<\\n[D-float] .nr D-float \\n[.d]+\\*[$CL_DEPTH]
.END
\#
\# RULE WEIGHT
\# -----------
\# *Argument:
\#   <weight of rules in points>
\# *Function:
\#   Sets \D't <n>' to the correct number of machine units for the
\#   argument given in points.
\# *Notes:
\#   Decimal fractions are allowed.  Rule weight must be < 100.
\#
.MAC RULE_WEIGHT END
.    di NULL \" Diverted so there's no problem with breaks, spacing, etc.
.       ds $ARG \\$1
.       substring $ARG -1
.       if !\B'\\*[$ARG]' \{\
.          tm1 "[mom]: The argument to \\$0 must not have a unit of measure appended.
.          ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.       \}
.       length #STR_LENGTH \\$1
.       ds $ARG \\$1
.       substring $ARG 0 0
.       ie '\\*[$ARG]'.' \{\
.          ds $ARG \\$1
.          substring $ARG 1 \\n[#STR_LENGTH]-1
.          nr #WEIGHT \\*[$ARG]*100
.          if (\\n[#WEIGHT]>=1000) \{\
.              while (\\n[#WEIGHT]>=1000) \{\
.                 nr #WEIGHT \\n[#WEIGHT]/10
.              \}
.          \}
.       \}
.       el \{\
.          ds $ARG \\$1
.          length #ARG_LENGTH \\*[$ARG]
.          if \\n[#ARG_LENGTH]>1 .substring $ARG 1 1
.          ie '\\*[$ARG]'.' \{\
.             ds $LHS \\$1
.             substring $LHS 0 0
.             ds $RHS \\$1
.             substring $RHS 2
.             nr #WEIGHT \\*[$LHS]\\*[$RHS]*100
.             if (\\n[#WEIGHT]>=10000) \{\
.                while (\\n[#WEIGHT]>=10000) \{\
.                   nr #WEIGHT \\n[#WEIGHT]/10
.                \}
.             \}
.          \}
.          el \{\
.             ie \\n[#STR_LENGTH]<=2 .nr #WEIGHT \\$1*1000
.             el \{\
.                ds $ARG \\$1
.                substring $ARG 2 2
.                ie !'\\*[$ARG]'.' \{\
.                   tm1 "[mom]: Invalid argument given to macro \\$0 at line \\n[.c].
.                   tm1 "       Rule weight must be < 100 points.
.                   tm1 "       Falling back to default weight .5 points.
.                   nr #WEIGHT 500
.                \}
.                el \{\
.                   ds $LHS \\$1
.                   substring $LHS 0 1
.                   ds $RHS \\$1
.                   substring $RHS 3
.                   nr #WEIGHT \\*[$LHS]\\*[$RHS]*1000
.                   if (\\n[#WEIGHT]>=100000) \{\
.                      while (\\n[#WEIGHT]>=100000) \{\
.                         nr #WEIGHT \\n[#WEIGHT]/10
.                      \}
.                   \}
.                \}
.             \}
.          \}
.       \}
.       nr #WEIGHT_ADJ \\n[#WEIGHT]/2
.       if '\\$0'BIBLIOGRAPHY_STRING_UNDERLINE_WEIGHT' \
.          ds $TITLE_TYPE BIB_STRING_
.       if '\\$0'ENDNOTE_TITLE_UNDERLINE_WEIGHT' \
.          ds $TITLE_TYPE EN_TITLE_
.       if '\\$0'EN_HEADER_UNDERLINE_WEIGHT' \
.          ds $TITLE_TYPE EN_STRING_
.       if !'\\*[$TITLE_TYPE]'BIB_STRING' \
.          if !'\\*[$TITLE_TYPE]'EN_TITLE' \
.             if !'\\*[$TITLE_TYPE]'EN_STRING' \
.                ds _TYPE \\$0
.       length type-len _TYPE
.       if \\n[type-len]>17 \{\
.          substring _TYPE 0 -17
.          ds $TITLE_TYPE \\*[_TYPE]
.       \}
.       if !'\\*[$TITLE_TYPE]'' \{\
.          nr #\\*[$TITLE_TYPE]UNDERLINE_WEIGHT \\n[#WEIGHT]
.          nr #\\*[$TITLE_TYPE]UNDERLINE_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.       \}
.       if '\\$0'RULE_WEIGHT' \{\
.          nr #RULE_WEIGHT     \\n[#WEIGHT]
.          nr #RULE_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.       \}
.       if '\\$0'UNDERSCORE_WEIGHT' \{\
.          nr #UNDERSCORE_WEIGHT     \\n[#WEIGHT]
.          nr #UNDERSCORE_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.       \}
.       if '\\$0'FOOTER_RULE_WEIGHT' \{\
.          nr #FOOTER_RULE_WEIGHT     \\n[#WEIGHT]
.          nr #FOOTER_RULE_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.       \}
.       if '\\$0'FOOTNOTE_RULE_WEIGHT' \{\
.          nr #FN_RULE_WEIGHT     \\n[#WEIGHT]
.          nr #FN_RULE_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.       \}
.       if '\\$0'HEADER_RULE_WEIGHT' \{\
.          nr #HEADER_RULE_WEIGHT     \\n[#WEIGHT]
.          nr #HEADER_RULE_WEIGHT_ADJ \\n[#WEIGHT_ADJ]
.       \}
.    di
.END
\#
\# Aliases for RULE_WEIGHT
\# 
.ALIAS BIB_STRING_UNDERLINE_WEIGHT RULE_WEIGHT
.ALIAS DOCTYPE_UNDERLINE_WEIGHT    RULE_WEIGHT
.ALIAS EN_STRING_UNDERLINE_WEIGHT  RULE_WEIGHT
.ALIAS EN_TITLE_UNDERLINE_WEIGHT   RULE_WEIGHT
.ALIAS FN_RULE_WEIGHT              RULE_WEIGHT
.ALIAS FOOTER_RULE_WEIGHT          RULE_WEIGHT
.ALIAS FOOTNOTE_RULE_WEIGHT        RULE_WEIGHT
.ALIAS HEADER_RULE_WEIGHT          RULE_WEIGHT
.ALIAS RULE_WEIGHT                 RULE_WEIGHT
.ALIAS TOC_HEADER_UNDERLINE_WEIGHT RULE_WEIGHT
.ALIAS UNDERSCORE_WEIGHT           RULE_WEIGHT
\#
\# Default rule weights
\# 
.nr #BIB_STRING_UNDERLINE_WEIGHT 500
.nr #DOCTYPE_UNDERLINE_WEIGHT    500
.nr #EN_STRING_UNDERLINE_WEIGHT  500
.nr #EN_TITLE_UNDERLINE_WEIGHT   500
.nr #FN_RULE_WEIGHT              500
.nr #FOOTER_RULE_WEIGHT          500
.nr #HEADER_RULE_WEIGHT          500
.nr #RULE_WEIGHT                 500
.nr #TOC_HEADER_UNDERLINE_WEIGHT 500
.nr #UNDERSCORE_WEIGHT           500
\#
.nr #BIB_STRING_UNDERLINE_WEIGHT_ADJ \n[#BIB_STRING_UNDERLINE_WEIGHT]/2
.nr #DOCTYPE_UNDERLINE_WEIGHT_ADJ    \n[#DOCTYPE_UNDERLINE_WEIGHT]/2
.nr #EN_STRING_UNDERLINE_WEIGHT_ADJ  \n[#EN_STRING_UNDERLINE_WEIGHT]/2
.nr #EN_TITLE_UNDERLINE_WEIGHT_ADJ   \n[#EN_TITLE_UNDERLINE_WEIGHT]/2
.nr #FN_RULE_WEIGHT_ADJ              \n[#FN_RULE_WEIGHT]/2
.nr #FOOTER_RULE_WEIGHT_ADJ          \n[#FOOTER_RULE_WEIGHT]/2
.nr #HEADER_RULE_WEIGHT_ADJ          \n[#HEADER_RULE_WEIGHT]/2
.nr #RULE_WEIGHT_ADJ                 \n[#RULE_WEIGHT]/2
.nr #TOC_HEADER_UNDERLINE_WEIGHT_ADJ \n[#TOC_HEADER_UNDERLINE_WEIGHT]/2
.nr #UNDERSCORE_WEIGHT_ADJ           \n[#UNDERSCORE_WEIGHT]/2
\#
\# Read in remaining aliases and default rule weights
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<=14 \{\
. ALIAS \*[TITLE_TYPE_\n[#LOOP]]_UNDERLINE_WEIGHT           RULE_WEIGHT
. ALIAS COVER_\*[TITLE_TYPE_\n[#LOOP]]_UNDERLINE_WEIGHT     RULE_WEIGHT
. ALIAS DOC_COVER_\*[TITLE_TYPE_\n[#LOOP]]_UNDERLINE_WEIGHT RULE_WEIGHT
. nr #\*[TITLE_TYPE_\n[#LOOP]]_UNDERLINE_WEIGHT            500
. nr #COVER_\*[TITLE_TYPE_\n[#LOOP]]_UNDERLINE_WEIGHT      500
. nr #DOC_COVER_\*[TITLE_TYPE_\n[#LOOP]]_UNDERLINE_WEIGHT  500
. nr #\*[TITLE_TYPE_\n[#LOOP]]_UNDERLINE_WEIGHT_ADJ \
    \n[#\*[TITLE_TYPE_\n[#LOOP]]_UNDERLINE_WEIGHT]/2
. nr #COVER_\*[TITLE_TYPE_\n[#LOOP]]_UNDERLINE_WEIGHT_ADJ \
    \n[#COVER_\*[TITLE_TYPE_\n[#LOOP]]_UNDERLINE_WEIGHT]/2
. nr #DOC_COVER_\*[TITLE_TYPE_\n[#LOOP]]_UNDERLINE_WEIGHT_ADJ \
    \n[#DOC_COVER_\*[TITLE_TYPE_\n[#LOOP]]_UNDERLINE_WEIGHT]/2
.\}
\#
\# Set default rule weight
\#
.di NULL
\D't 500'
.di
\#
\# =====================================================================
\#
\# +++WORD AND SENTENCE SPACING+++
\#
\# WORD SPACE CONTROL
\# ------------------
\# *Argument:
\#   <+|->wordspace | DEFAULT
\# *Function:
\#   Increases or decreases interword space by user supplied amount.
\#   If DEFAULT, value is set to 12 (groff default).
\# *Notes:
\#   $WS_CONSTANT is the groff default word space.
\#   $WS_VAR is the user supplied amount by which to in/decrease word space.
\#   $WS is a concatenation of WS_CONSTANT and WS_VAR.
\#
\#   \n[.sss] holds the current sentence space value.
\#
.MAC WS END
.    ds $WS_CURR \\n[.ss]
.    ds $WS_VAR  \\$1
.    ie '\\$1'DEFAULT' .ss 12 \\n[.sss]
.    el \{\
.       ds $WS (\\*[$WS_CURR]+\\*[$WS_VAR])
.       ie \\n[.sss]=12 .ss \\*[$WS] 12
.       el \{\
.          ss \\*[$WS] (\\*[$WS]+\\*[$SS_VAR])
.          SS \\*[$SS_VAR]
.      \}
.    \}
.END
\#
\# SENTENCE SPACE CONTROL
\# ----------------------
\# *Argument:
\#   <+-sentencespace> | 0 | DEFAULT
\# *Function:
\#   Increases or decreases sentence space by user supplied amount.
\#   If 0, sentence spaces are ignored.  If DEFAULT, value is
\#   set to 12 (groff default).
\# *Notes:
\#   Because the user supplied value requires a literal + or - sign,
\#   the macro argument is stored in a string.
\#
\#   Sentence space applies only to input where sentences are separated
\#   by two spaces (and/or, in fill mode [FLUSH L|R|C or JUSTIFY], an EOL).
\#   Changing .SS when sentences are separated by only one space has
\#   no effect on the space between sentences.
\#
\#   \n[.ss] holds the current wordspace value.
\#   \n[.sss] holds the current sentence space value.
\#
.MAC SS END
.    ds $SS_VAR \\$1
.    ie '\\$1'0' .ss \\n[.ss] (\\n[.ss]-\\n[.ss])
.    el \{\
.       ie '\\$1'DEFAULT' .ss \\n[.ss]
.       el                .ss \\n[.ss] (0+\\*[$SS_VAR])
.    \}
.END
\#
\# =====================================================================
\#
\# INDENTS
\# -------
\#
\# +++INDENT LEFT+++
\#
.MAC IL END
.    if \\n[#INDENT_STYLE_BOTH] .IBX
.    nr #INDENT_STYLE_LEFT  1
.    nr #INDENT_ACTIVE      1
.    nr #INDENT_LEFT_ACTIVE 1
.    ie '\\$1'' \{\
.       br
.       in \\n[#L_INDENT]u
.       ta \\n[.l]u-\\n[#L_INDENT]u
.    \}
.    el \{\
.       br
.       nr #L_INDENT +(\\$1)
.       in \\n[#L_INDENT]u
.       ta \\n[.l]u-\\n[#L_INDENT]u
.    \}
.    if \\n[#IN_ITEM] .nr #IN_ITEM_L_INDENT +(\\$1)
.END
\#
\# +++INDENT RIGHT+++
\#
.MAC IR END
.    if \\n[#INDENT_STYLE_BOTH] .IBX
.    nr #INDENT_STYLE_RIGHT   1
.    nr #INDENT_ACTIVE        1
.    nr #INDENT_RIGHT_ACTIVE  1
.    ie '\\$1'' \{\
.       br
.       ie \\n[#TAB_ACTIVE] \{\
.          ll \\n[.l]u-\\n[#R_INDENT]u
.          ta \\n[.l]u-\\n[#L_INDENT]u
.       \}
.       el \{\
.          ll \\n[.l]u-\\n[#R_INDENT]u
.          ta \\n[.l]u-\\n[#L_INDENT]u
.       \}
.    \}
.    el \{\
.       br
.       nr #R_INDENT +(\\$1)
.       ie \\n[#TAB_ACTIVE] \{\
.          ll \\n[.l]u-\\n[#R_INDENT]u
.          ta \\n[.l]u-\\n[#L_INDENT]u
.       \}
.       el \{\
.          ll \\n[.l]u-\\n[#R_INDENT]u
.          ta \\n[.l]u-\\n[#L_INDENT]u
.       \}
.    \}
.END
\#
\# +++INDENT BOTH+++
\#
.MAC IB END
.    br
.    if \\n[#INDENT_STYLE_LEFT]  .ILX
.    if \\n[#INDENT_STYLE_RIGHT] .IRX
.    nr #INDENT_STYLE_BOTH  1
.    nr #INDENT_ACTIVE      1
.    nr #INDENT_BOTH_ACTIVE 1
.    ie '\\$1'' \{\
.       ie \\n[#DOCS] \
.          ll \\n[#DOC_L_LENGTH]u-\\n[#BR_INDENT]u
.       el .ll \\n[.l]u-\\n[#BR_INDENT]u
.       in \\n[#BL_INDENT]u
.       ta \\n[.l]u
.    \}
.    el \{\
.       nr #BL_INDENT (\\n[#INDENT]+\\$1)
.       ie \\n[#NUM_ARGS]=2 .nr #BR_INDENT +(\\$2)
.       el .nr #BR_INDENT \\n[#BL_INDENT]
.       if '\\n[.z]'' .ll
.       ll \\n[.l]u-\\n[#BR_INDENT]u
.       in \\n[#BL_INDENT]u
.       ta \\n[.l]u-\\n[#BR_INDENT]u
.    \}
.END
\#
\# +++TEMPORARY INDENT+++
\#
.MAC TI END
.    br
.    ie '\\$1'' \{\
.       ti \\n[#T_INDENT]u
.       if \\n[#INDENT_LEFT_ACTIVE] .ti \\n[#T_INDENT]u+\\n[#L_INDENT]u
.       if \\n[#INDENT_BOTH_ACTIVE] .ti \\n[#T_INDENT]u+\\n[#BL_INDENT]u
.    \}
.    el \{\
.       nr #T_INDENT (\\$1)
.       ti \\n[#T_INDENT]u
.    \}
.END
\#
\# +++HANGING INDENT+++
\#
.MAC HI END
.    ie '\\$1'' .ti -\\n[#HL_INDENT]u
.    el \{\
.       nr #HL_INDENT (\\$1)
.       ti -\\n[#HL_INDENT]u
.    \}
.END
\#
\# +++INDENTS OFF+++
\#
.MAC ILX END
.    ie \\n[#IN_ITEM] .nr #L_INDENT -\\n[#IN_ITEM_L_INDENT]
.    el \{\
.       br
.       in 0
.       rr #INDENT_LEFT_ACTIVE
.       nr #L_INDENT_ILX \\n[#L_INDENT]
.    \}
.    if '\\$1'CLEAR' \{\
.       rr #L_INDENT
.       rr #INDENT_STYLE_LEFT
.       rr #L_INDENT_ILX
.       rr #INDENT_ACTIVE
.    \}
.END
\#
.MAC IRX END
.    br
.    rr #INDENT_RIGHT_ACTIVE
.    ie \\n[#TAB_ACTIVE] .TAB\\n[#CURRENT_TAB]
.    el \{\
.       ie \\n[#COLUMNS] \{\
.          ll \\n[#COL_L_LENGTH]u
.          ta \\n[.l]u
.       \}
.       el \{\
.          ll \\n[#L_LENGTH]u
.          ta \\n[.l]u
.       \}
.    \}
.    if '\\$1'CLEAR' \{\
.       rr #R_INDENT
.       rr #INDENT_STYLE_RIGHT
.    \}
.END
\#
.MAC IBX END
.    br
.    in 0
.    rr #INDENT_ACTIVE
.    rr #INDENT_BOTH_ACTIVE
.    ie \\n[#TAB_ACTIVE] .TAB\\n[#CURRENT_TAB]
.    el \{\
.       ie \\n[#COLUMNS] \{\
.          ll \\n[#COL_L_LENGTH]u
.          ta \\n[.l]u
.       \}
.       el \{\
.          ll \\n[#L_LENGTH]u
.          ta \\n[.l]u
.       \}
.    \}
.    if '\\$1'CLEAR' \{\
.       rr #BL_INDENT
.       rr #BR_INDENT
.       rr #INDENT_STYLE_BOTH
.    \}
.END
\#
.MAC IX END
.    if '\\$0'IX' \{\
.       if !\\n[#IX_WARN] \{\
.          tm1 "[mom]: Use of .IX is deprecated.  Use .IQ instead.
.          tm1 "      .IX will continue to behave as before, but to
.          tm1 "       avoid this message, please update your document.
.          nr #IX_WARN 1
.       \}
.    \}
.    br
.    in 0
.    rr #INDENT_LEFT_ACTIVE
.    rr #INDENT_RIGHT_ACTIVE
.    rr #INDENT_BOTH_ACTIVE
.    rr #INDENT_ACTIVE
.    if \\n[#INDENT_STYLE_RIGHT] \{\
.       ie \\n[#TAB_ACTIVE] .TAB\\n[#CURRENT_TAB]
.       el \{\
.          ie \\n[#COLUMNS] \{\
.             ll \\n[#COL_L_LENGTH]u
.             ta \\n[.l]u
.          \}
.          el \{\
.             ll \\n[#L_LENGTH]u
.             ta \\n[.l]u
.          \}
.       \}
.    \}
.    if \\n[#INDENT_STYLE_BOTH] \{\
.       ie \\n[#TAB_ACTIVE] .TAB\\n[#CURRENT_TAB]
.       el \{\
.          ie \\n[#COLUMNS] \{\
.             ll \\n[#COL_L_LENGTH]u
.             ta \\n[.l]u
.          \}
.          el \{\
.             ll \\n[#L_LENGTH]u
.             ta \\n[.l]u
.          \}
.       \}
.    \}
.    if '\\$1'CLEAR' \{\
.       if \\n[#INDENT_STYLE_RIGHT] \{\
.          ie \\n[#TAB_ACTIVE] .TAB\\n[#CURRENT_TAB]
.          el \{\
.             ie \\n[#COLUMNS] \{\
.                ll \\n[#COL_L_LENGTH]u
.                ta \\n[.l]u
.             \}
.             el \{\
.                ll \\n[#L_LENGTH]u
.                ta \\n[.l]u
.             \}
.          \}
.       \}
.       if \\n[#INDENT_STYLE_BOTH] \{\
.          ie \\n[#TAB_ACTIVE] .TAB\\n[#CURRENT_TAB]
.          el \{\
.             ie \\n[#COLUMNS] \{\
.                ll \\n[#COL_L_LENGTH]u
.                ta \\n[.l]u
.             \}
.             el \{\
.                ll \\n[#L_LENGTH]u
.                ta \\n[.l]u
.             \}
.          \}
.       \}
.       rr #L_INDENT
.       rr #R_INDENT
.       rr #BL_INDENT
.       rr #BR_INDENT
.       rr #T_INDENT
.       rr #H_INDENT
.       rr #INDENT_STYLE_LEFT
.       rr #INDENT_STYLE_RIGHT
.       rr #INDENT_STYLE_BOTH
.    \}
.END
\#
\# =====================================================================
\#
\# +++HANGING CHARACTERS+++
\#
\#   LEFT_HANG hangs its argument to the left of the left margin.
\#   If enclosed in double-quotes, the argument may contain local
\#   horizontal motions.  Input text after LEFT_HANG must begin
\#   by repeating the text of the argument including horizontal
\#   motions.  If the hung character is a left double-quote,
\#   \[lq] must be used in the argument and the usual keyboard
\#   double-quote (") used for the input text (so as not to confuse
\#   SMARTQUOTES).
\#
\#   HANG is called inline with \*[HANG <character>].  Hangs its
\#   single-character argument, typically a punctuation mark, to the
\#   right of the right margin in justified copy.  Unlike LEFT_HANG,
\#   does not require repeating the character as part of input text.
\#
\#   Except for hung hyphens, HANG may be used mid-line in input
\#   text.  Hung hyphens must come at the end of input lines.  If
\#   the hung character is a right double-quote, "\[rq]" must be
\#   used as the argument (that is, the rq character surrounded by
\#   double-quotes).  The double-quotes are required for all special
\#   characters that have the form \[c].
\#
.MAC LEFT_HANG END
.    ie '\\$0'LEFT_HANG' \{\
.       vpt 0
.       sp -1
.       nr #HANG \w'\\$1'
.       in +\\n[#HANG]u
.       ll +\\n[#HANG]u
.       ie !\\n[.z] .po -\\n[#HANG]u
.       el \!.po -\\n[#HANG]u
.       ti -\\n[#HANG]u
.       vpt
.    \}
.    el \{\
.       vpt 0
.       in
.       ll
.       po
.       vpt
.    \}
.END
\#
.ALIAS NO_HANG LEFT_HANG
\#
.MAC HANG END
\c
.if '\\$1'\[rq]' .nr #OPEN_CLOSE 0
\c
\&\\$1\c
\h'-\w'\\$1'u'\c
.END
\#
\# =====================================================================
\#
\# +++MULTIPLE COLUMNS+++
\#
\# MULTIPLE COLUMNS ON
\# -------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Marks the top of a column set
\#
.MAC MCO END
.    mk c
.END
\#
\# MULTIPLE COLUMN RETURN
\# ----------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Returns to the top of a column set
\#
.MAC MCR END
.    vpt 0
.    sp |\\n[c]u
.    vpt
.END
\#
\# MULTIPLE COLUMNS OFF
\# --------------------
\# *Arguments:
\#   <none> | <lead to advance beneath bottom of deepest column>
\# *Function:
\#   Advances to the end of a column set
\# *Notes:
\#   With no argument, advances to the next baseline (at the current
\#   leading value) beneath the longest column.  With an argument
\#   (which requires a unit of measure), advances arg distance
\#   beneath the baseline of the deepest column.  If the argument
\#   is zero, advances to the baseline of the deepest column.
\#
.MAC MCX END
.    vpt 0
.    ie '\\$1'' \{\
.       if '\\n[.z]'FLOAT*DIV' \!.TQ
.       TQ
.       sp |\\n[.h]u
.    \}
.    el \{\
.       nr #MCX_ALD (\\$1)
.       TQ
.       ie \\n[#MCX_ALD]=0 .sp |\\n[.h]u-1v
.       el .sp |\\n[.h]u+\\n[#MCX_ALD]u
.       rr #MCX_ALD
.    \}
.    vpt
.END
\#
\# =====================================================================
\#
\# +++TYPESETTING SUPPORT MACROS+++
\#
\# TRAP
\# ----
\# *Arguments:
\#   toggle
\# *Function:
\#   Enables/disables traps.
\# *Notes:
\#   EL and TN don't function as advertised on the last line before
\#   a trap (when they break the preceding line, they spring the
\#   trap, and groff won't back up to the line preceding the trap).
\#   TRAP is a kludge to get EL and TN work properly on last lines.
\#   The user simply encloses the offending lines in TRAP OFF/TRAP.
\#
.MAC TRAP END
.    ie '\\$1'' .vpt
.    el         .vpt 0
.END
\#
\# SILENT
\# ------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Diverts text so that it doesn't print, or turns the function off.
\# *Notes:
\#   Useful for setting up autotabs where you don't want the line with
\#   the tab marks to print.
\#
\#   Also aliased as COMMENT, in case user wants to input a batch of
\#   text that doesn't print.
\#
.MAC SILENT END
.    nr #SILENT 1
.    if \\n[#QUAD] .br
.    ie '\\$1'' .di NO_FLASH
.    el \{\
.       br
.       di
.       rm NO_FLASH
.       rr #SILENT
.    \}
.END
\#
\# PRINT
\# -----
\# *Function:
\#   Prints anything.  A macro that helps keep my code nicely indented.
\#
.MAC PRINT END
.    nop \\$*
.END
\#
\# Numbered strings for while loop in SMALLCAPS.
\#
.ds $c1 a
.ds $c2 b
.ds $c3 c
.ds $c4 d
.ds $c5 e
.ds $c6 f
.ds $c7 g
.ds $c8 h
.ds $c9 i
.ds $c10 j
.ds $c11 k
.ds $c12 l
.ds $c13 m
.ds $c14 n
.ds $c15 o
.ds $c16 p
.ds $c17 q
.ds $c18 r
.ds $c19 s
.ds $c20 t
.ds $c21 u
.ds $c22 v
.ds $c23 w
.ds $c24 x
.ds $c25 y
.ds $c26 z
.ds $c27 \[`a]
.ds $c28 \[^a]
.ds $c29 \['a]
.ds $c30 \[:a]
.ds $c31 \[oa]
.ds $c32 \[~a]
.ds $c33 \[ae]
.ds $c34 \[`e]
.ds $c35 \[^e]
.ds $c36 \['e]
.ds $c37 \[:e]
.ds $c38 \[`i]
.ds $c39 \[^i]
.ds $c40 \['i]
.ds $c41 \[:i]
.ds $c42 \[`o]
.ds $c43 \[^o]
.ds $c44 \['o]
.ds $c45 \[:o]
.ds $c46 \[~o]
.ds $c47 \[/o]
.ds $c48 \[`u]
.ds $c49 \[^u]
.ds $c50 \['u]
.ds $c51 \[:u]
.ds $c52 \[,c]
.ds $c53 \[Sd]
.ds $c54 \[~n]
.ds $c55 \[Sd]
.ds $c56 \[Tp]
.ds $c57 \['y]
.ds $c58 \[:y]
\#
.ds $C1 A
.ds $C2 B
.ds $C3 C
.ds $C4 D
.ds $C5 E
.ds $C6 F
.ds $C7 G
.ds $C8 H
.ds $C9 I
.ds $C10 J
.ds $C11 K
.ds $C12 L
.ds $C13 M
.ds $C14 N
.ds $C15 O
.ds $C16 P
.ds $C17 Q
.ds $C18 R
.ds $C19 S
.ds $C20 T
.ds $C21 U
.ds $C22 V
.ds $C23 W
.ds $C24 X
.ds $C25 Y
.ds $C26 Z
.ds $C27 \[`A]
.ds $C28 \[^A]
.ds $C29 \['A]
.ds $C30 \[:A]
.ds $C31 \[oA]
.ds $C32 \[~A]
.ds $C33 \[AE]
.ds $C34 \[`E]
.ds $C35 \[^E]
.ds $C36 \['E]
.ds $C37 \[:E]
.ds $C38 \[`I]
.ds $C39 \[^I]
.ds $C40 \['I]
.ds $C41 \[:I]
.ds $C42 \[`O]
.ds $C43 \[^O]
.ds $C44 \['O]
.ds $C45 \[:O]
.ds $C46 \[~O]
.ds $C47 \[/O]
.ds $C48 \[`U]
.ds $C49 \[^U]
.ds $C50 \['U]
.ds $C51 \[:U]
.ds $C52 \[,C]
.ds $C53 \[-D]
.ds $C54 \[~N]
.ds $C55 \[-D]
.ds $C56 \[TP]
.ds $C57 \['Y]
.ds $C58 \[:Y]
\#
\# CAPS
\# ----
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Converts text to caps, or, if OFF, reverts to normal caps/lc.
\# *Notes:
\#   For inline control of capitalization style, use \*[UC] and
\#   \*[LC].
\#
.MAC CAPS END
.    ie '\\$1'' \{\
.       LC_TO_CAPS
.       nr #CAPS_ON 1
.    \}
.    el \{\
.       CAPS_TO_LC
.       rr #CAPS_ON
.    \}
.END
\#
.MAC UC END
\c
.    LC_TO_CAPS
.    nr #CAPS_ON 1
.END
\#
.MAC LC END
\c
.    CAPS_TO_LC
.    rr #CAPS_ON
.END
\#
\# Perform lowercase conversion to caps or revert to lowercase
\#
.MAC CONVERT_CASE END
.    if '\\$0'LC_TO_CAPS' \{\
.       nr #LOOP 0 1
.       while \\n+[#LOOP]<=58 \{\
.          tr \\*[$c\\n[#LOOP]]\\*[$C\\n[#LOOP]]  
.       \}
.    \}
.    if '\\$0'CAPS_TO_LC' \{\
.       nr #LOOP 0 1
.       while \\n+[#LOOP]<=58 \{\
.          tr \\*[$c\\n[#LOOP]]\\*[$c\\n[#LOOP]]  
.       \}
.    \}
.END
.
.ALIAS LC_TO_CAPS CONVERT_CASE
.ALIAS CAPS_TO_LC CONVERT_CASE
.
\#
\# SMALLCAPS
\# ---------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Converts text to smallcaps, or, if <anything>, reverts to normal
\#   caps/lc.
\# *Notes:
\#   SMALLCAPS has no inline escape eqiv. to \*[UC].
\#
.MAC SMALLCAPS END
.    if \\n[.int] .nop \& \c
.    nr sc*size \\n[.ps]*\\n[sc*factor]/1000
.    if \\n[sc*wt-adj] .nr sc*wt-adj-factor \\n[sc*size]*\\n[sc*wt-adj]/1000
.    if \\n[sc*extend] .nr sc*extend-factor \\n[sc*size]*\\n[sc*extend]/1000
.    ie '\\$1'' \{\
.       nr #SMALLCAPS_ON 1
.       nr #LOOP 0 1
.       while \\n+[#LOOP]<=58 \{\
.          char \\*[$c\\n[#LOOP]] \
\Z'\s[\\n[sc*size]u+\\n[sc*extend-factor]u]\H'-\\n[sc*extend-factor]u'\
\\*[$C\\n[#LOOP]]'\
\h'\\n[sc*wt-adj-factor]u'\\*[$C\\n[#LOOP]]\s[0]
.       \}
.    \}
.    el \{\
.       nr #LOOP 0 1
.       while \\n+[#LOOP]<=58 \{\
.          rchar \\*[$c\\n[#LOOP]]
.      \}
.      rr sc*wt-adj-factor
.      rr sc*extend-factor
.      rr #SMALLCAPS_ON
.    \}
.END
\#
\# SMALLCAPS_SIZE
\# --------------
\# *Arguments:
\#   <size> [ <weight adjustment>
\# *Function:
\#   Sets registers 'sc*factor', 'sc*wt-adj', and sc*extend.
\# *Notes:
\#   Weight adjustment pseudo-emboldens small caps to visually match the
\#   weight of the larger real caps.
\#
\#   Both sc*factor (size) and sc*wt-adj (weight adjustment) args are
\#   expressed as percentages of type size.
\#
.MAC SMALLCAPS_STYLE END
.    nr #LOOP 0 1
.    while \\n+[#LOOP]<=\\n[#NUM_ARGS] \{\
.       if '\\$1'SIZE' \{\
.          shift
.          nr sc*factor (z;\\$1)/100
.          shift
.       \}
.       if '\\$1'WEIGHT_ADJ' \{\
.          shift
.          nr sc*wt-adj (z;\\$1)/100
.          shift
.       \}
.       if '\\$1'EXTEND' \{\
.          shift
.          nr sc*extend (z;\\$1)/100
.          shift
.       \}
.    \}
.    if \\n[sc*wt-adj]=0 .rr sc*wt-adj
.    if \\n[sc*extend]=0 .rr sc*extend
.END
.
.SMALLCAPS_STYLE \
SIZE 74 \
WEIGHT_ADJ .3 \
EXTEND 5
\#
\# SIZESPECS
\# ---------
\# Argument:
\#   <none>
\# Function:
\#   Gets cap-height, x-height, and descender depth of the
\#   current font at the current point size.
\# *Notes:
\#   The routine is diverted so it remains invisible to output.
\#
.MAC SIZESPECS END
.    if '\\n[.z]'FLOAT*DIV' \
.       if \\n[dn] .nr saved-dn \\n[dn]
.    di TYPESIZE
E\R'#CAP_HEIGHT \\n[.cht]'
e\R'#X_HEIGHT \\n[.cht]'
y\R'#DESCENDER \\n[.cdp]'
.    br
.    ds $CAP_HEIGHT \\n[#CAP_HEIGHT]u
.    ds $X_HEIGHT \\n[#X_HEIGHT]u
.    ds $DESCENDER \\n[#DESCENDER]u
.    di
.    if '\\n[.z]'FLOAT*DIV' \
.       nr dn \\n[saved-dn]
.END
\#
\# =====================================================================
\#
\# +++TYPESETTING ALIASES+++
\#
.ALIAS ADD_SPACE         ALD
.ALIAS CENTRE            CENTER
.ALIAS COLOUR            COLOR
.ALIAS COMMENT           SILENT
.ALIAS CONDENSE          CONDENSE_OR_EXTEND
.ALIAS EXTEND            CONDENSE_OR_EXTEND
.ALIAS FAM               FAMILY
.ALIAS FONT              FT
.ALIAS HYPHENATE         HY
.ALIAS HYPHENATION       HY
.ALIAS HYSET             HY_SET
.ALIAS IBQ               IBX
.ALIAS ILQ               ILX
.ALIAS IQ                IX
.ALIAS IRQ               IRX
.ALIAS LIG               LIGATURES
.ALIAS NEWCOLOUR         NEWCOLOR
.ALIAS PADMARKER         PAD_MARKER
.ALIAS SP                ALD
.ALIAS SPACE             ALD
.ALIAS TABSET            TAB_SET
.ALIAS TB                TAB
.ALIAS UNDERSCORE_2      UNDERSCORE2
.ALIAS XCOLOUR           XCOLOR
\#
\# ====================================================================
\#
\# DOCUMENT PROCESSING MACROS, STRINGS AND ALIASES
\# ===============================================
\#
\# DOC_MACRO_ERROR
\# ---------------
\# *Arguments:
\#   None.
\# *Function:
\#   Warning message if DOC_<PARAMETER> called before START.
\#
.MAC DOC_MACRO_ERROR END
.    if '\\$1'DOC_L_MARGIN'    .ds $REPLACEMENT L_MARGIN
.    if '\\$1'DOC_R_MARGIN'    .ds $REPLACEMENT R_MARGIN
.    if '\\$1'DOC_LINE_LENGTH' .ds $REPLACEMENT LL
.    if '\\$1'DOC_FAMILY'      .ds $REPLACEMENT "FAMILY or FAM
.    if '\\$1'DOC_PT_SIZE'     .ds $REPLACEMENT PT_SIZE
.    if '\\$1'DOC_LEAD'        .ds $REPLACEMENT LS
.    if '\\$1'DOC_QUAD'        .ds $REPLACEMENT QUAD
.    tm1 "[mom]: \\$1 at line \\n[.c] of '\\n[.F]' should not be used before START.
.    tm1 "       Use \\*[$REPLACEMENT] instead.
.    ab   [mom]: Aborting.
.END
\#
\# +++PAGE DIMENSIONS+++
\#
\# PAPER SIZE
\# ----------
\# *Arguments:
\#   LETTER | LEGAL | STATEMENT | TABLOID | LEDGER | FOLIO | QUARTO | 10x14 | EXECUTIVE | A3 | A4 | A5 | B4 | B5
\# *Function:
\#   Sets up dimensions for different paper sizes.
\#
.MAC PAPER END
.    ds $PAPER \\$1
.    if '\\*[$PAPER]'LETTER' \{\
.       PAGEWIDTH  8.5i
.       PAGELENGTH 11i
.    \}
.    if '\\*[$PAPER]'LEGAL' \{\
.       PAGEWIDTH  8.5i
.       PAGELENGTH 14i
.    \}
.    if '\\*[$PAPER]'STATEMENT' \{\
.       PAGEWIDTH  5.5i
.       PAGELENGTH 8.5i
.    \}
.    if '\\*[$PAPER]'TABLOID' \{\
.       PAGEWIDTH  11i
.       PAGELENGTH 17i
.    \}
.    if '\\*[$PAPER]'LEDGER' \{\
.       PAGEWIDTH  17i
.       PAGELENGTH 11i
.    \}
.    if '\\*[$PAPER]'FOLIO' \{\
.       PAGEWIDTH  8.5i
.       PAGELENGTH 13i
.    \}
.    if '\\*[$PAPER]'QUARTO' \{\
.       PAGEWIDTH  610p
.       PAGELENGTH 780p
.    \}
.    if '\\*[$PAPER]'10x14' \{\
.       PAGEWIDTH  10i
.       PAGELENGTH 14i
.    \}
.    if '\\*[$PAPER]'EXECUTIVE' \{\
.       PAGEWIDTH  7.25i
.       PAGELENGTH 10.5i
.    \}
.    if '\\*[$PAPER]'A3' \{\
.       PAGEWIDTH  842p
.       PAGELENGTH 1190p
.    \}
.    if '\\*[$PAPER]'A4' \{\
.       PAGEWIDTH  595p
.       PAGELENGTH 842p
.    \}
.    if '\\*[$PAPER]'A5' \{\
.       PAGEWIDTH  421p
.       PAGELENGTH 595p
.    \}
.    if '\\*[$PAPER]'B4' \{\
.       PAGEWIDTH  709p
.       PAGELENGTH 1002p
.    \}
.    if '\\*[$PAPER]'B5' \{\
.       PAGEWIDTH  501p
.       PAGELENGTH 709p
.    \}
.    if '\\$2'LANDSCAPE' \{\
.       nr #PAGE_WIDTH_TMP \\n[#PAGE_WIDTH]
.       PAGEWIDTH \\n[#PAGE_LENGTH]u
.       PAGELENGTH \\n[#PAGE_WIDTH_TMP]u
.    \}
.    if !r#L_MARGIN .L_MARGIN \\n[.o]
.    if !r#R_MARGIN .R_MARGIN 1i
.END
\#
\# ====================================================================
\#
\# +++PRINTSTYLE -- TYPEWRITE OR TYPESET+++
\#
\# PRINTSTYLE
\# ----------
\# *Arguments:
\#   TYPESET | TYPEWRITE [SINGLESPACE]
\# *Function:
\#   Sets type specs for typewriter-style or typeset output.
\# *Notes:
\#   Number registers: TYPEWRITE=1, TYPESET=2.
\#
.MAC PRINTSTYLE END
.    if !\\n[#COLLATE]=1 \{\
.       if !d$PAPER .PAPER LETTER
.       if '\\$1'TYPEWRITE' \{\
.          nr #PRINT_STYLE 1
.          if !\\n[#DOC_TYPE]=4 \{\
.             L_MARGIN 6P
.             R_MARGIN 6P
.          \}
.          ds $TYPEWRITER_FAM C
.          ds $TYPEWRITER_PS  12
.          TYPEWRITER
.          color 0
.          ie '\\$2'SINGLESPACE' \{\
.             nr #SINGLE_SPACE 1
.             vs 12
.             ie \\n[#DOC_TYPE]=4 .nr #FOOTER_ADJ \\n[.v]
.             el .nr #FOOTER_ADJ \\n[.v]
.             nr #ORIGINAL_DOC_LEAD \\n[.v]
.          \}
.          el \{\
.             if !\\n[#DOC_TYPE]=4 \{\
.                vs 24
.                nr #FOOTER_ADJ \\n[.v]/2
.                nr #ORIGINAL_DOC_LEAD \\n[.v]
.             \}
.          \}
.          QUAD    L
.          HY      OFF
.          SMARTQUOTES OFF
.          if !\\n[#PP_INDENT] .nr #PP_INDENT 3P
.          HDRFTR_RIGHT_CAPS
.          nr #BOLDER_UNITS 0
.          nr #CONDENSE 0
.          nr #EXTEND 0
.          if !\\n[#ITALIC_MEANS_ITALIC] .rm IT
.          rm BD
.          rm BDI
.          if !\\n[#ITALIC_MEANS_ITALIC] .rm PREV
.          if !\\n[#SLANT_MEANS_SLANT]   .UNDERLINE_SLANT
.          if !\\n[#ITALIC_MEANS_ITALIC] .UNDERLINE_ITALIC
.          if !\\n[#UNDERLINE_QUOTES]    .UNDERLINE_QUOTES
.          nr #IGNORE_COLUMNS 1
.          nr #RULE_WEIGHT 500
.          char \[em] --
.          tr `'
.          tr \[lq]"
.          tr \[rq]"
.       \}
.       if '\\$1'TYPESET' \{\
.          nr #PRINT_STYLE 2
.          if !\\n[#DOC_TYPE]=5 \{\
.             if !\\n[#DOC_TYPE]=4 \{\
.                L_MARGIN 6P
.                R_MARGIN 6P
.             \}
.          \}
.          FAMILY  T
.          FT      R
.          if !\\n[#DOC_TYPE]=4 .ps 12.5
.          if !\\n[#DOC_TYPE]=4 .vs 16
.\" In DEFAULTS, TRAPS is run with this leading, so we need a register to
.\" hold it for use with the .sp in FOOTER
.          nr #FOOTER_ADJ 12000
.          JUSTIFY
.          HY
.          HY_SET 2 36p 1p
.          KERN
.          LIG
.          SS 0
.          SMARTQUOTES
.          if !\\n[#PP_INDENT] \{\
.             in 2m                 \"Set indent
.             nr #PP_INDENT \\n[.i] \"Read into #PP_INDENT
.             in 0                  \"Remove indent
.          \}
.          HDRFTR_RIGHT_CAPS
.          rr #IGNORE_COLUMNS
.       \}
.\" Set up default style for nine levels of headings
.       nr #HD_LEVEL 0 1 \" loop step
.       nr #LOOP 9       \" loop count
.       while \\n+[#HD_LEVEL]<=\\n[#LOOP] \{\
.           HEADING_STYLE \\n[#HD_LEVEL] \
            FONT  B  \
            SIZE  +0 \
            QUAD  L  \
            NEEDS 1 \
            COLOR black
.\"  Set up default style for nine levels of TOC headings
.           TOC_ENTRY_STYLE \\n[#HD_LEVEL] \
            FONT  R  \
            SIZE  +0 \
            COLOR black
.       \}
.\" Set up decreasing sizes for headings levels 1 - 3, starting at +3
.       nr #HD_LEVEL 0 1 \" loop step
.       nr #LOOP 3       \" loop count
.       nr #HD_SIZE 4 1
.       while \\n+[#HD_LEVEL]<=\\n[#LOOP] \{\
.          nr #HD_SIZE_CHANGE \\n-[#HD_SIZE]
.          ds $HEAD_\\n[#HD_LEVEL]_SIZE +\\n[#HD_SIZE_CHANGE]
.       \}
.\" Set up TOC title style
.       TOC_TITLE_STYLE FONT R SIZE +0 INDENT 0
.\" Set up captions, labels, sources
.       LABELS ALL FONT B AUTOLEAD 2
.       LABELS EQN FONT R QUAD RIGHT
.       CAPTIONS ALL AUTOLEAD 2
.       CAPTIONS EQN QUAD CENTER
.       SOURCES TBL AUTOLEAD 2
.    \}
.END
\#
\# Set limited parameters to TYPEWRITE.
\#
.MAC TYPEWRITER_FAMILY END
.    ds $TYPEWRITER_FAM \\$1
.END
\#
.ALIAS TYPEWRITER_FAM TYPEWRITER_FAMILY
\#
.MAC TYPEWRITER_SIZE END
.    ds $TYPEWRITER_PS \\$1
.END
\#
.MAC TYPEWRITER END
.    fam \\*[$TYPEWRITER_FAM]
.    ft  R
.    ps  \\*[$TYPEWRITER_PS]
.END
\#
\# ITALIC MEANS ITALIC
\# -------------------
\# *Argument:
\#   <none>
\# *Function:
\#   Instructs TYPEWRITE to treat italics as italics, whether
\#   invoked via control lines or inline.
\# *Notes:
\#   ITALIC_MEANS_ITALIC and UNDERLINE_ITALIC are mutually exclusive,
\#   hence invoking the one automatically turns off the other.
\#
.MAC ITALIC_MEANS_ITALIC END
.    if \\n[#PRINT_STYLE]=1 \{\
.       nr #ITALIC_MEANS_ITALIC 1
.       rr #UNDERLINE_ITALIC
.       rm ROM
.       rm IT
.       rm PREV
.       ds ROM  \Ef[R]
.       ds IT   \Ef[I]
.       ds PREV \Ef[]
.    \}
.END
\#
\# UNDERLINE ITALIC
\# ----------------
\# *Argument:
\#   <none>
\# *Function:
\#   Instructs TYPEWRITE to underline italics, whether invoked
\#   via control lines or inline.
\# *Notes:
\#   UNDERLINE_ITALIC and ITALIC_MEANS_ITALIC are mutually exclusive,
\#   hence invoking the one automatically turns off the other.
\#
\#   UNDERLINE_ITALIC is the default for TYPEWRITE.
\#
.MAC UNDERLINE_ITALIC END
.    if \\n[#PRINT_STYLE]=1 \{\
.       nr #UNDERLINE_ITALIC 1
.       rr #ITALIC_MEANS_ITALIC
.       rm ROM
.       rm IT
.       rm PREV
.       ds ROM  \E*[ULX]
.       ds IT   \E*[UL]
.       ds PREV \E*[ULX]
.    \}
.END
\#
\# UNDERLINE SLANT
\# ---------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Instructs TYPEWRITE to underline occurrences of \*[SLANT], or
\#   turns feature off.
\# *Notes:
\#   Users may want \*[SLANT] to mean slant in TYPEWRITE, although
\#   most of the time, \*[SLANT] most likely means the user wanted
\#   italic but didn't have it, ergo the need to tell TYPEWRITE to
\#   treat \*[SLANT] as italic (i.e. underlined).
\#
\#   UNDERLINE_SLANT and SLANT_MEANS_SLANT are mutually exclusive,
\#   hence invoking the one automatically turns off the other.
\#
\#   UNDERLINE_SLANT is the default for TYPEWRITE.
\#
.MAC UNDERLINE_SLANT END
.    if \\n[#PRINT_STYLE]=1 \{\
.       rr #SLANT_MEANS_SLANT
.       nr #UNDERLINE_SLANT 1
.       rm SLANT
.       rm SLANTX
.       ds SLANT  \ER'#SLANT_ON 1'\E*[UL]
.       ds SLANTX \ER'#SLANT_ON 0'\E*[ULX]
.    \}
.END
\#
.MAC SLANT_MEANS_SLANT END
.    if \\n[#PRINT_STYLE]=1 \{\
.       rr #UNDERLINE_SLANT
.       nr #SLANT_MEANS_SLANT 1
.       rm SLANT
.       rm SLANTX
.       ds SLANT  \ER'#SLANT_ON 1'\ES'\En[#DEGREES]'
.       ds SLANTX \ER'#SLANT_ON 0'\ES'0'
.    \}
.END
\#
.MAC IGNORE_COLUMNS END
.    if \\n[#PRINT_STYLE]=1 .nr #NO_COLUMNS 1
.END
\#
\# ====================================================================
\#
\# +++COPY STYLE -- DRAFT OR FINAL+++
\#
\# COPY STYLE
\# ----------
\# *Arguments:
\#   DRAFT | FINAL
\# *Function:
\#   Sets registers that are used to determine what to put
\#   in the default header, and how to number pages.
\# *Notes:
\#   DOCTYPE must come before COPYSTYLE.
\#
.MAC COPYSTYLE END
.    ds $COPY_STYLE \\$1
.    if '\\*[$COPY_STYLE]'DRAFT' \{\
.       nr #COPY_STYLE 1
.       if !d$DRAFT .DRAFT 1
.    \}
.    if '\\*[$COPY_STYLE]'FINAL' .nr #COPY_STYLE 2
.    if !d$CHAPTER_STRING  .CHAPTER_STRING "Chapter"
.    if !d$DRAFT_STRING    .DRAFT_STRING "Draft"
.    if !d$REVISION_STRING .REVISION_STRING "Rev."
.\" Default
.    if \\n[#DOC_TYPE]=1 \{\
.       ie \\n[#COPY_STYLE]=1 \{\
.          ie \\n[#PAGENUM_STYLE_SET] .PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.          el .PAGENUM_STYLE roman
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ie \\n[#DRAFT_WITH_PAGENUM] .ds $HDRFTR_CENTER
.             el \{\
.                ie '\\*[$REVISION]'' \{\
.                   ds $HDRFTR_CENTER \
                    \\*[$DRAFT_STRING]\\*[$DRAFT]
.                \}
.                el \{\
.                   ds $HDRFTR_CENTER \
                    \\*[$DRAFT_STRING]\\*[$DRAFT], \
                    \\*[$REVISION_STRING] \\*[$REVISION]
.                \}
.             \}
.          \}
.       \}
.       el \{\
.          ie \\n[#PAGENUM_STYLE_SET] .PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.          el                         .PAGENUM_STYLE DIGIT
.          if \\n[#DRAFT_WITH_PAGENUM] .rr #DRAFT_WITH_PAGENUM
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ds $HDRFTR_CENTER
.             rr #USER_DEF_HDRFTR_CENTER
.          \}
.       \}
.    \}
.\" Chapter
.    if \\n[#DOC_TYPE]=2 \{\
.\" Copystyle DRAFT
.       ie \\n[#COPY_STYLE]=1 \{\
.          ie \\n[#PAGENUM_STYLE_SET] \
.             PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.          el \
.             PAGENUM_STYLE roman
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ie \\n[#DRAFT_WITH_PAGENUM] \{\
.                ie '\\*[$CHAPTER]'' \{\
.                   ie !'\\*[$CHAPTER_TITLE_1]'' \
.                       ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                   el .ds $HDRFTR_CENTER \\*[$CHAPTER_STRING]
.                \}
.                el \{\
.                   ie !'\\*[$CHAPTER_TITLE_1]'' \
.                       ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                   el .ds $HDRFTR_CENTER \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.                \}
.             \}
.             el \{\
.                ie '\\*[$REVISION]'' \{\
.                   ie '\\*[$CHAPTER]'' \{\
.                      ie !'\\*[$CHAPTER_TITLE_1]'' \{\
.                         ie '\\*[$DRAFT]'' \
.                            ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT]
.                         \}
.                      \}
.                      el \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT]
.                         \}
.                      \}
.                   \}
.                   el \{\
.                      ie !'\\*[$CHAPTER_TITLE_1]'' \{\
.                         ie '\\*[$DRAFT]'' \
.                            ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE_1], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT]
.                         \}
.                      \}
.                      el \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING] \\*[$CHAPTER], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT]
.                         \}
.                      \}
.                   \}
.                \}
.                el \{\
.                   ie '\\*[$CHAPTER]'' \{\
.                      ie !'\\*[$CHAPTER_TITLE_1]'' \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$REVISION_STRING] \\*[$REVISION]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT], \
                             \\*[$REVISION_STRING] \\*[$REVISION]
.                         \}
.                      \}
.                      el \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING], \
                             \\*[$REVISION_STRING] \\*[$REVISION]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT], \
                             \\*[$REVISION_STRING] \\*[$REVISION]
.                         \}
.                      \}
.                   \}
.                   el \{\
.                      ie !'\\*[$CHAPTER_TITLE_1]'' \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$REVISION_STRING] \\*[$REVISION]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT], \
                             \\*[$REVISION_STRING] \\*[$REVISION]
.                         \}
.                      \}
.                      el \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING] \\*[$CHAPTER], \
                             \\*[$REVISION_STRING] \\*[$REVISION]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING] \\*[$CHAPTER], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT], \
                             \\*[$REVISION_STRING] \\*[$REVISION]
.                         \}
.                      \}
.                   \}
.                \}
.             \}
.          \}
.       \}
.\" Copystyle FINAL
.       el \{\
.          if \\n[#DRAFT_WITH_PAGENUM] .rr #DRAFT_WITH_PAGENUM
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ie \\n[#PAGENUM_STYLE_SET] \
.                PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.             el .PAGENUM_STYLE DIGIT
.             ie '\\*[$CHAPTER]'' \{\
.                ie !'\\*[$CHAPTER_TITLE_1]'' \
.                   ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                el \
.                   ds $HDRFTR_CENTER \\*[$CHAPTER_STRING]
.             \}
.             el \{\
.                ie !'\\*[$CHAPTER_TITLE_1]'' \
.                   ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                el \
.                   ds $HDRFTR_CENTER \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.             \}
.          \}
.       \}
.    \}
.\" Named
.    if \\n[#DOC_TYPE]=3 \{\
.       ie \\n[#COPY_STYLE]=1 \{\
.          ie \\n[#PAGENUM_STYLE_SET] .PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.          el                         .PAGENUM_STYLE roman
.          ie \\n[#DRAFT_WITH_PAGENUM] \
.             ds $HDRFTR_CENTER \\*[$DOC_TYPE]
.          el \{\
.             if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.                ie '\\*[$REVISION]'' \{\
.                   ie '\\*[$DRAFT]'' \
.                      ds $HDRFTR_CENTER \\*[$DOC_TYPE]
.                   el \{\
.                      ds $HDRFTR_CENTER \
                       \\*[$DOC_TYPE], \
                       \\*[$DRAFT_STRING]\\*[$DRAFT]
.                   \}
.                \}
.                el \{\
.                   ie '\\*[$DRAFT]'' \{\
.                      ds $HDRFTR_CENTER \
                       \\*[$DOC_TYPE], \
                       \\*[$REVISION_STRING] \\*[$REVISION]
.                   \}
.                   el \{\
.                      ds $HDRFTR_CENTER \
                       \\*[$DOC_TYPE], \
                       \\*[$DRAFT_STRING]\\*[$DRAFT], \
                       \\*[$REVISION_STRING] \\*[$REVISION]
.                   \}
.                \}
.             \}
.          \}
.       \}
.       el \{\
.          if \\n[#DRAFT_WITH_PAGENUM] .rr #DRAFT_WITH_PAGENUM
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ie \\n[#PAGENUM_STYLE_SET] .PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.             el .PAGENUM_STYLE DIGIT
.             ds $HDRFTR_CENTER \\*[$DOC_TYPE]
.          \}
.       \}
.    \}
.END
\#
\# ====================================================================
\#
\# +++COLLECT DOC INFO (reference macros, metadata)+++
\#
\# *Arguments:
\#   various string/register arguments
\# *Function:
\#   Set strings and registers for covers, docheaders, page headers.
\#
.MAC DOCTITLE END
.    rr #DOCTITLE_NUM
.    nr #DOCTITLE_NUM 0 1
.    while \\n[#NUM_ARGS]>\\n[#DOCTITLE_NUM] \{\
.       ds $DOCTITLE_\\n+[#DOCTITLE_NUM] \\$\\n[#DOCTITLE_NUM]
.    \}
.    ds $DOCTITLE \\$*
.    PDF_TITLE \\*[$DOCTITLE]
.END
\#
.MAC TITLE END \"Document title
.    if '\\$1'DOC_COVER' \{\
.       shift
.       DOC_COVERTITLE \\$@
.       return
.    \}
.    if '\\$1'COVER' \{\
.       shift
.       COVERTITLE \\$@
.       return
.    \}
.    ie \\n[#NUM_ARGS]=0 \{\
.       if \\n[#TITLE_NUM] \{\
.          nr #ITEM 0 1
.          while \\n[#TITLE_NUM]>\\n[#ITEM] \{\
.             rm $TITLE_\\n+[#ITEM]
.          \}
.          rr #TITLE_NUM
.       \}
.    \}
.    el \{\
.       nr #TITLE_NUM 0 1
.       while \\n[#NUM_ARGS]>\\n[#TITLE_NUM] \{\
.          ds $TITLE_\\n+[#TITLE_NUM] \\$\\n[#TITLE_NUM]
.       \}
.       ds $TITLE \\$*
.    \}
.END
\#
.MAC SUBTITLE END \"Document sub-title
.    ie \\n[#NUM_ARGS]=0 \{\
.       if \\n[#DOC_COVER_SUBTITLE_NUM] \
.          ds COVER_ DOC_COVER_
.       if \\n[#COVER_SUBTITLE_NUM] \
.          ds COVER_ COVER_
.       if \\n[#\\*[COVER_]SUBTITLE_NUM] \{\
.          nr #ITEM 0 1
.          while \\n[#\\*[COVER_]SUBTITLE_NUM]>\\n[#ITEM] \{\
.             rm $\\*[COVER_]SUBTITLE_\\n+[#ITEM]
.          \}
.          rr #\\*[COVER_]SUBTITLE_NUM
.          rm $SUBTITLE
.       \}
.    \}
.    el \{\
.       if '\\$1'DOC_COVER' \{\
.          ds COVER_ DOC_COVER_
.          shift
.       \}
.       if '\\$1'COVER' \{\
.          ds COVER_ COVER_
.          shift
.       \}
.       nr #\\*[COVER_]SUBTITLE_NUM 0 1
.       while \\n[#NUM_ARGS]>\\n[#\\*[COVER_]SUBTITLE_NUM] \{\
.          ds $\\*[COVER_]SUBTITLE_\\n+[#\\*[COVER_]SUBTITLE_NUM] \
\\$\\n[#\\*[COVER_]SUBTITLE_NUM]
.       \}
.       rm COVER_
.       ds $SUBTITLE \\$*
.    \}
.END
\#
.MAC CHAPTER END \"If document is a chapter, the chapter number
.    nr #CHAPTER_CALLED 1
.    ds $CHAPTER \\$1
.    if \B'\\*[$CHAPTER]' .nr #CH_NUM \\*[$CHAPTER]
.    if !r #CH_NUM .nr #CH_NUM 1
.END
.
.MAC CHAPTER_NUMBER END
.    nr #CH_NUM \\$1
.END
\#
.MAC CHAPTER_TITLE END \" This defines what comes after Chapter #
.    ie \\n[#NUM_ARGS]=0 \{\
.       if \\n[#CHAPTER_TITLE_NUM] \{\
.          nr #ITEM 0 1
.          while \\n[#CHAPTER_TITLE_NUM]>\\n[#ITEM] \{\
.             rm $CHAPTER_TITLE_\\n+[#ITEM]
.          \}
.          rr #CHAPTER_TITLE_NUM
.          rm $CHAPTER_TITLE
.       \}
.    \}
.    el \{\
.       rr #CHAPTER_TITLE_NUM
.       nr #CHAPTER_TITLE_NUM 0 1
.       while \\n[#NUM_ARGS]>\\n[#CHAPTER_TITLE_NUM] \{\
.          ds $CHAPTER_TITLE_\\n+[#CHAPTER_TITLE_NUM] \
\\$\\n[#CHAPTER_TITLE_NUM]
.       \}
.       ds $CHAPTER_TITLE \\$*
.    \}
.END
\#
.MAC DRAFT END \"Draft number
.    ie '\\$1'' .ds $DRAFT
.    el .ds $DRAFT " \\$1
.END
\#
.MAC REVISION END \"Revision number
.    ds $REVISION \\$1
.END
\#
.MAC DRAFT_WITH_PAGENUMBER END \"Attach draft/revision strings to page number
.    nr #DRAFT_WITH_PAGENUM 1
.END
\#
.MAC AUTHOR END \"Author.  Enclose all args fully in double quotes.
.    rr #NO_PRINT_AUTHOR
.    if '\\$1'DOC_COVER' \{\
.       ds COVER_ DOC_COVER_
.       shift
.    \}
.    if '\\$1'COVER' \{\
.       ds COVER_ COVER_
.       shift
.    \}
.    nr #\\*[COVER_]AUTHOR_NUM 0 1
.    while \\n[#NUM_ARGS]>\\n[#\\*[COVER_]AUTHOR_NUM] \{\
.       ds $\\*[COVER_]AUTHOR_\\n+[#\\*[COVER_]AUTHOR_NUM] \
\\$\\n[#\\*[COVER_]AUTHOR_NUM]
.       if !'\\*[$\\*[COVER_]AUTHOR_\\n[#\\*[COVER_]AUTHOR_NUM]]'' \
.          as $AUTHORS \
"\\*[$\\*[COVER_]AUTHOR_\\n[#\\*[COVER_]AUTHOR_NUM]], \"
.    \}
.    ds $AUTHOR \\*[$AUTHOR_1]
.    substring $AUTHORS 0 -2
.    ds PDF_AUTHORS \\*[$AUTHORS]
.    pdfmomclean PDF_AUTHORS
.    nop \!x X ps:exec [/Author (\\*[PDF_AUTHORS]) /DOCINFO pdfmark
.END
.
.ALIAS EDITOR AUTHOR
\#
.MAC COPYRIGHT END          \"For use on cover pages only
.   ie \\n[#NUM_ARGS]=1 \
.       ds $COVER_COPYRIGHT \[co]\\$1
.    el \
.       if '\\$1'DOC_COVER' .ds $DOC_COVER_COPYRIGHT \[co]\\$2
.END
\#
.MAC COPYRIGHT_V_ADJUST END
.    ds $COPYRIGHT_V_ADJ \\$1
.END
\#
.MAC MISC END \"Doc cover and cover pages only; enclose all args in double quotes
.    rm COVER_
.    ie \\n[#NUM_ARGS]=0 \{\
.       if \\n[#DOC_COVER_MISC_LINES] \
.          ds COVER_ DOC_COVER_
.       if \\n[#COVER_MISC_LINES] \
.          ds COVER_ COVER_
.       if \\n[#\\*[COVER_]MISC_LINES] \{\
.          nr #LINE 0 1
.          while \\n[#\\*[COVER_]MISC_LINES]>\\n[#LINE] \{\
.             rm $\\*[COVER_]MISC_\\n+[#LINE]
.          \}
.          rr #\\*[COVER_]MISC_LINES
.       \}
.    \}
.    el \{\
.       if '\\$1'DOC_COVER' \{\
.          ds COVER_ DOC_COVER_
.          shift
.       \}
.       if '\\$1'COVER' \{\
.          ds COVER_ COVER_
.          shift
.       \}
.       nr #\\*[COVER_]MISC_LINE 0 1
.       while \\n[#NUM_ARGS]>\\n[#\\*[COVER_]MISC_LINE] \{\
.          ds $\\*[COVER_]MISC_\\n+[#\\*[COVER_]MISC_LINE] \
\\$[\\n[#\\*[COVER_]MISC_LINE]]
.       \}
.       nr #\\*[COVER_]MISC_LINES \\n[#NUM_ARGS]
.       rm COVER_
.    \}
.END
\#
\# Page number that appears on page one.
.MAC PAGENUMBER END
.    nr #n%_AT_PAGENUM_SET \\n%
.    nr #PAGE_NUM_ADJ \\$1-\\n[#n%_AT_PAGENUM_SET]
.    rr #n%_AT_PAGENUM_SET
.    nr #PAGE_NUM_SET 1
.END
\#
\# Replacement string for pagenumber.
.MAC PAGENUMBER_STRING END
.    ds $PAGENUM_STRING \\$1
.END
\#
\# ====================================================================
\#
\# +++TYPE OF DOCUMENT+++
\#
\# DOCUMENT TYPE
\# -------------
\# *Argument:
\#   DEFAULT | CHAPTER | NAMED "<whatever> | LETTER
\# *Function:
\#   Creates strings and sets registers for document types.
\# *Notes:
\#   Number registers: DEFAULT=1, CHAPTER=2, NAMED=3, LETTER=4
\#
.MAC DOCTYPE END
.    if '\\$1'DEFAULT' .nr #DOC_TYPE 1
.    if '\\$1'CHAPTER' .nr #DOC_TYPE 2
.    if '\\$1'NAMED' \{\
.       rr #NO_PRINT_DOCTYPE
.       ds $DOC_TYPE \\$2
.       nr #DOC_TYPE 3
.    \}
.    if '\\$1'LETTER' \{\
.       nr #DOC_TYPE 4
.       L_MARGIN 1.125i
.       R_MARGIN 1.125i
.       ps 12
.       vs 13.5
.       nr #FOOTER_ADJ \\n[.v]
.       DOCHEADER OFF
.       PARA_INDENT 3m
.       INDENT_FIRST_PARAS
.       PARA_SPACE
.       ds $SUITE \En[#SUITE]
.       HEADER_MARGIN 3P+6p
.       HEADER_GAP 3P
.       FOOTERS
.       FOOTER_RULE OFF
.       FOOTER_LEFT ""
.       FOOTER_CENTER ""
.       FOOTER_RIGHT_SIZE +0
.       FOOTER_RIGHT "\&.../\E*[$SUITE]
.       FOOTER_ON_FIRST_PAGE
.       em ALL_DONE
.    \}
.    if '\\$1'SLIDES' \{\
.       shift
.       nr #DOC_TYPE 5
.       PRINTSTYLE TYPESET
.       FAMILY H
.       QUAD CENTER
.       QUOTE_STYLE QUAD CENTER
.       BLOCKQUOTE_STYLE \
          QUAD J \
          INDENT \\n[.l]u/5u
.       PARA_INDENT 0
.       NO_SHIM
.       NO_FLEX
.       HEADING_STYLE 1 \
          SIZE +8 \
          QUAD CENTER
.       HEADING_STYLE 2 \
          SIZE +4 \
          QUAD CENTER
.       HEADING_STYLE 3 \
          SIZE +2 \
          QUAD CENTER
.       DOCHEADER off
.       PAGINATION off
.       PAGENUM_HYPHENS off
.       HEADERS off
.       FOOTERS off
.       HEADERS_PLAIN
.       FOOTERS_PLAIN
.       nr loop-count 0 1
.       nr loop-counter \\n[#NUM_ARGS]
.\" Default 16:9 setup if no ASPECT
.       PAGE 11i 6.1875i 36p 36p 80p 72p
.       PT_SIZE 14
.       AUTOLEAD 4
.       HEADER_SIZE  -2
.       while \\n+[loop-count]<=\\n[loop-counter] \{\
.          if '\\$1'ASPECT' \{\
.             if '\\$2'4:3' \{\
.                PAGE 11i 8.25i 36p 36p 90p 84p
.                PT_SIZE 16
.                AUTOLEAD 6
.                HEADER_SIZE  -3
.             \}
.             if '\\$2'16:9' \{\
.                PAGE 11i 6.1875i 36p 36p 80p 72p
.                PT_SIZE 14
.                AUTOLEAD 4
.                HEADER_SIZE  -2
.             \}
.             shift 2
.          \}
.          if '\\$1'HEADER' \{\
.             shift 1
.             nr #SLIDE_HEADERS 1
.             ds $SLIDE_HDR_L \\$1
.             ds $SLIDE_HDR_C \\$2
.             ds $SLIDE_HDR_R \\$3
.             HEADER_MARGIN 45p
.             shift 3
.          \}
.          if '\\$1'FOOTER' \{\
.             shift 1
.             nr #SLIDE_FOOTERS 1
.             ds $SLIDE_FTR_L \\$1
.             ds $SLIDE_FTR_C \\$2
.             ds $SLIDE_FTR_R \\$3
.             shift 3
.          \}
.          if '\\$1'TRANSITION' \{\
.             shift 1
.             ds $TRANS_TYPE \\$1
.             shift 1
.          \}
.          if '\\$1'PAUSE' \{\
.             shift 1
.             ds $PAUSE_TYPE \\$1
.             shift 1
.          \}
.       \}
.       if d $TRANS_TYPE \
.          pdftransition PAGE \\*[$TRANS_TYPE]
.       if d $PAUSE_TYPE \
.          pdftransition BLOCK \\*[$PAUSE_TYPE]
.    \}
.    ie \\n[#SLIDE_HEADERS]+\\n[#SLIDE_FOOTERS]=2 \{\
.       HEADERS_AND_FOOTERS L "^\\*[$SLIDE_HDR_L]#\\*[$SLIDE_HDR_C]#\\*[$SLIDE_HDR_R]^" \
                            L "^\\*[$SLIDE_FTR_L]#\\*[$SLIDE_FTR_C]#\\*[$SLIDE_FTR_R]^"
.    \}
.    el \{\
.       if \\n[#SLIDE_HEADERS] \{\
.          HEADERS
.          HEADER_RECTO L "^\\*[$SLIDE_HDR_L]#\\*[$SLIDE_HDR_C]#\\*[$SLIDE_HDR_R]^" \
.       \}
.       if \\n[#SLIDE_FOOTERS] \{\
.          FOOTERS
.          FOOTER_RECTO L "^\\*[$SLIDE_FTR_L]#\\*[$SLIDE_FTR_C]#\\*[$SLIDE_FTR_R]^"
.       \}
.    \}
.END
\#
\# +++LETTER MACROS+++
\#
\# First, create a register to hold incrementing numbers to be
\# appended to LETTERHEAD.
\#
.nr #FIELD 0 1
\#
\# DATE
\# ----
\# *Arguments:
\#   <none>
\# *Function:
\#   Stores date (entered on the line after .DATE) in diversion
\#   LETTERHEAD<n>
\#
.MAC DATE END
.    if !'\\n[.z]'' .di
.    di LETTERHEAD\\n+[#FIELD]
.    ie \\n[#FIELD]=1 \{\
.       nr #DATE_FIRST 1
.       RIGHT
.    \}
.    el .LEFT
.END
\#
\# TO
\# --
\# *Arguments:
\#   <none>
\# *Function:
\#   Stores addressee address (entered on the line after .TO) in
\#   diversion LETTERHEAD<n>
\#
.MAC TO END
.    if !'\\n[.z]'' .di
.    di LETTERHEAD\\n+[#FIELD]
.    LEFT
.END
\#
\# FROM
\# ----
\# *Arguments:
\#   <none>
\# *Function:
\#   Stores addresser address (entered on the line after .FROM) in
\#   diversion LETTERHEAD<n>
\#
.MAC FROM END
.    if !'\\n[.z]'' .di
.    di LETTERHEAD\\n+[#FIELD]
.    LEFT
.END
\#
\# GREETING
\# --------
\# *Arguments:
\#   <none>
\# *Function:
\#   Stores greeting (entered on the line after .GREETING) in
\#   diversion LETTERHEAD<n>
\#
.MAC GREETING END
.    if !'\\n[.z]'' .di
.    di LETTERHEAD\\n+[#FIELD]
.    LEFT
.END
\#
\# CLOSING
\# -------
\# *Arguments:
\#   <closing string>
\# *Function:
\#   Stores greeting in diversion CLOSING.
\#
.MAC CLOSING END
.    if '\\*[$SIG_SPACE]'' .ds $SIG_SPACE 3v
.    ie ( (2v+\\*[$SIG_SPACE]) > \\n[.t] ) \{\
.       ie !\\n[@TOP] \{\
.          ch HEADER
.          ch FOOTER
.          br
.          tm1 "[mom]: Insufficient room for \\$0 and signature line.
.          ab   [mom]: Terminating '\\n[.F]' before closing.
.       \}
.       el .sp
.    \}
.    el .br
.    nr #CLOSING 1
.    di CLOSING_TEXT
.END
\#
\# CLOSING INDENT
\# --------------
\# *Argument:
\#   <amount to indent closing from left margin>
\# *Function:
\#   Defines string $CLOSE_INDENT for use in macro, ALL_DONE.
\#
.MAC CLOSING_INDENT END
.    ds $CLOSE_INDENT \\$1
.END
\#
\# SIGNATURE_SPACE
\# ---------------
\# *Argument:
\#   <amount of space to leave for signature>
\# *Function:
\#   Defines string $SIG_SPACE for use in macro, ALL_DONE.
\#
.MAC SIGNATURE_SPACE END
.    ds $SIG_SPACE \\$1
.END
\#
\# NO SUITE
\# --------
\# *Arguments:
\#   <none>
\# *Function:
\#   Redefines $FOOTER_RIGHT to blank so that a suite number doesn't
\#   appear at the bottom of letter pages.
\#
.MAC NO_SUITE END
.    FOOTER_RIGHT ""
.END
\#
\# ====================================================================
\#
\# +++DEFAULTS FOR DOCUMENT PROCESSING+++
\#
\# TYPE-STYLE CONTROL MACROS
\# -------------------------
\# The control macros for family, font, size, color and quad are
\# here grouped together.  Each (e.g., _FAMILY) uses the calling alias
\# to determine the document element to which the style parameter
\# applies.  Defaults for all these guys are set in DEFAULTS, and
\# listed in the "Control Macros" section of the documentation
\# pertinent to the element whose style is to be changed.
\#
.MAC _FAMILY END
.    ds PARAM      FAM
.    ds ELEMENT    \\$0
.    if '\\$0'COPYRIGHT_FAMILY' \
.       ds ELEMENT COVER_COPYRIGHT_FAMILY
.    ds FROM_ALIAS \\$0
.    substring ELEMENT 0 -4    \" Strip 'ILY' from FAMILY
.    ASSIGN_ELEMENT \\$1
.END
\#
.MAC _FONT END
.    ds PARAM      FT
.    ds ELEMENT    \\$0
.    ds FROM_ALIAS \\$0
.    if '\\$0'COPYRIGHT_FONT' \
.       ds ELEMENT COVER_COPYRIGHT_FONT
.    substring ELEMENT 0 -5
.    ds ELEMENT \\*[ELEMENT]FT \" ELEMENT is now \\$0_FT
.    ASSIGN_ELEMENT \\$1
.END
\#
.MAC _SIZE END
.    ds PARAM       SIZE_CHANGE
.    ds ELEMENT     \\$0_CHANGE
.    if '\\$0'CODE_SIZE' \{\
.       ds PARAM SIZE_ADJ
.       ds ELEMENT \\$0_ADJ
.    \}
.    if '\\$0'COPYRIGHT_SIZE' \
.       ds ELEMENT COVER_COPYRIGHT_SIZE_CHANGE
.    ds FROM_ALIAS  \\$0
.    ASSIGN_ELEMENT \\$1
.END
\#
.MAC _COLOR END
.    if \\n[#PRINT_STYLE]=1 .return
.    ds PARAM       COLOR
.    ds ELEMENT     \\$0
.    if '\\$0'COPYRIGHT_COLOR' \
.       ds ELEMENT COVER_COPYRIGHT_COLOR
.    ds FROM_ALIAS  \\$0
.    ASSIGN_ELEMENT \\$1
.END
\#
.MAC _CAPS END
.    ds CAPS_TYPE \\$0
.    substring CAPS_TYPE 0 7
.    ds CALLED_AS \\$0
.    substring CALLED_AS -7
.    ie '\\*[CALLED_AS]'NO_CAPS' \{\
.       ie '\\*[CAPS_TYPE]'BIBLIOGR' \{\
.          if '\\$0'BIBLIOGRAPHY_HEADER_NO_CAPS' .rr #BIB_STRING_CAPS
.          if '\\$0'BIBLIOGRAPHY_STRING_NO_CAPS' .rr #BIB_STRING_CAPS
.       \}
.       el \{\
.          ie '\\*[CAPS_TYPE]'ENDNOTES' \{\
.             if '\\$0'ENDNOTES_HEADER_NO_CAPS' .rr #EN_STRING_CAPS
.             if '\\$0'ENDNOTES_STRING_NO_CAPS' .rr #EN_STRING_CAPS
.          \}
.          el \{\
.             ie '\\$0'TOC_HEADER_NO_CAPS' .rr #TOC_STRING_CAPS
.             el \{\
.                ds REGISTER_TYPE \\$0
.                substring REGISTER_TYPE 0 -8
.                as REGISTER_TYPE CAPS
.                rr #\\*[REGISTER_TYPE]
.             \}
.          \}
.       \}
.    \}
.    el \{\
.       ie '\\*[CAPS_TYPE]'BIBLIOGR' \{\
.          if '\\$0'BIBLIOGRAPHY_HEADER_CAPS' .nr #BIB_STRING_CAPS 1
.          if '\\$0'BIBLIOGRAPHY_STRING_CAPS' .nr #BIB_STRING_CAPS 1
.       \}
.       el .nr #\\$0 1
.    \}
.END
.
.ALIAS _NO_CAPS _CAPS
\#
.MAC _SMALLCAPS END
.    ds SMALLCAPS_TYPE \\$0
.    substring SMALLCAPS_TYPE 0 7
.    ds CALLED_AS \\$0
.    substring CALLED_AS -12
.    ie '\\*[CALLED_AS]'NO_SMALLCAPS' \{\
.       ie '\\*[SMALLCAPS_TYPE]'BIBLIOGR' \{\
.          if '\\$0'BIBLIOGRAPHY_HEADER_NO_SMALLCAPS' .rr #BIB_STRING_SMALLCAPS
.          if '\\$0'BIBLIOGRAPHY_STRING_NO_SMALLCAPS' .rr #BIB_STRING_SMALLCAPS
.       \}
.       el \{\
.          ie '\\*[SMALLCAPS_TYPE]'ENDNOTES' \{\
.             if '\\$0'ENDNOTES_HEADER_NO_SMALLCAPS' .rr #EN_STRING_SMALLCAPS
.             if '\\$0'ENDNOTES_STRING_NO_SMALLCAPS' .rr #EN_STRING_SMALLCAPS
.          \}
.          el \{\
.             ie '\\$0'TOC_HEADER_NO_SMALLCAPS' .rr #TOC_STRING_SMALLCAPS
.             el \{\
.                ds REGISTER_TYPE \\$0
.                substring REGISTER_TYPE 0 -13
.                as REGISTER_TYPE SMALLCAPS
.                rr #\\*[REGISTER_TYPE]
.             \}
.          \}
.       \}
.    \}
.    el \{\
.       ie '\\*[SMALLCAPS_TYPE]'BIBLIOGR' \{\
.          if '\\$0'BIBLIOGRAPHY_HEADER_SMALLCAPS' .nr #BIB_STRING_SMALLCAPS 1
.          if '\\$0'BIBLIOGRAPHY_STRING_SMALLCAPS' .nr #BIB_STRING_SMALLCAPS 1
.       \}
.       el .nr #\\$0 1
.    \}
.END
.
.ALIAS _NO_SMALLCAPS _SMALLCAPS
\#
.MAC _QUAD END
.    if '\\$0'BIBLIOGRAPHY_QUAD' \{\
.       if '\\$1'R' .QUAD-ERROR \\$0
.       if '\\$1'C' .QUAD-ERROR \\$0
.    \}
.    if '\\$0'ENDNOTE_QUAD' \{\
.       if '\\$1'R' .QUAD-ERROR \\$0
.       if '\\$1'C' .QUAD-ERROR \\$0
.    \}
.    if '\\$0'DOC_QUAD' \
.       if !\\n[#DOCS] .DOC_MACRO_ERROR \\$0
.    ds PARAM       QUAD
.    ds ELEMENT     \\$0
.    if '\\$0'COPYRIGHT_QUAD' \
.       ds ELEMENT COVER_COPYRIGHT_QUAD
.    ds FROM_ALIAS  \\$0
.    ASSIGN_ELEMENT \\$1
.END
\#
\# Special handling for QUOTE quadding
\#
.MAC QUOTE_QUAD END
.    ds $Q_QUAD \\$0
.    substring $Q_QUAD 6
.END
.
.ALIAS QUOTE_LEFT   QUOTE_QUAD
.ALIAS QUOTE_CENTER QUOTE_QUAD
.ALIAS QUOTE_RIGHT  QUOTE_QUAD
\#
.MAC QUAD-ERROR END
.    tm1 "[mom]: \\$1 at line \\n[.c] of '\\n[.F]' must be set to either L or J.
.    ab   [mom]: Aborting.
.END
\#
.MAC ASSIGN_ELEMENT END
.    rm $\\*[ELEMENT] \" Clear this first
.\" HDRFTR_<POSITION>_<PARAMETER> need special handling.
.    ds hdrftr \\*[FROM_ALIAS]
.    substring hdrftr 0 5
.    if '\\*[hdrftr]'HDRFTR' \{\
.       ds hdrftr-pos-element \\*[ELEMENT]
.\" See if ELEMENT is of the form HDRFTR_<pos>_<param>
.       substring hdrftr-pos-element 0 7
.       substring hdrftr-pos-element -1
.       if !'\\*[ELEMENT]'HDRFTR_COLOR' \{\
.          if '\\*[hdrftr-pos-element]'L' .nr hdrftr-pos-element 1
.          if '\\*[hdrftr-pos-element]'C' .nr hdrftr-pos-element 1
.          if '\\*[hdrftr-pos-element]'R' .nr hdrftr-pos-element 1
.       \}
.    \}
.    if !\\n[hdrftr-pos-element] \{\
.       ds c1-c5 \\*[ELEMENT]
.       substring c1-c5 0 4  \" Grab first five letters of the alias
.    \}
.\"  If none of the following, convert the substring of the
.\"  calling alias, ie \*[ELEMENT], into the parameter string, e.g.,
.\"  $TITLE_FAM, assign arg, and set register.
.    if !'\\*[c1-c5]'BIBLI' \
.    if !'\\*[c1-c5]'BLOCK' \
.    if !'\\*[c1-c5]'CITAT' \
.    if !'\\*[c1-c5]'ENDNO' \
.    if !'\\*[c1-c5]'EPIGR' \
.    if !'\\*[c1-c5]'FOOTN' \
.    if !'\\*[c1-c5]'HDRFT' \
.    if !'\\*[c1-c5]'LINEN' \
.    if !'\\*[c1-c5]'PAGEN' \{\
.       ie '\\*[ELEMENT]'CODE_SIZE_ADJ' .nr #\\*[ELEMENT] \\$1
.       el \{\
.          ds $\\*[ELEMENT] \\$1
.          nr #\\*[ELEMENT] 1
.       \}
.    \}
.    if '\\*[$\\*[ELEMENT]]'' \{\
.       if '\\*[c1-c5]'BIBLI' .ASSIGN_PARAM BIB       \\$1
.       if '\\*[c1-c5]'BLOCK' .ASSIGN_PARAM BQUOTE_   \\$1
.       if '\\*[c1-c5]'CITAT' .ASSIGN_PARAM BQUOTE_   \\$1
.       if '\\*[c1-c5]'ENDNO' .ASSIGN_PARAM EN        \\$1
.       if '\\*[c1-c5]'EPIGR' .ASSIGN_PARAM EPI_      \\$1
.       if '\\*[c1-c5]'FOOTN' .ASSIGN_PARAM FN_       \\$1
.       if '\\*[c1-c5]'HDRFT' .ASSIGN_PARAM HDRFTR_   \\$1
.       if '\\*[c1-c5]'LINEN' .ASSIGN_PARAM LN_       \\$1
.       if '\\*[c1-c5]'PAGEN' .ASSIGN_PARAM PAGE_NUM_ \\$1
.    \}
.    if \\n[hdrftr-pos-element] \{\
.       if '\\*[hdrftr-pos-element]'L' .ds hdrftr-pos-element LEFT
.       if '\\*[hdrftr-pos-element]'C' .ds hdrftr-pos-element CENTER
.       if '\\*[hdrftr-pos-element]'R' .ds hdrftr-pos-element RIGHT
.       if '\\*[ELEMENT]'HDRFTR_\\*[hdrftr-pos-element]_FAM' \
.          ds $HDRFTR_\\*[hdrftr-pos-element]_FAM \\$1
.    \}
.    rr hdrftr-pos-element
.    rm hdrftr-pos-element
.END
\#
.MAC ASSIGN_PARAM END
.    if '\\*[PARAM]'FAM'         .nr substr-index -7
.    if '\\*[PARAM]'FT'          .nr substr-index -5
.    if '\\*[PARAM]'SIZE_CHANGE' .nr substr-index -5
.    if '\\*[PARAM]'COLOR'       .nr substr-index -6
.    if '\\*[PARAM]'QUAD'        .nr substr-index -5
.    if '\\$1'BIB' \{\
.       ds ELEMENT \\*[FROM_ALIAS]
.       substring ELEMENT 12 \\n[substr-index]
.       if '\\*[ELEMENT]'_HEADER_' \
.          ds ELEMENT _STRING_
.    \}
.    if '\\$1'BQUOTE_' .rm ELEMENT
.    if '\\$1'EN' \{\
.       ds ELEMENT \\*[FROM_ALIAS]
.       substring ELEMENT 7 \\n[substr-index]
.       if '\\*[ELEMENT]'S_HEADER_' \
.          ds ELEMENT _STRING_
.       if '\\*[ELEMENT]'_LINENUMBER_' \
.          ds ELEMENT _LN_
.    \}
.    if '\\$1'EPI_' .rm ELEMENT
.    if '\\$1'FN_'  .rm ELEMENT
.    if '\\$1'HDRFTR_' \{\
.       if '\\*[ELEMENT]'HDRFTR_FAM' \{\
.          nr #HDRFTR 1
.          ds $HDRFTR_FAM        \\$2
.          ds $HDRFTR_LEFT_FAM   \\$2
.          ds $HDRFTR_CENTER_FAM \\$2
.          ds $HDRFTR_RIGHT_FAM  \\$2
.       \}
.       if '\\*[ELEMENT]'HDRFTR_COLOR' \{\
.          nr #HDRFTR 1
.          nr #HDRFTR_COLOR 1
.          ds $HDRFTR_COLOR \\$2
.       \}
.       if '\\*[ELEMENT]'HDRFTR_SIZE_CHANGE' \{\
.          nr #HDRFTR 1
.          ds $HDRFTR_SIZE_CHANGE \\$2
.       \}
.       if '\\*[PARAM]'SIZE_CHANGE' \{\
.          nr #HDRFTR 1
.          if '\\*[hdrftr-pos-element]'L' \
.             ds $HDRFTR_LEFT_SIZE_CHANGE \\$2
.          if '\\*[hdrftr-pos-element]'C' \
.             ds $HDRFTR_CENTER_SIZE_CHANGE \\$2
.          if '\\*[hdrftr-pos-element]'R' \
.             ds $HDRFTR_RIGHT_SIZE_CHANGE \\$2
.       \}
.       if !r #HDRFTR \{\
.          substring ELEMENT 7 \\n[substr-index]
.          if '\\*[ELEMENT]'_LEFT' .ds ELEMENT _STRING_
.       \}
.    \}
.    if '\\$1'LN_'       .rm ELEMENT
.    if '\\$1'PAGE_NUM_' .rm ELEMENT
.    if !r #HDRFTR \{\
.       ds $\\$1\\*[ELEMENT]\\*[PARAM] \\$2
.       nr #\\$1\\*[ELEMENT]\\*[PARAM] 1
.    \}
.    rr #HDRFTR
.    rm hdrftr-pos-element
.    rr substr-index
.    rm FROM_ALIAS
.    rm ELEMENT
.END
\#
.MAC TITLE_LEAD END
.    ds $TYPE \\$0
.    substring $TYPE 0 2
.    if '\\*[$TYPE]'DOC' .nr DOC_ 1
.    ds $TYPE \\$0
.    ie '\\*[$TYPE]'MISC_LEAD' .ds $TYPE COVER_MISC
.    el .substring $TYPE -6 0
.    ds $\\*[$TYPE]_LEAD \\$1
.    nr #\\*[$TYPE]_LEAD 1
.    rm $TYPE
.END
\#
\# The _STYLE macro, called by various aliases, allows grouping
\# style parameters for most document elements in a single macro
\# using 'KEYWORD value' pairs.
\#
.MAC _STYLE END
.    SILENT \" Some of the invoked macros cause unwanted breaks
.    ds $STYLE_TYPE \\$0
.    substring $STYLE_TYPE 0 -7
.    ds $HDR_FTR \\*[$STYLE_TYPE]
.    length #HDR_FTR_STRING $HDR_FTR
.    if \\n[#HDR_FTR_STRING]<=5 .substring $HDR_FTR 0 5 \" HEADER or FOOTER
.    if '\\*[$HDR_FTR]'HEADER' .ds $HDR_FTR HEADER
.    if '\\*[$HDR_FTR]'FOOTER' .ds $HDR_FTR FOOTER
.    ds $POS \\$0
.    substring $POS 7 7
.    if '\\*[$POS]'L' .ds $POS LEFT
.    if '\\*[$POS]'C' .ds $POS CENTER
.    if '\\*[$POS]'R' .ds $POS RIGHT
.    if '\\*[$STYLE_TYPE]'\\*[$HDR_FTR]_\\*[$POS]' \{\
.       ds $\\*[$HDR_FTR]_\\*[$POS] \\*[$HDR_FTR]_\\*[$POS]
.       ds $STYLE_TYPE HDRFTR_\\*[$POS]
.    \}
.    if '\\*[$STYLE_TYPE]'ENDNOTES_HEADER' \
.       ds $BIB-EN-TOC EN_STRING
.    if '\\*[$STYLE_TYPE]'ENDNOTE_STRING' \
.       ds $BIB-EN-TOC EN_STRING
.    if '\\*[$STYLE_TYPE]'BIBLIOGRAPHY_HEADER' \
.       ds $BIB-EN-TOC BIB_STRING
.    if '\\*[$STYLE_TYPE]'BIBLIOGRAPHY_STRING' \
.       ds $BIB-EN-TOC BIB_STRING
.    if '\\*[$STYLE_TYPE]'TOC_HEADER' \
.       ds $BIB-EN-TOC TOC_STRING
.    if '\\*[$STYLE_TYPE]'PAGENUMBER' \
.       ds $STYLE_TYPE PAGENUM
.    nr #LOOP 0 1
.    nr #STYLE_PARAMS \\n[#NUM_ARGS]
.    while \\n+[#LOOP]<=\\n[#STYLE_PARAMS] \{\ 
.       if '\\$1'FAMILY' \{\
.          shift
.          \\*[$STYLE_TYPE]_FAMILY \\$1
.          shift
.       \}
.       if '\\$1'FONT' \{\
.          shift
.          \\*[$STYLE_TYPE]_FONT \\$1
.          shift
.       \}
.       if '\\$1'SIZE' \{\
.          shift
.          \\*[$STYLE_TYPE]_SIZE \\$1
.          shift
.       \}
.       if '\\$1'COLOR' \{\
.          shift
.          \\*[$STYLE_TYPE]_COLOR \\$1
.          shift
.       \}
.       if '\\$1'CAPS' \{\
.          if \\n[#\\*[$STYLE_TYPE]_SMALLCAPS] \{\
.             tm1 \
"[mom]: '\\*[$STYLE_TYPE]_STYLE' contains CAPS and SMALLCAPS. \
CAPS takes precedence.
.             rr #\\*[$STYLE_TYPE]_SMALLCAPS
.          \}
.          \\*[$STYLE_TYPE]_CAPS
.          if d $\\*[$HDR_FTR]_LEFT   .HEADER_LEFT_CAPS
.          if d $\\*[$HDR_FTR]_CENTER .HEADER_CENTER_CAPS
.          if d $\\*[$HDR_FTR]_CENTRE .HEADER_CENTER_CAPS
.          if d $\\*[$HDR_FTR]_RIGHT  .HEADER_RIGHT_CAPS
.          shift
.       \}
.       if '\\$1'NO_CAPS' \{\
.          nr #\\*[$STYLE_TYPE]_CAPS 0
.          if !'\\*[$BIB-EN-TOC]'' \
.             rr #\\*[$BIB-EN-TOC]_CAPS
.          shift
.       \}
.       if '\\$1'SMALLCAPS' \{\
.          if \\n[#\\*[$STYLE_TYPE]_CAPS] \{\
.             tm1 \
"[mom]: '\\*[$STYLE_TYPE]_STYLE' contains CAPS and SMALLCAPS. \
SMALLCAPS takes precedence.
.             rr #\\*[$STYLE_TYPE]_CAPS
.          \}
.          \\*[$STYLE_TYPE]_SMALLCAPS
.          shift
.       \}
.       if '\\$1'NO_SMALLCAPS' \{\
.          rr #\\*[$STYLE_TYPE]_SMALLCAPS
.          if !'\\*[$BIB-EN-TOC]'' \
.             rr #\\*[$BIB-EN-TOC]_SMALLCAPS
.          shift
.       \}
.       if '\\$1'LEAD' \{\
.          shift
.          \\*[$STYLE_TYPE]_LEAD \\$1
.          shift
.       \}
.       if '\\$1'AUTOLEAD' \{\
.          shift
.          \\*[$STYLE_TYPE]_AUTOLEAD \\$1
.          shift
.       \}
.       if '\\$1'SPACE' \{\
.          shift
.          \\*[$STYLE_TYPE]_SPACE \\$1
.          shift
.       \}
.       if '\\$1'QUAD' \{\
.          shift
.          ie '\\*[$STYLE_TYPE]'QUOTE' \{\
.              ds $QUAD_TYPE \\$1
.              substring $QUAD_TYPE 0 0
.              if '\\*[$QUAD_TYPE]'L' .QUOTE_LEFT
.              if '\\*[$QUAD_TYPE]'C' .QUOTE_CENTER
.              if '\\*[$QUAD_TYPE]'R' .QUOTE_RIGHT
.          \}
.          el .\\*[$STYLE_TYPE]_QUAD \\$1
.          shift
.       \}
.       if '\\$1'INDENT' \{\
.          shift
.          \\*[$STYLE_TYPE]_INDENT \\$1
.          shift
.       \}
.\" UNDERLINE and UNDERSCORE are identical but we can't use : or &
.\" in string comparisons.
.       if '\\$1'UNDERLINE' \{\
.          shift
.          if '\\$1'DOUBLE' \{\
.             as ul-args \\$1 \"
.             shift
.          \}
.          nr #COUNT 0 1
.          while \\n+[#COUNT]<=3 \{\
.             if \B'\\$1' \{\
.                as ul-args \\$1 \"
.                shift
.             \}
.          \}
.          \\*[$STYLE_TYPE]_UNDERSCORE \\*[ul-args]
.       \}
.       if '\\$1'UNDERSCORE' \{\
.          shift
.          if '\\$1'DOUBLE' \{\
.             as ul-args \\$1 \"
.             shift
.          \}
.          nr #COUNT 0 1
.          while \\n+[#COUNT]<=3 \{\
.             if \B'\\$1' \{\
.                as ul-args \\$1 \"
.                shift
.             \}
.          \}
.          \\*[$STYLE_TYPE]_UNDERSCORE \\*[ul-args]
.       \}
.       if '\\$1'NO_UNDERSCORE' \{\
.          rr #\\*[$STYLE_TYPE]_UNDERLINE
.          if !'\\*[$BIB-EN-TOC]'' \
.             rr #\\*[$BIB-EN-TOC]_UNDERLINE
.          shift
.       \}
.       if '\\$1'NO_UNDERLINE' \{\
.          rr #\\*[$STYLE_TYPE]_UNDERLINE
.          if !'\\*[$BIB-EN-TOC]'' \
.             rr #\\*[$BIB-EN-TOC]_UNDERLINE
.          shift
.       \}
.       if '\\$1'V_ADJUST' \{\
.          shift
.          COPYRIGHT_V_ADJUST \\$1
.          shift
.       \}
.    \}
.    rm $STYLE_TYPE
.    rm $HDR_FTR
.    rm $POS
.    rm $HEADER_LEFT
.    rm $HEADER_CENTER
.    rm $HEADER_RIGHT
.    rm $BIB-EN-TOC
.    rm ul-args
.    SILENT off
.END
.
.ds STYLE_TYPE_1  ATTRIBUTE
.ds STYLE_TYPE_2  AUTHOR
.ds STYLE_TYPE_3  BIBLIOGRAPHY_HEADER
.ds STYLE_TYPE_4  BIBLIOGRAPHY_STRING
.ds STYLE_TYPE_5  BLOCKQUOTE
.ds STYLE_TYPE_6  CHAPTER
.ds STYLE_TYPE_7  CHAPTER_TITLE
.ds STYLE_TYPE_8  CODE
.ds STYLE_TYPE_9  COPYRIGHT
.ds STYLE_TYPE_10 COVER
.ds STYLE_TYPE_11 COVERTITLE
.ds STYLE_TYPE_12 DOC_COVERTITLE
.ds STYLE_TYPE_13 DOCHEADER
.ds STYLE_TYPE_14 DOCTITLE
.ds STYLE_TYPE_15 DOCTYPE
.ds STYLE_TYPE_16 ENDNOTE_TITLE
.ds STYLE_TYPE_17 ENDNOTES_HEADER
.ds STYLE_TYPE_18 ENDNOTE_STRING
.ds STYLE_TYPE_19 EPIGRAPH
.ds STYLE_TYPE_20 FINIS
.ds STYLE_TYPE_21 FOOTER_LEFT
.ds STYLE_TYPE_22 FOOTER_CENTER
.ds STYLE_TYPE_23 FOOTER_CENTRE
.ds STYLE_TYPE_24 FOOTER_RIGHT
.ds STYLE_TYPE_25 FOOTNOTE
.ds STYLE_TYPE_26 HEADER_LEFT
.ds STYLE_TYPE_27 HEADER_CENTER
.ds STYLE_TYPE_28 HEADER_CENTRE
.ds STYLE_TYPE_29 HEADER_RIGHT
.ds STYLE_TYPE_30 LEAD
.ds STYLE_TYPE_31 LINENUMBER
.ds STYLE_TYPE_32 MISC
.ds STYLE_TYPE_33 QUOTE
.ds STYLE_TYPE_34 PAGENUMBER
.ds STYLE_TYPE_35 SUBTITLE
.ds STYLE_TYPE_36 TITLE
.ds STYLE_TYPE_37 TOC_HEADER
.
.
.nr #LOOP 0 1
.while \n+[#LOOP]<=37 \{\
. ALIAS \*[STYLE_TYPE_\n[#LOOP]]_STYLE           _STYLE
. ALIAS COVER_\*[STYLE_TYPE_\n[#LOOP]]_STYLE     _STYLE
. ALIAS DOC_COVER_\*[STYLE_TYPE_\n[#LOOP]]_STYLE _STYLE
.\}
\#
\# UNDERLINE CONTROL
\# -----------------
\# *Arguments:
\#   [ DOUBLE ] [ <underline weight> [<underline gap>] ] | <none> | <anything>
\# *Function:
\#   Toggles underlining of the element indicated by the calling alias
\#   on or off.  Uses #<element>_UNDERLINE_WEIGHT to set the weight,
\#   and defines string $<element>_UNDERLINE_GAP.
\#
.MAC _UNDERLINE END
.    ds $GET_TITLE_TYPE \\$0
.    substring $GET_TITLE_TYPE -2
.    ie '\\*[$GET_TITLE_TYPE]'NE' \{\
.\" Called as _UNDERLINE
.        ds $GET_TITLE_TYPE \\$0
.        substring $GET_TITLE_TYPE 0 -10
.        ds $TITLE_TYPE \\*[$GET_TITLE_TYPE]
.    \}
.    el \{\
.\" Called as _UNDERSCORE
.        ds $GET_TITLE_TYPE \\$0
.        substring $GET_TITLE_TYPE 0 -11
.        ds $TITLE_TYPE \\*[$GET_TITLE_TYPE]
.    \}
.    ds $GET_TITLE_TYPE \\$0
.    substring $GET_TITLE_TYPE 0 2
.    if '\\*[$GET_TITLE_TYPE]'BIB' .ds $TITLE_TYPE BIB_STRING_
.    if '\\*[$GET_TITLE_TYPE]'SUB' .ds $TITLE_TYPE SUBTITLE_
.    ds $GET_TITLE_TYPE \\$0
.    substring $GET_TITLE_TYPE 0 7
.    if '\\*[$GET_TITLE_TYPE]'ENDNOTES' .ds $TITLE_TYPE EN_STRING_
.    ds $GET_TITLE_TYPE \\$0
.    substring $GET_TITLE_TYPE 0 10
.    if '\\*[$GET_TITLE_TYPE]'ENDNOTE_STR' .ds $TITLE_TYPE EN_STRING_
.    if '\\*[$GET_TITLE_TYPE]'ENDNOTE_TIT' .ds $TITLE_TYPE EN_TITLE_
.    ie '\\$1'' .nr #\\*[$TITLE_TYPE]UNDERLINE 1
.    el \{\
.       ie \\n[#NUM_ARGS]=1 \{\
.          ie \B'\\$1' \{\
.             if !\\n[#PRINT_STYLE]=1 \{\
.                \\*[$TITLE_TYPE]UNDERLINE_WEIGHT \\$1
.                nr #\\*[$TITLE_TYPE]UNDERLINE 1
.             \}
.          \}
.          el \{\
.             ie '\\$1'DOUBLE' .nr #\\*[$TITLE_TYPE]UNDERLINE 2
.             el .nr #\\*[$TITLE_TYPE]UNDERLINE 0
.          \}
.       \}
.       el \{\
.          if !\\n[#PRINT_STYLE]=1 \{\
.               nr #\\*[$TITLE_TYPE]UNDERLINE 1
.               if '\\$1'DOUBLE' \{\
.                  nr #\\*[$TITLE_TYPE]UNDERLINE 2
.                  shift
.               \}
.               \\*[$TITLE_TYPE]UNDERLINE_WEIGHT \\$1
.               if !'\\$2'' \
.                  ds $\\*[$TITLE_TYPE]UNDERLINE_GAP \\$2
.               if !'\\$3'' \
.                  ds $\\*[$TITLE_TYPE]RULE_GAP \\$3
.          \}
.       \}
.    \}
.    rm $TITLE_TYPE
.END
.
.ALIAS ENDNOTE_STRING_UNDERLINE _UNDERLINE
.ALIAS ENDNOTE_STRING_UNDERSCORE _UNDERLINE
\#
\# DEFAULTS
\# --------
\# *Arguments:
\#   <none>
\# *Function:
\#   Sets up defaults if no values are entered prior to START.
\# *Notes:
\#   The defaults for $CHAPTER_STRING, $DRAFT_STRING, and
\#   $REVISION_STRING are in the COPYSTYLE macro.
\#
.MAC DEFAULTS END
.    if !\\n[#DOC_TYPE]=5 \{\
.       ie !d $PAPER .PAPER LETTER
.       el .PAPER \\*[$PAPER]
.    \}
.    if !\\n[#DOC_TYPE] .DOCTYPE DEFAULT
.    if !r #CH_NUM .nr #CH_NUM 1 
.    ie \\n[#PAGENUM_STYLE_SET] .PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.    el \
.       if !\\n[#COPY_STYLE]=1 .PAGENUM_STYLE DIGIT
.    if !\\n[#COPY_STYLE] .COPYSTYLE FINAL
.    if \\n[#DRAFT_WITH_PAGENUM] .COPYSTYLE \\*[$COPY_STYLE]
.    if \\n[#DOC_TYPE]=4 \{\
.       if !\\n[#USER_SET_L_LENGTH] \{\
.          R_MARGIN \\n[#R_MARGIN]u
.          rr #USER_SET_L_LENGTH
.       \}
.       if \\n[#PRINT_STYLE]=1 .PRINTSTYLE TYPEWRITE SINGLESPACE
.    \}
.    if \\n[#COPY_STYLE]=1 \{\
.       COPYSTYLE DRAFT
.       PAGENUMBER 1
.    \}
.    if !r #DOC_HEADER .DOCHEADER
.    if !r #HEADERS_ON .HEADERS
.    if !r #PAGINATE   .PAGINATE
.\"
.    if !r #HEADER_MARGIN .HEADER_MARGIN 4P+6p
.    if !r #HEADER_GAP    .HEADER_GAP 3P
.\"
.    if \\n[#FOOTERS_ON] \{\
.       HEADERS OFF
.       ie \\n[#PAGINATE] \
.          if \\n[#PAGE_NUM_POS_SET]=0 .PAGENUM_POS TOP CENTER
.       el \
.          if !\\n[#T_MARGIN] .T_MARGIN 6P
.    \}
.    if !\\n[#HEADERS_ON] \{\
.       if !\\n[#FOOTERS_ON] \{\
.          ie \\n[#PAGE_NUM_V_POS]=1 \{\
.             HEADER_MARGIN \\n[#HEADER_MARGIN]
.             HEADER_GAP \\n[#HEADER_GAP]
.          \}
.          el .if !r #T_MARGIN .T_MARGIN 6P
.       \}
.    \}
.    if !r #T_MARGIN \
.       T_MARGIN \\n[#HEADER_MARGIN]+\\n[#HEADER_GAP]
.    if !r #DOCHEADER_ADVANCE \
.       nr #DOCHEADER_ADVANCE \\n[#T_MARGIN]
.    if !r #FOOTER_MARGIN .FOOTER_MARGIN 3P
.    if !r #FOOTER_GAP    .FOOTER_GAP 3P
.    if !r #B_MARGIN \
.       B_MARGIN \\n[#FOOTER_MARGIN]u+\\n[#FOOTER_GAP]u
.    if !\\n[#HEADER_RULE_GAP] .HEADER_RULE_GAP 4p
.    if !\\n[#FOOTER_RULE_GAP] .FOOTER_RULE_GAP 4p
.    if !r #HDRFTR_RULE     .HDRFTR_RULE
.    if !r #PAGE_NUM_SET    .PAGENUMBER 1
.\" Read in number registers and strings for type parameters
.    nr #DOC_L_MARGIN \\n[#L_MARGIN]
.    nr #DOC_L_LENGTH \\n[#L_LENGTH]
.    nr #DOC_R_MARGIN \\n[#PAGE_WIDTH]-(\\n[#DOC_L_MARGIN]+\\n[#L_LENGTH])
.    ie !'\\*[$SAVED_DOC_FAM]'' \{\
.       ds $DOC_FAM \\*[$SAVED_DOC_FAM]
.       rm $SAVED_DOC_FAM
.    \}
.    el .ds $DOC_FAM \\*[$FAMILY]
.    nr #DOC_PT_SIZE  \\n[#PT_SIZE]
.    if \\n[#TOC]          .nr #DOC_PT_SIZE \\n[#TOC_PS]
.    if \\n[#ENDNOTES]     .nr #DOC_PT_SIZE \\n[#EN_PS]
.    if \\n[#BIBLIOGRAPHY] .nr #DOC_PT_SIZE \\n[#BIB_PS]
.    if \
(\\n[#TOC]=0)&\
(\\n[#LIST_OF_FIGURES]=0)&\
(\\n[#LIST_OF_TABLES]=0)&\
(\\n[#LIST_OF_EQUATIONS]=0) \
.    nr #DOC_LEAD \\n[.v]
.    nr #DOC@LEAD \\n[#DOC_LEAD]
.    if \\n[#AUTO_LEAD] .nr #DOC_AUTOLEAD \\n[#AUTOLEAD_VALUE]
.\" #SAVED_DOC_LEAD is set in COLLATE
.    if \\n[#SAVED_DOC_LEAD] \{\
.       if \
(\\n[#TOC]=0)&\
(\\n[#LIST_OF_FIGURES]=0)&\
(\\n[#LIST_OF_TABLES]=0)&\
(\\n[#LIST_OF_EQUATIONS]=0) \{\
.          ie !\\n[#DOC_LEAD]=\\n[#SAVED_DOC_LEAD] .nr #RERUN_TRAPS 1
.          el .nr #SKIP_TRAPS 1
.       \}
.    \}
.    ie \\n[#ADJ_DOC_LEAD]=1 .
.    el \
.       if !\\n[#DOC_LEAD_ADJUST_OFF] .DOC_LEAD_ADJUST
.    ie d$RESTORE_DOC_QUAD \{\
.       ds $DOC_QUAD \\*[$RESTORE_DOC_QUAD]
.       rm $RESTORE_DOC_QUAD
.    \}
.    el .ds $DOC_QUAD \\*[$QUAD_VALUE]
.    if '\\*[$FONT]''   .FT R
.    if '\\*[$PP_FT]''  .ds $PP_FT \\*[$FONT]
.    FT \\*[$PP_FT]
.\" Counters
.    nr #PP                0
.    nr #FN_NUMBER         0 1
.    nr #EN_NUMBER         0 1
.    nr #FN_COUNT_FOR_COLS 0 1
.    nr #DONE_ONCE         0 1
.\" Enable shimming if user hasn't turned it off
.   if \\n[#NO_SHIM]=2 \{\
.      rr #NO_SHIM
.      nr #NO_FLEX 1
.   \}
.\" General style defaults for both PRINTSTYLEs
.    nr #PP_STYLE 1
.    PARA_INDENT \\n[#PP_INDENT]u
.    if !d $HDRFTR_FAM           .ds $HDRFTR_FAM \\*[$DOC_FAM]
.    if !d $HDRFTR_SIZE_CHANGE   .HDRFTR_SIZE +0
.    if !d $PAGE_NUM_FAM         .PAGENUM_FAMILY \\*[$DOC_FAM]
.    if !d $PAGE_NUM_FT          .PAGENUM_FONT R
.    if !d $PAGE_NUM_SIZE_CHANGE .PAGENUM_SIZE +0
.    if !r #PAGE_NUM_POS_SET     .PAGENUM_POS BOTTOM CENTER
.    ie \\n[#PAGE_NUM_HYPHENS_SET] \{\
.       if \\n[#PAGE_NUM_HYPHENS]=0 .PAGENUM_HYPHENS OFF
.       if \\n[#PAGE_NUM_HYPHENS]=1 .PAGENUM_HYPHENS
.    \}
.    el \
.       if !d$PAGENUM_STRING .PAGENUM_HYPHENS
.    if !d $FN_FAM     .FOOTNOTE_FAMILY \\*[$DOC_FAM]
.    if !d $FN_FT      .FOOTNOTE_FONT R
.    if !d $FN_QUAD    .FOOTNOTE_QUAD \\*[$DOC_QUAD]
.    if !r #FN_RULE    .FOOTNOTE_RULE
.    if !r #FN_MARKERS .FOOTNOTE_MARKERS
.    if \\n[#FN_MARKERS]=1 \{\
.       if \\n[#FN_REF]=1 \
.          if !\\n[#FN_MARKER_STYLE] .FOOTNOTE_MARKER_STYLE NUMBER
.       if !\\n[#FN_MARKER_STYLE] .FOOTNOTE_MARKER_STYLE STAR
.    \}
.    if !r #EN_MARKER_STYLE .ENDNOTE_MARKER_STYLE SUPERSCRIPT
.    if !d $EN_PN_STYLE     .ENDNOTES_PAGENUM_STYLE digit
.    if !d $EN_FAM          .ENDNOTE_FAMILY \\*[$DOC_FAM]
.    if !d $EN_FT           .ENDNOTE_FONT R
.    if !d $EN_QUAD \{\
.       ds quad-check \\*[$DOC_QUAD]
.       substring quad-check 0 0
.       if '\\*[$DOC_QUAD]'C' .nr quad-check 1
.       if '\\*[$DOC_QUAD]'R' .nr quad-check 1
.       ie \\n[quad-check] .ENDNOTE_QUAD J
.       el .ENDNOTE_QUAD \\*[$DOC_QUAD]
.       rr quad-check
.    \}
.    if !d $EN_STRING       .ENDNOTES_HEADER_STRING "Endnotes"
.    if !d $EN_STRING_FAM   .ENDNOTES_HEADER_FAMILY \\*[$EN_FAM]
.    if !d $EN_STRING_QUAD  .ENDNOTES_HEADER_QUAD CENTER
.    if !d $EN_TITLE \{\
.       ie \\n[#DOC_TYPE]=2 \{\
.          ie !'\\*[$CHAPTER_TITLE_1]'' \{\
.             ie '\\*[$CHAPTER]'' .ENDNOTE_TITLE "\\*[$CHAPTER_TITLE]"
.             el .ENDNOTE_TITLE \
"\\*[$CHAPTER_STRING] \\*[$CHAPTER]: \\*[$CHAPTER_TITLE]"
.          \}
.             el \{\
.                ie '\\*[$CHAPTER]'' .ENDNOTE_TITLE "\\*[$CHAPTER_STRING]"
.                el .ENDNOTE_TITLE "\\*[$CHAPTER_STRING] \\*[$CHAPTER]"
.             \}
.          \}
.       el .ENDNOTE_TITLE "\\*[$TITLE]"
.    \}
.    if !d $EN_TITLE_FAM  .ENDNOTE_TITLE_FAMILY \\*[$EN_FAM]
.    if !d $EN_TITLE_QUAD .ENDNOTE_TITLE_QUAD LEFT
.    if !d $EN_NUMBER_FAM .ENDNOTE_NUMBER_FAMILY \\*[$EN_FAM]
.    if !d $EN_LN_FAM     .ENDNOTE_LINENUMBER_FAMILY \\*[$EN_FAM]
.    if !r #EN_NUMBERS_ALIGN_LEFT \{\
.       if !r #EN_NUMBERS_ALIGN_RIGHT \{\
.          ie !\\n[#EN_MARKER_STYLE]=2 .ENDNOTE_NUMBERS_ALIGN RIGHT 2
.          el .ENDNOTE_NUMBERS_ALIGN RIGHT 4
.       \}
.    \}
.    if !r #EN_LN_GAP            .ENDNOTE_LINENUMBER_GAP 1m
.    if !r #EN_ALLOWS_HEADERS    .ENDNOTES_ALLOWS_HEADERS
.    if !d $BIB_PN_STYLE         .BIBLIOGRAPHY_PAGENUM_STYLE digit
.    if !d $BIB_FAM              .BIBLIOGRAPHY_FAMILY \\*[$DOC_FAM]
.    if !d $BIB_FT               .BIBLIOGRAPHY_FONT R
.    if !d $BIB_QUAD \{\
.       ds quad-check \\*[$DOC_QUAD]
.       substring quad-check 0 0
.       if '\\*[$DOC_QUAD]'C' .nr quad-check 1
.       if '\\*[$DOC_QUAD]'R' .nr quad-check 1
.       ie \\n[quad-check] .BIBLIOGRAPHY_QUAD J
.       el .BIBLIOGRAPHY_QUAD \\*[$DOC_QUAD]
.       rr quad-check
.    \}
.    if !d $BIB_STRING           .BIBLIOGRAPHY_STRING "Bibliography"
.    if !d $BIB_STRING_FAM       .BIBLIOGRAPHY_STRING_FAMILY \\*[$BIB_FAM]
.    if !d $BIB_STRING_QUAD      .BIBLIOGRAPHY_STRING_QUAD CENTER
.    if !d $TOC_HEADER_STRING    .TOC_HEADER_STRING "Contents"
.    if !d $TOC_HEADER_QUAD      .TOC_HEADER_QUAD LEFT
.    if !d $TOC_PN_STYLE         .TOC_PAGENUM_STYLE roman
.    if !r #TOC_PN_PADDING       .TOC_PADDING 3
.\" Line numbering
.    if !r #LN_GUTTER      .nr #LN_GUTTER 2
.    if !r #Q_LN_GUTTER    .nr #Q_LN_GUTTER 2
.    if !r #BQ_LN_GUTTER   .nr #BQ_LN_GUTTER 2
.    if !d $LN_FAM         .ds $LN_FAM \\*[$DOC_FAM]
.    if !d $LN_FT          .ds $LN_FT R
.    if !d $LN_SIZE_CHANGE .ds $LN_SIZE_CHANGE +0
.    if !d $LN_COLOR       .ds $LN_COLOR black
.\" PDF link colour
.    if !\\n[PDFHREF_COLOR_SET] .PDF_LINK_COLOR 0.0 0.3 0.9
.\" PDF frame
.    if !d pdf-img:frame-weight .ds pdf-img:frame-weight .5
.    if !d pdf-img:frame-color  .ds pdf-img:frame-color  black
.\" Captions, labels, sources
.\" All at default doc specs except leading, which is autolead 2
.   nr label-type-counter 0 1
.   while \\n+[label-type-counter]<=5 \{\
.      if \\n[label-type-counter]=1 .ds label-type eqn
.      if \\n[label-type-counter]=2 .ds label-type pdf-img
.      if \\n[label-type-counter]=3 .ds label-type pic
.      if \\n[label-type-counter]=4 .ds label-type tbl
.      if \\n[label-type-counter]=5 .ds label-type floating
.      nr spec-type-counter 0 1
.      while \\n+[spec-type-counter]<=3 \{\
.         if \\n[spec-type-counter]=1 .ds spec-type label
.         if \\n[spec-type-counter]=2 .ds spec-type caption
.         if \\n[spec-type-counter]=3 .ds spec-type source
.         set-defaults
.         set-inline-specs
.      \}
.      rm label-type
.      rm spec-type
.   \}
.\" String defaults for both PRINTSTYLEs
.    ie \\n[#DOC_TYPE]=1 \{\
.       ie '\\*[$DOCTITLE]'' \{\
.          if \\n[#USER_DEF_HDRFTR_LEFT]=0  .ds $HDRFTR_LEFT \\*[$AUTHOR_1]
.          if \\n[#USER_DEF_HDRFTR_RIGHT]=0 .ds $HDRFTR_RIGHT \\*[$TITLE]
.       \}
.       el \{\
.          if \\n[#COPY_STYLE]=1             .DRAFT_WITH_PAGENUMBER
.          if \\n[#USER_DEF_HDRFTR_LEFT]=0   .ds $HDRFTR_LEFT \\*[$AUTHOR_1]
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 .ds $HDRFTR_CENTER \\*[$TITLE]
.          if \\n[#USER_DEF_HDRFTR_RIGHT]=0  .ds $HDRFTR_RIGHT \\*[$DOCTITLE]
.       \}
.    \}
.    el \{\
.       if \\n[#USER_DEF_HDRFTR_LEFT]=0  .ds $HDRFTR_LEFT \\*[$AUTHOR_1]
.       if \\n[#USER_DEF_HDRFTR_RIGHT]=0 .ds $HDRFTR_RIGHT \\*[$TITLE]
.    \}
.    if !d $ATTRIBUTE_STRING  .ds $ATTRIBUTE_STRING by
.    if !d $FINIS_STRING      .FINIS_STRING "End"
.    if !r #FINIS_STRING_CAPS .nr #FINIS_STRING_CAPS 1
.\" Covers
.    if !r #DOC_COVERS_OFF           .nr #DOC_COVERS 1
.    if !r #COVERS_OFF               .nr #COVERS 1
.    if !d $COVER_COPYRIGHT_QUAD     .COVER_COPYRIGHT_QUAD R
.    if !d $COVER_MISC_QUAD          .COVER_MISC_QUAD L
.    if !d $MISC_QUAD                .MISC_QUAD L
.    if !d $DOC_COVER_COPYRIGHT_QUAD .DOC_COVER_COPYRIGHT_QUAD R
.    if !d $DOC_COVER_MISC_QUAD      .DOC_COVER_MISC_QUAD L
.\" Defaults for printstyle TYPEWRITE
.    if \\n[#PRINT_STYLE]=1 \{\
.       TYPEWRITER
.       SS DEFAULT
.       if \\n[#UNDERLINE_QUOTES]=1 .UNDERLINE_QUOTES
.       if \\n[#UNDERLINE_QUOTES]=0 .UNDERLINE_QUOTES OFF
.       if !\\n[#HDRFTR_PLAIN] \{\
.          if !r #HDRFTR_RIGHT_CAPS .nr #HDRFTR_RIGHT_CAPS 1
.          if \\n[#HDRFTR_RIGHT_CAPS]=0 \
.             if !d $HDRFTR_RIGHT_SIZE_CHANGE .HDRFTR_RIGHT_SIZE +0
.       \}
.\" +Doctype underlining (if NAMED)
.       if !r #DOCTYPE_UNDERLINE .nr #DOCTYPE_UNDERLINE 1
.\" +Quotes and blockquotes
.       if !r #Q_OFFSET_VALUE \
.          if '\\*[$Q_OFFSET_VALUE]'' \
.             QUOTE_INDENT \\n[#PP_INDENT]u+(\\n[#PP_INDENT]u/2u)
.       if !d $Q_QUAD .QUOTE_LEFT
.       if !d $BQUOTE_QUAD        .BLOCKQUOTE_QUAD LEFT
.       if !r #BQ_OFFSET_VALUE \
.          if '\\*[$BQ_OFFSET_VALUE]'' \
.             BLOCKQUOTE_INDENT \\n[#PP_INDENT]u+(\\n[#PP_INDENT]u/2u)
.\" +Epigraphs
.       if !r #EPI_OFFSET_VALUE \
.          if '\\*[$EPI_OFFSET_VALUE]'' .EPIGRAPH_INDENT 2
.\" +Linebreaks
.       if !d $LINEBREAK_CHAR .LINEBREAK_CHAR * 3 2p
.\" +Footnotes
.       if !d $FN_SIZE_CHANGE .FOOTNOTE_SIZE +0
.       if !r #FN_RULE_LENGTH .FOOTNOTE_RULE_LENGTH 2i
.\" +Endnotes
.       if !r #EN_PP_INDENT .ENDNOTE_PARA_INDENT \\n[#PP_INDENT]
.       if !r #EN_STRING_CAPS .ENDNOTES_HEADER_CAPS
.       if !r #EN_STRING_UNDERLINE .nr #EN_STRING_UNDERLINE 2
.\" +Footnotes
.       if !r #FN_RULE_ADJ .FOOTNOTE_RULE_ADJ 6p
.\" +Slant stuff
.       if !r #SLANT_MEANS_SLANT \{\
.          ie \\n[#UNDERLINE_SLANT]=1 .UNDERLINE_SLANT
.          el .UNDERLINE_SLANT OFF
.       \}
.\" +Bibliography
.       if !r #BIB_STRING_UNDERLINE .nr #BIB_STRING_UNDERLINE 2
.       if !r #BIB_STRING_CAPS .BIBLIOGRAPHY_STRING_CAPS
.    \}
.\" Defaults for printstyle TYPESET
.    if \\n[#PRINT_STYLE]=2 \{\
.       if !d $DOCHEADER_LEAD_ADJ .DOCHEADER_LEAD +0
.\" +Cover
.       if !d $COVER_LEAD_ADJ .COVER_LEAD +0
.       if !d $COVER_FAM      .COVER_FAMILY \\*[$DOC_FAM]
.\" (title)
.       if !d $COVER_TITLE_FAM \{\
.          ie !d $COVER_FAM .COVER_TITLE_FAMILY \\*[$DOC_FAM]
.          el .COVER_TITLE_FAMILY \\*[$COVER_FAM]
.       \}
.       if !d $COVER_TITLE_FT .COVER_TITLE_FONT B
.       if !d $COVER_TITLE_SIZE_CHANGE .COVER_TITLE_SIZE +3.5
.\" (doctitle)
.       if !d $COVER_DOCTITLE_FAM \{\
.          ie !d $DOC_COVER_FAM .COVER_DOCTITLE_FAMILY \\*[$DOC_FAM]
.          el .COVER_DOCTITLE_FAMILY \\*[$COVER_FAM]
.       \}
.       if !d $COVER_DOCTITLE_FT          .COVER_DOCTITLE_FONT B
.       if !d $COVER_DOCTITLE_SIZE_CHANGE .COVER_DOCTITLE_SIZE +3.5
.\" (covertitle)
.       if !d $COVER_COVERTITLE_FAM \{\
.          ie !d $COVER_FAM .COVER_COVERTITLE_FAMILY \\*[$DOC_FAM]
.          el .COVER_COVERTITLE_FAMILY \\*[$COVER_FAM]
.       \}
.       if !d $COVER_COVERTITLE_FT .COVER_COVERTITLE_FONT B
.       if !d $COVER_COVERTITLE_SIZE_CHANGE .COVER_COVERTITLE_SIZE +3.5
.\" (doc_covertitle)
.       if !d $COVER_DOC_COVERTITLE_FAM \{\
.          ie !d $COVER_FAM .COVER_DOC_COVERTITLE_FAMILY \\*[$DOC_FAM]
.          el .COVER_DOC_COVERTITLE_FAMILY \\*[$COVER_FAM]
.       \}
.       if !d $COVER_DOC_COVERTITLE_FT .COVER_DOC_COVERTITLE_FONT B
.       if !d $COVER_DOC_COVERTITLE_SIZE_CHANGE .COVER_DOC_COVERTITLE_SIZE +3.5
.\" (chapter)
.       if !d $COVER_CHAPTER_FAM \{\
.          ie !d $COVER_FAM .COVER_CHAPTER_FAMILY \\*[$DOC_FAM]
.          el .COVER_CHAPTER_FAMILY \\*[$COVER_FAM]
.       \}
.       if !d $COVER_CHAPTER_FT .COVER_CHAPTER_FONT B
.       if !d $COVER_CHAPTER_SIZE_CHANGE .COVER_CHAPTER_SIZE +3.5
.\" (chapter title)
.       if !d $COVER_CHAPTER_TITLE_FAM \{\
.          ie !d $COVER_FAM .COVER_CHAPTER_TITLE_FAMILY \\*[$DOC_FAM]
.          el .COVER_CHAPTER_TITLE_FAMILY \\*[$COVER_FAM]
.       \}
.       if !d $COVER_CHAPTER_TITLE_FT .COVER_CHAPTER_TITLE_FONT BI
.       if !d $COVER_CHAPTER_TITLE_SIZE_CHANGE .COVER_CHAPTER_TITLE_SIZE +4
.\" (subtitle)
.       if !d $COVER_SUBTITLE_FAM \{\
.          ie !d $COVER_FAM .COVER_SUBTITLE_FAMILY \\*[$DOC_FAM]
.          el .COVER_SUBTITLE_FAMILY \\*[$COVER_FAM]
.       \}
.       if !d $COVER_SUBTITLE_FT .COVER_SUBTITLE_FONT R
.       if !d $COVER_SUBTITLE_SIZE_CHANGE .COVER_SUBTITLE_SIZE +0
.\" (attribution and author[s])
.       if !d $COVER_ATTRIBUTE_FAM \{\
.          ie !d $COVER_FAM .COVER_ATTRIBUTE_FAMILY \\*[$DOC_FAM]
.          el .COVER_ATTRIBUTE_FAMILY \\*[$COVER_FAM]
.       \}
.       if !d $COVER_ATTRIBUTE_FT .COVER_ATTRIBUTE_FONT I
.       if !d $COVER_ATTRIBUTE_SIZE_CHANGE .COVER_ATTRIBUTE_SIZE +0
.       if !d $COVER_AUTHOR_FAM \{\
.          ie !d $COVER_FAM .COVER_AUTHOR_FAMILY \\*[$DOC_FAM]
.          el .COVER_AUTHOR_FAMILY \\*[$COVER_FAM]
.       \}
.       if !d $COVER_AUTHOR_FT .COVER_AUTHOR_FONT I
.       if !d $COVER_AUTHOR_SIZE_CHANGE .COVER_AUTHOR_SIZE +0
.\" (doctype if "named")
.       if !d $COVER_DOCTYPE_FAM \{\
.          ie !d $COVER_FAM .COVER_DOCTYPE_FAMILY \\*[$DOC_FAM]
.          el .COVER_DOCTYPE_FAMILY \\*[$COVER_FAM]
.       \}
.       if !d $COVER_DOCTYPE_FT .COVER_DOCTYPE_FONT BI
.       if !d $COVER_DOCTYPE_SIZE_CHANGE .COVER_DOCTYPE_SIZE +3
.\" (copyright)
.       if !d $COVER_COPYRIGHT_FAM \{\
.          ie !d $COVER_FAM .COVER_COPYRIGHT_FAMILY \\*[$DOC_FAM]
.          el .COVER_COPYRIGHT_FAMILY \\*[$COVER_FAM]
.       \}
.       if !d $COVER_COPYRIGHT_FT .COVER_COPYRIGHT_FONT R
.       if !d $COVER_COPYRIGHT_SIZE_CHANGE .COVER_COPYRIGHT_SIZE -2
.\" (misc)
.       if !d $COVER_MISC_FAM         .COVER_MISC_FAMILY \\*[$DOC_FAM]
.       if !d $COVER_MISC_FT          .COVER_MISC_FONT R
.       if !d $COVER_MISC_SIZE_CHANGE .COVER_MISC_SIZE -2
.       if !r #COVER_MISC_LEAD        .COVER_MISC_LEAD 14.5
.\" +Doc cover
.       if !d $DOC_COVER_LEAD_ADJ .DOC_COVER_LEAD +0
.       if !d $DOC_COVER_FAM      .DOC_COVER_FAMILY \\*[$DOC_FAM]
.\" (title)
.       if !d $DOC_COVER_TITLE_FAM \{\
.          ie !d $DOC_COVER_FAM .DOC_COVER_TITLE_FAMILY \\*[$DOC_FAM]
.          el .DOC_COVER_TITLE_FAMILY \\*[$DOC_COVER_FAM]
.       \}
.       if !d $DOC_COVER_TITLE_FT          .DOC_COVER_TITLE_FONT B
.       if !d $DOC_COVER_TITLE_SIZE_CHANGE .DOC_COVER_TITLE_SIZE +3.5
.\" (doctitle)
.       if !d $DOC_COVER_DOCTITLE_FAM \{\
.          ie !d $DOC_COVER_FAM .DOC_COVER_DOCTITLE_FAMILY \\*[$DOC_FAM]
.          el .DOC_COVER_DOCTITLE_FAMILY \\*[$DOC_COVER_FAM]
.       \}
.       if !d $DOC_COVER_DOCTITLE_FT          .DOC_COVER_DOCTITLE_FONT B
.       if !d $DOC_COVER_DOCTITLE_SIZE_CHANGE .DOC_COVER_DOCTITLE_SIZE +3.5
.\" (covertitle)
.       if !d $DOC_COVER_COVERTITLE_FAM \{\
.          ie !d $COVER_FAM .DOC_COVER_COVERTITLE_FAMILY \\*[$DOC_FAM]
.          el .DOC_COVER_COVERTITLE_FAMILY \\*[$COVER_FAM]
.       \}
.       if !d $DOC_COVER_COVERTITLE_FT .DOC_COVER_COVERTITLE_FONT B
.       if !d $DOC_COVER_COVERTITLE_SIZE_CHANGE .DOC_COVER_COVERTITLE_SIZE +3.5
.\" (doc_covertitle)
.       if !d $DOC_COVER_DOC_COVERTITLE_FAM \{\
.          ie !d $COVER_FAM .DOC_COVER_DOC_COVERTITLE_FAMILY \\*[$DOC_FAM]
.          el .DOC_COVER_DOC_COVERTITLE_FAMILY \\*[$COVER_FAM]
.       \}
.       if !d $DOC_COVER_DOC_COVERTITLE_FT .DOC_COVER_DOC_COVERTITLE_FONT B
.       if !d $DOC_COVER_DOC_COVERTITLE_SIZE_CHANGE .DOC_COVER_DOC_COVERTITLE_SIZE +3.5
.\" (chapter)
.       if !d $DOC_COVER_CHAPTER_FAM \{\
.          ie !d $DOC_COVER_FAM .DOC_COVER_CHAPTER_FAMILY \\*[$DOC_FAM]
.          el .DOC_COVER_CHAPTER_FAMILY \\*[$DOC_COVER_FAM]
.       \}
.       if !d $DOC_COVER_CHAPTER_FT          .DOC_COVER_CHAPTER_FONT B
.       if !d $DOC_COVER_CHAPTER_SIZE_CHANGE .DOC_COVER_CHAPTER_SIZE +3.5
.\" (chapter title)
.       if !d $DOC_COVER_CHAPTER_TITLE_FAM \{\
.          ie !d $DOC_COVER_FAM .DOC_COVER_CHAPTER_TITLE_FAMILY \\*[$DOC_FAM]
.          el .DOC_COVER_CHAPTER_TITLE_FAMILY \\*[$DOC_COVER_FAM]
.       \}
.       if !d $DOC_COVER_CHAPTER_TITLE_FT .DOC_COVER_CHAPTER_TITLE_FONT BI
.       if !d $DOC_COVER_CHAPTER_TITLE_SIZE_CHANGE .DOC_COVER_CHAPTER_TITLE_SIZE +4
.\" (subtitle)
.       if !d $DOC_COVER_SUBTITLE_FAM \{\
.          ie !d $DOC_COVER_FAM .DOC_COVER_SUBTITLE_FAMILY \\*[$DOC_FAM]
.          el .DOC_COVER_SUBTITLE_FAMILY \\*[$DOC_COVER_FAM]
.       \}
.       if !d $DOC_COVER_SUBTITLE_FT .DOC_COVER_SUBTITLE_FONT R
.       if !d $DOC_COVER_SUBTITLE_SIZE_CHANGE .DOC_COVER_SUBTITLE_SIZE +0
.\" (attribution and author[s])
.       if !d $DOC_COVER_ATTRIBUTE_FAM \{\
.          ie !d $DOC_COVER_FAM .DOC_COVER_ATTRIBUTE_FAMILY \\*[$DOC_FAM]
.          el .DOC_COVER_ATTRIBUTE_FAMILY \\*[$DOC_COVER_FAM]
.       \}
.       if !d $DOC_COVER_ATTRIBUTE_FT .DOC_COVER_ATTRIBUTE_FONT I
.       if !d $DOC_COVER_ATTRIBUTE_SIZE_CHANGE .DOC_COVER_ATTRIBUTE_SIZE +0
.       if !d $DOC_COVER_AUTHOR_FAM \{\
.          ie !d $DOC_COVER_FAM .DOC_COVER_AUTHOR_FAMILY \\*[$DOC_FAM]
.          el .DOC_COVER_AUTHOR_FAMILY \\*[$DOC_COVER_FAM]
.       \}
.       if !d $DOC_COVER_AUTHOR_FT .DOC_COVER_AUTHOR_FONT I
.       if !d $DOC_COVER_AUTHOR_SIZE_CHANGE .DOC_COVER_AUTHOR_SIZE +0
.\" (doctype if "named")
.       if !d $DOC_COVER_DOCTYPE_FAM \{\
.          ie !d $DOC_COVER_FAM .DOC_COVER_DOCTYPE_FAMILY \\*[$DOC_FAM]
.          el .DOC_COVER_DOCTYPE_FAMILY \\*[$DOC_COVER_FAM]
.       \}
.       if !d $DOC_COVER_DOCTYPE_FT .DOC_COVER_DOCTYPE_FONT BI
.       if !d $DOC_COVER_DOCTYPE_SIZE_CHANGE .DOC_COVER_DOCTYPE_SIZE +3
.\" (copyright)
.       if !d $DOC_COVER_COPYRIGHT_FAM \{\
.          ie !d $DOC_COVER_FAM .DOC_COVER_COPYRIGHT_FAMILY \\*[$DOC_FAM]
.          el .DOC_COVER_COPYRIGHT_FAMILY \\*[$DOC_COVER_FAM]
.       \}
.       if !d $DOC_COVER_COPYRIGHT_FT .DOC_COVER_COPYRIGHT_FONT R
.       if !d $DOC_COVER_COPYRIGHT_SIZE_CHANGE .DOC_COVER_COPYRIGHT_SIZE -2
.\" (misc)
.       if !d $DOC_COVER_MISC_FAM         .DOC_COVER_MISC_FAMILY \\*[$DOC_FAM]
.       if !d $DOC_COVER_MISC_FT          .DOC_COVER_MISC_FONT R
.       if !d $DOC_COVER_MISC_SIZE_CHANGE .DOC_COVER_MISC_SIZE -2
.       if !r #DOC_COVER_MISC_LEAD        .DOC_COVER_MISC_LEAD 14.5
.\" +Docheader
.       if !d $DOCHEADER_FAM .DOCHEADER_FAMILY \\*[$DOC_FAM]
.       if !d $TITLE_FAM \{\
.          ie !d $DOCHEADER_FAM .TITLE_FAMILY \\*[$DOC_FAM]
.          el .TITLE_FAMILY \\*[$DOCHEADER_FAM]
.       \}
.       if !d $TITLE_FT .TITLE_FONT B
.\" Title size change
.       if !d $TITLE_SIZE_CHANGE \{\
.          ie \\n[#DOC_TYPE]=2 .TITLE_SIZE +4
.          el .TITLE_SIZE +3.5
.       \}
.       if !d $CHAPTER_FAM \{\
.          ie !d $DOCHEADER_FAM .CHAPTER_FAMILY \\*[$DOC_FAM]
.          el .CHAPTER_FAMILY \\*[$DOCHEADER_FAM]
.       \}
.       if !d $CHAPTER_FT .CHAPTER_FONT B
.       if !d $CHAPTER_SIZE_CHANGE .CHAPTER_SIZE +4
.       if !d $CHAPTER_TITLE_FAM \{\
.          ie !d $DOCHEADER_FAM .CHAPTER_TITLE_FAMILY \\*[$DOC_FAM]
.          el .CHAPTER_TITLE_FAMILY \\*[$DOCHEADER_FAM]
.       \}
.       if !d $CHAPTER_TITLE_FT          .CHAPTER_TITLE_FONT BI
.       if !d $CHAPTER_TITLE_SIZE_CHANGE .CHAPTER_TITLE_SIZE +4
.       if !d $SUBTITLE_FAM \{\
.          ie !d $DOCHEADER_FAM .SUBTITLE_FAMILY \\*[$DOC_FAM]
.          el .SUBTITLE_FAMILY \\*[$DOCHEADER_FAM]
.       \}
.       if !d $SUBTITLE_FT          .SUBTITLE_FONT R
.       if !d $SUBTITLE_SIZE_CHANGE .SUBTITLE_SIZE +0
.       if !d $ATTRIBUTE_FAM \{\
.          ie !d $DOCHEADER_FAM .ATTRIBUTE_FAMILY \\*[$DOC_FAM]
.          el .ATTRIBUTE_FAMILY \\*[$DOCHEADER_FAM]
.       \}
.       if !d $ATTRIBUTE_FT          .ATTRIBUTE_FONT I
.       if !d $ATTRIBUTE_SIZE_CHANGE .ATTRIBUTE_SIZE +0
.       if !d $AUTHOR_FAM \{\
.          ie !d $DOCHEADER_FAM .AUTHOR_FAMILY \\*[$DOC_FAM]
.          el .AUTHOR_FAMILY \\*[$DOCHEADER_FAM]
.       \}
.       if !d $AUTHOR_FT          .AUTHOR_FONT I
.       if !d $AUTHOR_SIZE_CHANGE .AUTHOR_SIZE +0
.       if !d $DOCTYPE_FAM \{\
.          ie !d $DOCHEADER_FAM .DOCTYPE_FAMILY \\*[$DOC_FAM]
.          el .DOCTYPE_FAMILY \\*[$DOCHEADER_FAM]
.       \}
.       if !d $DOCTYPE_FT          .DOCTYPE_FONT BI
.       if !d $DOCTYPE_SIZE_CHANGE .DOCTYPE_SIZE +3
.\" +Headers and footers
.       if !\\n[#HDRFTR_PLAIN] \{\
.          if !d $HDRFTR_LEFT_FAM \
.             HDRFTR_LEFT_FAMILY \\*[$DOC_FAM]
.          if !d $HDRFTR_LEFT_FT \
.              HDRFTR_LEFT_FONT R
.          if \\n[#HDRFTR_LEFT_CAPS] \
.             if !d $HDRFTR_LEFT_SIZE_CHANGE \
.                HDRFTR_LEFT_SIZE -2
.          if !d $HDRFTR_LEFT_SIZE_CHANGE \
.              HDRFTR_LEFT_SIZE -.5
.          if !d $HDRFTR_CENTER_FAM \
.              HDRFTR_CENTER_FAMILY \\*[$DOC_FAM]
.          if !d $HDRFTR_CENTER_FT .HDRFTR_CENTER_FONT I
.          if \\n[#HDRFTR_CENTER_CAPS] \
.             if !d $HDRFTR_CENTER_SIZE_CHANGE \
.                HDRFTR_CENTER_SIZE -2
.          if !d $HDRFTR_CENTER_SIZE_CHANGE \
.              HDRFTR_CENTER_SIZE -.5
.          if !d $HDRFTR_RIGHT_FAM \
.             HDRFTR_RIGHT_FAMILY \\*[$DOC_FAM]
.          if !d $HDRFTR_RIGHT_FT .HDRFTR_RIGHT_FONT R
.          ie !r #HDRFTR_RIGHT_CAPS \{\
.             nr #HDRFTR_RIGHT_CAPS 1
.             if !d $HDRFTR_RIGHT_SIZE_CHANGE \
.                HDRFTR_RIGHT_SIZE -2
.          \}
.          el \{\
.             if \\n[#HDRFTR_RIGHT_CAPS]=0 \
.                if !d $HDRFTR_RIGHT_SIZE_CHANGE \
.                   HDRFTR_RIGHT_SIZE -.5
.          \}
.          ie !\\n[#HDRFTR_RIGHT_SMALLCAPS] \{\
.             if \\n[#HDRFTR_RIGHT_CAPS] \
.                if !d $HDRFTR_RIGHT_SIZE_CHANGE \
.                   HDRFTR_RIGHT_SIZE -2
.          \}
.          el \{\
.             nr #SKIP_CAPS_SMALLCAPS_WARNING 1
.             if \\n[#HDRFTR_RIGHT_CAPS] .HDRFTR_RIGHT_CAPS OFF
.          \}
.          if !d $HDRFTR_RIGHT_SIZE_CHANGE .HDRFTR_RIGHT_SIZE -.5
.       \}
.\" +Quotes
.       if !d $QUOTE_FAM         .QUOTE_FAMILY \\*[$DOC_FAM]
.       if !d $QUOTE_FT          .QUOTE_FONT I
.       if !d $QUOTE_SIZE_CHANGE .QUOTE_SIZE +0
.       if !r #Q_OFFSET_VALUE \
.          if '\\*[$Q_OFFSET_VALUE]'' .QUOTE_INDENT 3
.       if !d $Q_QUAD .QUOTE_LEFT
.\" +Blockquotes
.\"  Note: the leading for quotes and blockquotes is set after .DEFAULTS in START
.       if !d $BQUOTE_FAM         .BLOCKQUOTE_FAMILY \\*[$DOC_FAM]
.       if !d $BQUOTE_FT          .BLOCKQUOTE_FONT R
.       if !d $BQUOTE_SIZE_CHANGE .BLOCKQUOTE_SIZE -1
.       if !d $BQUOTE_QUAD        .BLOCKQUOTE_QUAD LEFT
.       if !r #BQ_OFFSET_VALUE \
.          if '\\*[$BQ_OFFSET_VALUE]'' .BLOCKQUOTE_INDENT 3
.\" +Epigraphs
.       if !d $EPI_FAM         .EPIGRAPH_FAMILY \\*[$DOC_FAM]
.       if !d $EPI_FT          .EPIGRAPH_FONT R
.       if !d $EPI_SIZE_CHANGE .EPIGRAPH_SIZE -1.5
.       if !r #EPI_AUTOLEAD    .EPIGRAPH_AUTOLEAD 2
.       if !d $EPI_QUAD        .EPIGRAPH_QUAD \\*[$DOC_QUAD]
.       if !r #EPI_OFFSET_VALUE \
.          if '\\*[$EPI_OFFSET_VALUE]'' .EPIGRAPH_INDENT 3
.\" +Linebreaks
.       if !d $LINEBREAK_CHAR  .LINEBREAK_CHAR * 3 3p
.       if !d $LINEBREAK_COLOR .LINEBREAK_COLOR black
.\" +Footnotes
.       if !r #FN_RULE_LENGTH .FOOTNOTE_RULE_LENGTH 4P
.       if !r #FN_RULE_ADJ    .FOOTNOTE_RULE_ADJ 3p
.       if !d $FN_SIZE_CHANGE .FOOTNOTE_SIZE -2
.       if !r #FN_AUTOLEAD    .FOOTNOTE_AUTOLEAD 2
.\" +Endnotes
.       if !r #EN_PS                 .ENDNOTE_PT_SIZE (\\n[#DOC_PT_SIZE]u)
.       if !d $EN_STRING_FT          .ENDNOTES_HEADER_FONT B
.       if !d $EN_STRING_SIZE_CHANGE .ENDNOTES_HEADER_SIZE +3.5
.       if !d $EN_TITLE_FT           .ENDNOTE_TITLE_FONT B
.       if !d $EN_TITLE_SIZE_CHANGE  .ENDNOTE_TITLE_SIZE +0
.       if !d $EN_NUMBER_FT          .ENDNOTE_NUMBER_FONT B
.       if !d $EN_LN_FT              .ENDNOTE_LINENUMBER_FONT R
.       if !d $EN_NUMBER_SIZE_CHANGE .ENDNOTE_NUMBER_SIZE +0
.       if !d $EN_LN_SIZE_CHANGE     .ENDNOTE_LINENUMBER_SIZE +0
.       if !r #EN_PP_INDENT          .ENDNOTE_PARA_INDENT 1.5m
.       if !d $EN_SPACE              .ENDNOTE_SPACING 0
.\" +Bibliography
.       if !r #BIB_LIST               .BIBLIOGRAPHY_TYPE PLAIN
.       if !r #BIB_PS                 .BIBLIOGRAPHY_PT_SIZE (\\n[#DOC_PT_SIZE]u)
.       if !d $BIB_STRING_FT          .BIBLIOGRAPHY_STRING_FONT B
.       if !d $BIB_STRING_SIZE_CHANGE .BIBLIOGRAPHY_STRING_SIZE +3.5
.\" +Table of contents
.       if !d $TOC_FAM                .TOC_FAMILY \\*[$DOC_FAM]
.       if !r #TOC_PS                 .TOC_PT_SIZE (\\n[#DOC_PT_SIZE]u)
.       if '\\*[$TOC_LEAD]''          .TOC_LEAD \\n[#DOC@LEAD]u ADJUST
.       if !d $TOC_HEADER_FAM         .TOC_HEADER_FAMILY \\*[$TOC_FAM]
.       if !d $TOC_HEADER_SIZE_CHANGE .TOC_HEADER_SIZE +3.5
.       if !d $TOC_HEADER_FT          .TOC_HEADER_FONT B
.       if !d $TOC_PN_FAM             .TOC_PN_FAMILY \\*[$TOC_FAM]
.       if !d $TOC_PN_FT              .TOC_PN_FONT R
.       if !d $TOC_PN_SIZE_CHANGE     .TOC_PN_SIZE +0
.       if !d $TOC_TITLE_FAM          .TOC_TITLE_FAMILY \\*[$TOC_FAM]
.    \}
.\" +Refer support
.    if !r #EN_REF .nr #FN_REF 1
.    if !d $REF_FN_INDENT \{\
.       if \\n[#PRINT_STYLE]=1 .INDENT_REFS FOOTNOTE .5i
.       if \\n[#PRINT_STYLE]=2 .INDENT_REFS FOOTNOTE 2m
.    \}
.    if !d $REF_EN_INDENT \{\
.       if \\n[#PRINT_STYLE]=1 .INDENT_REFS ENDNOTE .5i
.       if \\n[#PRINT_STYLE]=2 .INDENT_REFS ENDNOTE 2m
.    \}
.    if !d $REF_BIB_INDENT \{\
.       if \\n[#PRINT_STYLE]=1 .INDENT_REFS BIBLIO .5i
.       if \\n[#PRINT_STYLE]=2 .INDENT_REFS BIBLIO 2m
.    \}
.\" Define strings for idem entries
.    if \\n[#PRINT_STYLE]=1 .char \[idem] \[hy]\[hy]\[hy]
.    if \\n[#PRINT_STYLE]=2 .char \[idem] \v'-.3m'\l'3m'\v'.3m'
.\" Adjust doc leading for PRINTSTYLE TYPESET
.    if \\n[#PRINT_STYLE]=2 \
.       if \\n[#ADJ_DOC_LEAD]=1 .DOC_LEAD_ADJUST
.\" This diversion is to get a value for #FN_AUTOLEAD
.    di NULL
.       if \\n[#AUTO_LEAD] \{\
.          nr #RESTORE_AUTO_LEAD 1
.          nr #SAVED_AUTOLEAD_VALUE \\n[#AUTOLEAD_VALUE]
.       \}
.       ev NULL
.       if \\n[#PRINT_STYLE]=1 \{\
.          ps \\*[$TYPEWRITER_PS]
.          ie \\n[#SINGLE_SPACE]=1 .vs \\n[#ORIGINAL_DOC_LEAD]u
.          el .vs \\n[#ORIGINAL_DOC_LEAD]u/2u
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          ps  \\n[#DOC_PT_SIZE]u\\*[$FN_SIZE_CHANGE]
.          vs \\n[.ps]u+\\n[#FN_AUTOLEAD]u
.       \}
.       nr #FN_LEAD \\n[#LEAD]
.       ev
.    di
.    if \\n[#RESTORE_AUTO_LEAD] \{\
.       nr #AUTO_LEAD 1
.       nr #AUTOLEAD_VALUE  \\n[#SAVED_AUTOLEAD_VALUE]
.    \}
.    if !\\n[#SKIP_TRAPS] .TRAPS
.    rr #SKIP_TRAPS
.    if \\n[#REMOVE_ADJ] .DOC_LEAD \\n[#DOC_LEAD]u-\\n[#DOC_LEAD_ADJ]u
.    if (\\n[#FOOTER_MARGIN]+\\n[.v]>=\\n[#B_MARGIN]) \{\
.       tm1 "[mom]: Your chosen bottom margin for running text is too close to the footer margin.
.       tm1 "       No footers or bottom-of-page page numbers will be printed.
.       tm1 "       Please reset B_MARGIN or FOOTER_MARGIN to allow enough space.
.       tm1 "       If no footers or bottom-of-page page numbers are required,
.       tm1 "       invoke .FOOTER_MARGIN 0 before .START
.       nr #SKIP_FOOTER 1
.    \}
.\" Endnote, bibliography and toc leading
.    nr #OK_PROCESS_LEAD 1
.    nr #RESTORE_DOC_LEAD \\n[.v]
.    nr #RESTORE_B_MARGIN \\n[#B_MARGIN]
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie \\n[#SINGLE_SPACE] \{\
.          ENDNOTE_LEAD      12 ADJUST
.          BIBLIOGRAPHY_LEAD 12 ADJUST
.       \}
.       el \{\
.          ie \\n[#EN_SINGLESPACE] .ENDNOTE_LEAD 12 ADJUST
.          el .ENDNOTE_LEAD 24 ADJUST
.          ie \\n[#BIB_SINGLESPACE] .BIBLIOGRAPHY_LEAD 12 ADJUST
.          el .BIBLIOGRAPHY_LEAD 24 ADJUST
.       \}
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie !d $EN_LEAD  .ENDNOTE_LEAD \\n[#UNADJUSTED_DOC_LEAD]u ADJUST
.       el .ENDNOTE_LEAD \\*[$EN_LEAD] \\*[$ADJUST_EN_LEAD]
.       ie !d $BIB_LEAD .BIBLIOGRAPHY_LEAD \\n[#UNADJUSTED_DOC_LEAD]u ADJUST
.       el .BIBLIOGRAPHY_LEAD \\*[$BIB_LEAD] \\*[$ADJUST_BIB_LEAD]
.       ie !d $TOC_LEAD .TOC_LEAD \\n[#UNADJUSTED_DOC_LEAD]u \\*[$ADJUST_TOC_LEAD]
.       el .TOC_LEAD \\*[$TOC_LEAD] \\*[$ADJUST_TOC_LEAD]
.    \}
.    ie !d $BIB_SPACE .BIBLIOGRAPHY_SPACING 0
.    el \{\
.       if \\n[#DEFER_BIB_SPACING]=1 \{\
.          BIBLIOGRAPHY_SPACING \\*[$BIB_SPACE]
.          rr #DEFER_BIB_SPACING
.       \}
.    \}
.    nr #DOC_LEAD \\n[#RESTORE_DOC_LEAD]u
.    nr #B_MARGIN \\n[#RESTORE_B_MARGIN]
.    vs \\n[#DOC_LEAD]u
.    if !\\n[#PRINT_STYLE]=1 \{\
.       if \\n[#RERUN_TRAPS] \{\
.          TRAPS
.          rr #RERUN_TRAPS
.       \}
.    \}
.\" Set default heading and toc-entry family if not done already
.    nr #HD_LEVEL 0 1 \" loop step
.    nr #LOOP 9       \" loop count
.    while \\n+[#HD_LEVEL]<=\\n[#LOOP] \{\
.       if '\\*[$HEAD_\\n[#HD_LEVEL]_FAM]'' \
.           ds $HEAD_\\n[#HD_LEVEL]_FAM \\*[$DOC_FAM]
.       if '\\*[$HEAD_\\n[#HD_LEVEL]_BASELINE_ADJ]'' \
.           ds $HEAD_\\n[#HD_LEVEL]_BASELINE_ADJ \\n[.v]/10
.       if '\\*[$TOC_HEAD_\\n[#HD_LEVEL]_FAM]'' \
.           ds $TOC_HEAD_\\n[#HD_LEVEL]_FAM \\*[$TOC_FAM]
.    \}
.    if '\\*[$TOC_TITLE_FAM]'' .TOC_TITLE_FAMILY \\*[$DOC_FAM]
.\" Re-run MNinit to capture strings and registers set in DEFAULTS.
.    if !'\\*[$MN-arg1]'' \{\
.       MNinit \
\\*[$MN-arg1] \\*[$MN-arg2] \
\\*[$MN-arg3] \\*[$MN-arg4] \
\\*[$MN-arg5] \\*[$MN-arg6] \
\\*[$MN-arg7] \\*[$MN-arg8] \
\\*[$MN-arg9]
.    \}
.    if \\n[#PRINT_STYLE]=1 .nr #IGNORE 1
.    if \\n[#AUTO_LEAD] \{\
.       rr #AUTO_LEAD
.       rr #AUTOLEAD_VALUE
.    \}
.END
\#
\# =================================================================
\#
\# Macros and aliases needed for doccover, cover, and docheader in
\# START.
\#
.MAC DOC_HEADER_QUAD END
.    if '\\$0'DOC_HEADER_QUAD' .ds $CALLING_MACRO DOCHEADER
.    if '\\$0'COVER_H_POS'     .ds $CALLING_MACRO COVER
.    if '\\$0'DOC_COVER_H_POS' .ds $CALLING_MACRO DOC_COVER
.    substring $\\*[$CALLING_MACRO]_QUAD 0 0
.    ie !'\\*[$\\*[$CALLING_MACRO]_QUAD]'' \{\
.       if '\\*[$\\*[$CALLING_MACRO]_QUAD]'L' .LEFT
.       if '\\*[$\\*[$CALLING_MACRO]_QUAD]'C' .CENTER
.       if '\\*[$\\*[$CALLING_MACRO]_QUAD]'C' .RIGHT
.    \}
.    el .CENTER
.END
.
.ALIAS COVER_H_POS     DOC_HEADER_QUAD
.ALIAS DOC_COVER_H_POS DOC_HEADER_QUAD
\#
.MAC DO_TITLE_OR_AUTHOR END
.    ie '\\$0'DO_AUTHORS' .ds $TTL_AUTH AUTHOR
.    el .ds $TTL_AUTH TITLE
.    if !'\\*[$\\*[$PRFX]\\*[$TTL_AUTH]_1]'' \{\
.       if '\\$0'DO_SUBTITLE' \{\
.          if '\\*[$PRFX]'\\*[DOC_]COVER_SUB' \{\
.             ds $PRFX SUB
.             nr #\\*[DOC_]COVER_SUB 1
.          \}
.       \}
.       if !\\n[#PRINT_STYLE]=1 \{\
\#.          if (\\n[#COVER]=1):(\\n[#DOC_COVER]=1) \
\#.             rn $PRFX $PRFX_SAVED
.          fam  \\*[$\\*[$COVER_TYPE]\\*[$PRFX]\\*[$TTL_AUTH]_FAM]
.          ft   \\*[$\\*[$COVER_TYPE]\\*[$PRFX]\\*[$TTL_AUTH]_FT]
.          ps \
\\n[#DOC_PT_SIZE]u\\*[$\\*[$COVER_TYPE]\\*[$PRFX]\\*[$TTL_AUTH]_SIZE_CHANGE]
.          if '\\*[$COVER_TYPE]'' .vs \\n[#DOCHEADER_LEAD]u
.          if !'\\*[$\\*[$COVER_TYPE]\\*[$PRFX]\\*[$TTL_AUTH]_LEAD]'' \{\
.             vs \\*[$\\*[$COVER_TYPE]\\*[$PRFX]\\*[$TTL_AUTH]_LEAD]
.             if \\n[#DOCHEADER] .sp |\\n[#T_MARGIN]u-1v
.          \}
.          if \\n[#CHAPTER+TITLE]=1 .ALD \\n[.v]u/4u \" A little space before the chapter title
.          if \\n[#\\*[$COVER_TYPE]\\*[$PRFX]\\*[$TTL_AUTH]_COLOR]=1 \
.             COLOR \\*[$\\*[$COVER_TYPE]\\*[$PRFX]\\*[$TTL_AUTH]_COLOR]
.          if \\n[#\\*[$COVER_TYPE]\\*[$PRFX]\\*[$TTL_AUTH]_CAPS]=1 .CAPS
.          if \\n[#\\*[$COVER_TYPE]\\*[$PRFX]\\*[$TTL_AUTH]_SMALLCAPS]=1 .SMALLCAPS
\#.          if (\\n[#COVER]=1):(\\n[#DOC_COVER]=1) \
\#.             rn $PRFX_SAVED $PRFX
.       \}
.       if \\n[#\\*[DOC_]COVER_SUB] \{\
.          rr #\\*[DOC_]COVER_SUB
.          ds $PRFX \\*[DOC_]COVER_SUB
.          ds $SAVED_COVER_TYPE \\*[$COVER_TYPE]
.          rm $COVER_TYPE
.       \}
.       nr #ARG_NUM 0 1
.       while \\n[#\\*[$PRFX]\\*[$TTL_AUTH]_NUM]>=\\n+[#ARG_NUM] \{\
.          ie \\n[#\\*[$COVER_TYPE]\\*[$PRFX]\\*[$TTL_AUTH]_UNDERLINE] \{\
.             ds $TITLE_TYPE \\*[$COVER_TYPE]\\*[$PRFX]\\*[$TTL_AUTH]
.             ie \\n[#\\*[$COVER_TYPE]\\*[$PRFX]\\*[$TTL_AUTH]_UNDERLINE]=2 \{\
.                ie !\\n[#PRINT_STYLE]=1 \
.                   UNDERSCORE2 \\*[$\\*[$PRFX]\\*[$TTL_AUTH]_UNDERLINE_GAP] \
\\*[$\\*[$PRFX]\\*[$TTL_AUTH]_RULE_GAP] \
"\\*[$\\*[$PRFX]\\*[$TTL_AUTH]_\\n[#ARG_NUM]]
.                el .UNDERSCORE "\\*[$\\*[$PRFX]\\*[$TTL_AUTH]_\\n[#ARG_NUM]]
.             \}
.             el \{\
.                ie !\\n[#PRINT_STYLE]=1 \
.                   UNDERSCORE "\\*[$\\*[$PRFX]\\*[$TTL_AUTH]_\\n[#ARG_NUM]]
.                el .PRINT "\\*[$\\*[$PRFX]\\*[$TTL_AUTH]_\\n[#ARG_NUM]]
.             \}
.          \}
.          el \{\
.             PRINT "\\*[$\\*[$PRFX]\\*[$TTL_AUTH]_\\n[#ARG_NUM]]
.          \}
.          if \\n[#ARG_NUM]>1 .as PDF_BM " \"
.          as PDF_BM \\*[$\\*[$PRFX]\\*[$TTL_AUTH]_\\n[#ARG_NUM]]
.       \}
.       rm $TITLE_TYPE
.       if \\n[#PRINT_STYLE]=2 .vs
.       if \\n[#\\*[$COVER_TYPE]\\*[$PRFX]\\*[$TTL_AUTH]_COLOR]=1 \
.          gcolor
.       SMALLCAPS off
.       CAPS off
.    \}
.    if !'\\*[$SAVED_COVER_TYPE]'' \{\
.      ds $COVER_TYPE \\*[$SAVED_COVER_TYPE]
.      rm $SAVED_COVER_TYPE
.   \}
.END
.
.ALIAS DO_TITLE    DO_TITLE_OR_AUTHOR
.ALIAS DO_SUBTITLE DO_TITLE_OR_AUTHOR
.ALIAS DO_AUTHORS  DO_TITLE_OR_AUTHOR
\#
.MAC DO_CHAPTER END
.    fam \\*[$\\*[DOC_]COVER_CHAPTER_FAM]
.    ft     \\*[$\\*[DOC_]COVER_CHAPTER_FT]
.    ps \\n[#DOC_PT_SIZE]u\\*[$\\*[DOC_]COVER_CHAPTER_SIZE_CHANGE]
.    if \\n[#\\*[DOC_]COVER_CHAPTER_COLOR]=1 \
.       COLOR \\*[$\\*[DOC_]COVER_CHAPTER_COLOR]
.    if \\n[#\\*[DOC_]COVER_CHAPTER_CAPS]=1 .CAPS
.    if \\n[#\\*[DOC_]COVER_CHAPTER_SMALLCAPS]=1 .SMALLCAPS
.    ie \\n[#\\*[DOC_]COVER_CHAPTER_UNDERLINE] \{\
.       ds $TITLE_TYPE \\*[$COVER_TYPE]CHAPTER
.       ie \\n[#\\*[DOC_]COVER_CHAPTER_UNDERLINE]=2 \
.          UNDERSCORE2 \\*[$\\*[DOC_]COVER_CHAPTER_UNDERLINE_GAP] \
\\*[$\\*[DOC_]COVER_CHAPTER_RULE_GAP] "\\*[$CHAPTER_STRING] \\*[$CHAPTER]"
.       el .UNDERSCORE "\\*[$CHAPTER_STRING] \\*[$CHAPTER]"
.    \}
.    el .PRINT "\\*[$CHAPTER_STRING] \\*[$CHAPTER]"
.    gcolor
.    SMALLCAPS off
.    CAPS off
.END
.
.ALIAS DO_TITLE    DO_TITLE_OR_AUTHOR
.ALIAS DO_SUBTITLE DO_TITLE_OR_AUTHOR
.ALIAS DO_AUTHORS  DO_TITLE_OR_AUTHOR
\#
.MAC DO_CHAPTER END
.    fam \\*[$\\*[DOC_]COVER_CHAPTER_FAM]
.    ft     \\*[$\\*[DOC_]COVER_CHAPTER_FT]
.    ps \\n[#DOC_PT_SIZE]u\\*[$\\*[DOC_]COVER_CHAPTER_SIZE_CHANGE]
.    if \\n[#\\*[DOC_]COVER_CHAPTER_COLOR]=1 \
.       COLOR \\*[$\\*[DOC_]COVER_CHAPTER_COLOR]
.    if \\n[#\\*[DOC_]COVER_CHAPTER_CAPS]=1 .CAPS
.    if \\n[#\\*[DOC_]COVER_CHAPTER_SMALLCAPS]=1 .SMALLCAPS
.    ie \\n[#\\*[DOC_]COVER_CHAPTER_UNDERLINE] \{\
.       ds $TITLE_TYPE \\*[$COVER_TYPE]CHAPTER
.       ie \\n[#\\*[DOC_]COVER_CHAPTER_UNDERLINE]=2 \
.          UNDERSCORE2 \\*[$\\*[DOC_]COVER_CHAPTER_UNDERLINE_GAP] \
\\*[$\\*[DOC_]COVER_CHAPTER_RULE_GAP] "\\*[$CHAPTER_STRING] \\*[$CHAPTER]"
.       el .UNDERSCORE "\\*[$CHAPTER_STRING] \\*[$CHAPTER]"
.    \}
.    el .PRINT "\\*[$CHAPTER_STRING] \\*[$CHAPTER]"
.    gcolor
.    SMALLCAPS off
.    CAPS off
.END
\#
\# Spacing adjustments for (doc)cover and docheader elements
\#
.MAC _SPACE END
.   ds $\\$0R \\$1
.END
.
.ds SPACER_TYPE_1 SUBTITLE
.ds SPACER_TYPE_2 ATTRIBUTE
.ds SPACER_TYPE_3 AUTHOR
.ds SPACER_TYPE_4 CHAPTER_TITLE
.ds SPACER_TYPE_5 DOCTYPE
.
.nr #LOOP 0 1
.while \n+[#LOOP]<=5 \{\
.   ALIAS \*[SPACER_TYPE_\n[#LOOP]]_SPACE           _SPACE
.   ALIAS COVER_\*[SPACER_TYPE_\n[#LOOP]]_SPACE     _SPACE
.   ALIAS DOC_COVER_\*[SPACER_TYPE_\n[#LOOP]]_SPACE _SPACE
.\}
\#
.MAC DEFAULT_DOCHEADER END
.    nr #DOCHEADER 1
.    DOC_HEADER_QUAD
.    vs \\n[#DOCHEADER_LEAD]u
.    if \\n[#PRINT_STYLE]=2 \
.       if \\n[#DOCHEADER_COLOR]=1 \
.          COLOR \\*[$DOCHEADER_COLOR]
.    DO_TITLE
.    rr #DOCHEADER
.    if !'\\*[$SUBTITLE_1]'' \{\
.       ds $PRFX SUB
.       if !'\\*[$SUBTITLE_SPACER]'' .sp \\*[$SUBTITLE_SPACER]
.       if \\n[#PRINT_STYLE]=2 \
.          if \\n[#DOCHEADER_COLOR]=1 \
.             COLOR \\*[$DOCHEADER_COLOR]
.       DO_SUBTITLE
.       rm $PRFX
.    \}
.    if !\\n[#NO_PRINT_AUTHOR] \{\
.       if !'\\*[$AUTHOR_1]'' \{\
.          ie \\n[#PRINT_STYLE]=1 \{\
.             TYPEWRITER
.             ie \\n[#SINGLE_SPACE]=1 .vs \\n[#DOC_LEAD]u
.             el .vs \\n[#DOC_LEAD]u/2u
.             sp
.          \}
.          el .vs \\n[#DOC_LEAD]u\\*[$DOCHEADER_LEAD_ADJ]
.          if d$ATTRIBUTE_STRING \{\
.             FAMILY \\*[$ATTRIBUTE_FAM]
.             FT     \\*[$ATTRIBUTE_FT]
.             ps \
\\n[#DOC_PT_SIZE]u\\*[$ATTRIBUTE_SIZE_CHANGE]
.             if \\n[#DOCHEADER_COLOR]=1 \
.                COLOR \\*[$DOCHEADER_COLOR]
.             if \\n[#ATTRIBUTE_COLOR]=1 \
.                COLOR \\*[$ATTRIBUTE_COLOR]
.             if \\n[#ATTRIBUTE_CAPS]=1 .CAPS
.             if !'\\*[$ATTRIBUTE_SPACER]'' \
.                sp \\*[$ATTRIBUTE_SPACER]
.             ie \\n[#ATTRIBUTE_UNDERLINE] \{\
.                ds $TITLE_TYPE ATTRIBUTE
.                ie \\n[#ATTRIBUTE_UNDERLINE]=2 \
.                   UNDERSCORE2 \\*[$ATTRIBUTE_UNDERLINE_GAP] \
\\*[$ATTRIBUTE_RULE_GAP] "\\*[$ATTRIBUTE_STRING]"
.                el .UNDERSCORE "\\*[$ATTRIBUTE_STRING]"
.             \}
.             el .PRINT "\\*[$ATTRIBUTE_STRING]"
.             if \\n[#ATTRIBUTE_COLOR]=1 .gcolor
.             CAPS off
.          \}
.          if !'\\*[$AUTHOR_SPACER]'' .sp \\*[$AUTHOR_SPACER]
.          if \\n[#DOCHEADER_COLOR]=1 \
.             COLOR \\*[$DOCHEADER_COLOR]
.          DO_AUTHORS
.       \}
.    \}
.    FAMILY \\*[$DOC_FAM]
.    FT R
.END
\#
.MAC DEFAULT_DOCHEADER_TYPEWRITE END
.    CENTER
.    TYPEWRITER
.    if !\\n[#SINGLE_SPACE] \{\
.       vs \\n[#DOC_LEAD]u/2u
.       sp |\\n[#T_MARGIN]u-1v
.    \}
.    if !'\\*[$TITLE_1]'' \{\
.       ie \\n[#SINGLE_SPACE] \
.          vs \\n[#DOC_LEAD]u+(\\n[#DOC_LEAD]u/4u)
.       el .vs (\\n[#DOC_LEAD]u/2u)+(\\n[#DOC_LEAD]u/4u)
.       CAPS
.       DO_TITLE
.       CAPS OFF
.       vs
.    \}
.    if !'\\*[$SUBTITLE]'' \{\
.       ds $PRFX SUB
.       sp
.       DO_SUBTITLE
.       rm $PRFX
.    \}
.    if !\\n[#NO_PRINT_AUTHOR] \{\
.       if !'\\*[$AUTHOR_1]'' \{\
.          sp
.          if d$ATTRIBUTE_STRING .PRINT "\\*[$ATTRIBUTE_STRING]
.          sp
.          DO_AUTHORS
.       \}
.    \}
.END
\#
.MAC CHAPTER_DOCHEADER END
.    DOC_HEADER_QUAD
.    FAMILY  \\*[$CHAPTER_FAM]
.    FT      \\*[$CHAPTER_FT]
.    ps \\n[#DOC_PT_SIZE]u\\*[$CHAPTER_SIZE_CHANGE]
.    vs \\n[#DOCHEADER_LEAD]u
.\" Chapter title only
.    ie '\\*[$CHAPTER]'' \{\
.       if \\n[#PRINT_STYLE]=2 \
.          if \\n[#DOCHEADER_COLOR]=1 \
.             COLOR \\*[$DOCHEADER_COLOR]
.       if !'\\*[$CHAPTER_TITLE_1]'' \{\
.          ds $PRFX CHAPTER_
.          nr #DOCHEADER 1
.          DO_TITLE
.          rr #DOCHEADER
.          rm $PRFX
.       \}
.    \}
.\" Chapter string, possibly with a chapter title
.    el \{\
.       if \\n[#PRINT_STYLE]=2 \{\
.          if \\n[#DOCHEADER_COLOR]=1 \
.             COLOR \\*[$DOCHEADER_COLOR]
.          if \\n[#CHAPTER_COLOR]=1 \
.             COLOR \\*[$CHAPTER_COLOR]
.       \}
.       if \\n[#CHAPTER_CAPS]=1 .CAPS
.       ie \\n[#CHAPTER_UNDERLINE] \{\
.          ds $TITLE_TYPE CHAPTER
.          ie \\n[#CHAPTER_UNDERLINE]=2 \
.             UNDERSCORE2 \\*[$CHAPTER_UNDERLINE_GAP] \
\\*[$CHAPTER_RULE_GAP] "\\*[$CHAPTER_STRING] \\*[$CHAPTER]"
.          el .UNDERSCORE "\\*[$CHAPTER_STRING] \\*[$CHAPTER]"
.       \}
.       el .PRINT "\\*[$CHAPTER_STRING] \\*[$CHAPTER]"
.       rm $TITLE_TYPE
.       if \\n[#PRINT_STYLE]=2 \
.          if \\n[#CHAPTER_COLOR]=1 .gcolor
.       CAPS off
.       if !'\\*[$CHAPTER_TITLE_1]'' \{\
.          ds $PRFX CHAPTER_
.          if \\n[#PRINT_STYLE]=2 \{\
.             nr #CHAPTER+TITLE 1
.             if \\n[#DOCHEADER_COLOR]=1 \
.                COLOR \\*[$DOCHEADER_COLOR]
.          \}
.          if !'\\*[$CHAPTER_TITLE_SPACER]'' \
.             sp \\*[$CHAPTER_TITLE_SPACER]
.          DO_TITLE
.          rm $PRFX
.          rr #CHAPTER+TITLE
.          RLD \\n[#DOC_LEAD]u \" Just looks better this way
.       \}
.    \}
.    FAMILY \\*[$DOC_FAM]
.    FT R
.END
\#
.MAC CHAPTER_DOCHEADER_TYPEWRITE END
.    CENTER
.    TYPEWRITER
.    if !\\n[#SINGLE_SPACE] \{\
.       vs \\n[#DOC_LEAD]u/2u
.       sp |\\n[#T_MARGIN]u-1v
.    \}
.    ie '\\*[$CHAPTER]'' \{\
.       CAPS
.       ie !'\\*[$CHAPTER_TITLE]'' \{\
.          vs \\n[.v]u+(\\n[.v]u/3u)
.          nr #ARG_NUM 0 1
.          while \\n[#CHAPTER_TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.             UNDERSCORE 3p "\\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]"
.          \}
.          vs
.       \}
.       el \{\
.          CAPS
.          UNDERSCORE 3p "\\*[$CHAPTER_STRING]"
.       \}
.       CAPS OFF
.       RLD 1v
.    \}
.    el \{\
.       CAPS
.       UNDERSCORE 3p "\\*[$CHAPTER_STRING] \\*[$CHAPTER]
.       CAPS OFF
.       if !'\\*[$CHAPTER_TITLE]'' \{\
.          sp
.          nr #ARG_NUM 0 1
.          while \\n[#CHAPTER_TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.             PRINT "\\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]
.          \}
.       \}
.       sp -1
.    \}
.    vs \\n[#DOC_LEAD]u
.    if \\n[#SINGLE_SPACE] .sp 2
.END
\#
.MAC NAMED_DOCHEADER END
.    DEFAULT_DOCHEADER
.    if !\\n[#NO_PRINT_DOCTYPE] \{\
.       FAMILY  \\*[$DOCTYPE_FAM]
.       FT      \\*[$DOCTYPE_FT]
.       ps \\n[#DOC_PT_SIZE]u\\*[$DOCTYPE_SIZE_CHANGE]
.       vs \\n[#DOCHEADER_LEAD]u
.       ALD     \\n[#DOCHEADER_LEAD]u
.       if \\n[#DOCHEADER_COLOR]=1 \
.          COLOR \\*[$DOCHEADER_COLOR]
.       if \\n[#DOCTYPE_COLOR]=1 \
.          COLOR \\*[$DOCTYPE_COLOR]
.       if \\n[#DOCTYPE_CAPS]=1 .CAPS
.       if !'\\*[$DOCTYPE_SPACER]'' .sp \\*[$DOCTYPE_SPACER]
.       ie \\n[#DOCTYPE_UNDERLINE] \{\
.          ds $TITLE_TYPE DOCTYPE
.          ie \\n[#DOCTYPE_UNDERLINE]=2 \
.              UNDERSCORE2 \\*[$DOCTYPE_UNDERLINE_GAP] \
\\*[$DOCTYPE_RULE_GAP] "\\*[$DOC_TYPE]
.          el .UNDERSCORE "\\*[$DOC_TYPE]
.       \}
.       el .PRINT "\\*[$DOC_TYPE]
.       gcolor
.       CAPS off
.    \}
.    FAMILY \\*[$DOC_FAM]
.    FT R
.END
\#
\# COVER PAGE
\# ----------
\# *Arguments:
\#   TITLE | DOCTITLE | CHAPTER | CHAPTER_TITLE | CHAPTER+TITLE | COVERTITLE \
\#   [ SUBTITLE AUTHOR DOCTYPE COPYRIGHT MISC BLANKPAGE PDF_OUTLINE_LABEL ]
\# *Function:
\#   Toggles the number register for each cover page element
\#   passed as an argument.
\# *Notes:
\#   TITLE, DOCTITLE, CHAPTER, CHAPTER_TITLE or CHAPTER+TITLE must
\#   be supplied.  After that, users may enter as many or as few of
\#   the arguments as they like.  BLANKPAGE inserts a blank page
\#   after the cover.
\#
\#   If called as DOC_COVER, performs the same operations, but
\#   applies everything to a doc cover.
\#
.MAC COVER END
.    rm DOC_
.    ie '\\$0'DOC_COVER' \{\
.       nr #DOC_COVER 1
.       ds DOC_ DOC_
.    \}
.    el .nr #COVER 1
.    nr #ARG_NUM 0 1
.    nr #COVER_ITEM \\n[#NUM_ARGS]  \"loop count
.    if \\n[#NUM_ARGS]=1 \
.       if '\\$1'\\*[DOC_]COVERTEXT' \
.          nr #\\*[DOC_]COVERTEXT_ONLY 1
.    while \\n+[#ARG_NUM]<=\\n[#COVER_ITEM] \{\
.       if '\\$1'DOCTITLE' \{\
.          nr #\\*[DOC_]COVER_TITLE 2
.          shift
.       \}
.       if '\\$1'TITLE' \{\
.          nr #\\*[DOC_]COVER_TITLE 1
.          if \\n[#FROM_\\*[DOC_]COVERTITLE] \{\
.             nr #\\*[DOC_]COVER_TITLE 7
.             rr #FROM_\\*[DOC_]COVERTITLE
.          \}
.          shift
.       \}
.       if '\\$1'CHAPTER' \{\
.          nr #\\*[DOC_]COVER_TITLE 3
.          shift
.       \}
.       if '\\$1'CHAPTER_TITLE' \{\
.          nr #\\*[DOC_]COVER_TITLE 4
.          shift
.       \}
.       if '\\$1'CHAPTER+TITLE' \{\
.          nr #\\*[DOC_]COVER_TITLE 5
.          shift
.       \}
.       if '\\$1'COVERTITLE' \{\
.          nr #COVERTITLE 1
.          nr #\\*[DOC_]COVER_TITLE 6
.          shift
.       \}
.       if '\\$1'DOC_COVERTITLE' \{\
.          nr #DOC_COVERTITLE 1
.          nr #\\*[DOC_]COVER_TITLE 7
.          shift
.       \}
.       if '\\$1'SUBTITLE' \{\
.          nr #\\*[DOC_]COVER_SUBTITLE 1
.          shift
.       \}
.       if '\\$1'AUTHOR' \{\
.          nr #\\*[DOC_]COVER_AUTHOR 1
.          shift
.       \}
.       if '\\$1'DOCTYPE' \{\
.          nr #\\*[DOC_]COVER_DOCTYPE 1
.          shift
.       \}
.       if '\\$1'COPYRIGHT' \{\
.          nr #\\*[DOC_]COVER_COPYRIGHT 1
.          shift
.       \}
.       if '\\$1'MISC' \{\
.          nr #\\*[DOC_]COVER_MISC 1
.          shift
.       \}
.       if '\\$1'\\*[DOC_]COVERTEXT' \{\
.          nr #\\*[DOC_]COVERTEXT 1
.          shift
.       \}
.       if '\\$1'\\*[DOC_]COVER_IMAGE' \{\
.          nr #\\*[DOC_]COVER_IMAGE 1
.          shift
.       \}
.       if '\\$1'PDF_OUTLINE_LABEL' \{\
.          shift
.          ds $PDF_\\*[DOC_]COVER_LABEL \\$1
.          shift
.       \}
.       if '\\$1'BLANKPAGE' \{\
.          nr #\\*[DOC_]COVER_BLANKPAGE 1
.          shift
.       \}
.    \}
.    if '\\$0'DOC_COVER' .rm DOC_
.END
\#
\# COVER TITLE
\# -----------
\# *Arguments:
\#   <covertitle>
\# *Function:
\#   Stores cover title in string(s) for output on cover pages.
\#
.MAC COVERTITLE END
.    rm DOC_
.    if '\\$0'DOC_COVERTITLE' \{\
.       ds DOC_ DOC_
.       nr #FROM_\\*[DOC_]COVERTITLE 1
.    \}
.    ie \\n[#NUM_ARGS]=0 \{\
.       nr argc 0 1
.       while \\n+[argc]<=3 \{\
.          if \\n[#\\*[DOC_]COVER_TITLE_NUM] \{\
.             nr #ITEM 0 1
.             while \\n[#\\*[DOC_]COVERTITLE_NUM]>\\n[#ITEM] \{\
.                rm $\\*[DOC_]COVERTITLE_\\n+[#ITEM]
.             \}
.             rr #\\*[DOC_]COVERTITLE_NUM
.             rm $\\*[DOC_]COVERTITLE
.          \}
.       \}
.    \}
.    el \{\
.       nr #\\*[DOC_]COVERTITLE_NUM 0 1
.       while \\n[#NUM_ARGS]>\\n[#\\*[DOC_]COVERTITLE_NUM] \{\
.          ds \
$\\*[DOC_]COVERTITLE_\\n+[#\\*[DOC_]COVERTITLE_NUM] \\$\\n[#\\*[DOC_]COVERTITLE_NUM]
.          nr #\\*[DOC_]COVERTITLE_NUM \\n[#\\*[DOC_]COVERTITLE_NUM]
.       \}
.       ds $\\*[DOC_]COVERTITLE \\$*
.    \}
.END
\#
.MAC COVER_ATTRIBUTE_STRING END
.    if '\\$0'DOC_COVER_ATTRIBUTE_STRING' \
.       ds DOC_ DOC_
.    ds $\\*[DOC_]COVER_ATTRIBUTE_STRING \\$1 
.    rm DOC_
.END
.
.ALIAS DOC_COVER_ATTRIBUTE_STRING COVER_ATTRIBUTE_STRING
\#
\# COVER TEXT
\# ----------
\# *Arguments:
\#   [ START <vertical pos> ] | <anything>
\# *Function:
\#   With no arg, begins a diversion holding the cover text for
\#   output on the cover page.  With START <pos>, sets a vertical
\#   starting position relative to the top edge of the page.  With
\#   any other arg, ends the diversion.
\# *Notes:
\#   Aliased as DOC_COVERTEXT.
\#
\#   If no other items assigned to cover pages, starts 1/3 of the
\#   way down the cover page unless START pos is given, otherwise
\#   starts underneath the last of title, subtitle, author(s) or
\#   doctype, preceded by a blank line.
\#
\#   Does not persist.
\#
.MAC COVERTEXT END
.    rm DOC_
.    if '\\$0'DOC_COVERTEXT' .ds DOC_ DOC_
.    if '\\$1'START' \{\
.       shift
.       nr #\\*[DOC_]COVERTEXT_START_POS (u;\\$1)
.       shift
.    \}
.    ie '\\$1'' \{\
.       nr #COVERTEXT_PP 1
.       di \\*[DOC_]COVER_TEXT
.       ev 1
\!.     ie !\\n[#\\*[DOC_]COVERTEXT_START_POS] \{\
\!.        sp |\\n[.p]u/3u-1v
\!.     \}
\!.     el \{\
\!.        vs 0
\!.        sp |0i
\!.        vs \\\\n[#DOC_LEAD]u+\\\\*[$\\*[DOC_]COVER_LEAD_ADJ]
\!.        sp |\\n[#\\*[DOC_]COVERTEXT_START_POS]u-1
\!.     \}
\!.     vpt
.    \}
.    el \{\
.       br
\!.     vpt 0
.       ev
.       di
.       rm $FONT
.       rr #COVERTEXT_PP
.       IQ CLEAR
.    \}
.    rm DOC_
.END
.
.ALIAS DOC_COVERTEXT COVERTEXT
\#
\# COVER IMAGE
\# -----------
\#*Arguments:
\#  <image file> <width> <height> [ -L|-C|-R|-I <ind> Y-pos [ X-pos ] ]
\#*Function:
\#  Places an image on doccovers and covers.
\#*Notes:
\#  Aliased as DOC_COVER_IMAGE.
\#
\#  <width> and <height> are required.  With no further args, images
\#  are set at 0,0 by default so that full page images fill the entire
\#  printer sheet.
\#  
\#  Positioning args are the same as PDF_IMAGE.  -L, -R, -C and -I <ind>
\#  observe the left and right margins.
\#
\#  Y-pos is required for all but full page images; without it, images
\#  are flush with the top of the page.  X-pos is only needed if the
\#  user prefers to give absolute X,Y positioning.
\#
\#  Note that Y-pos comes before X-pos in the args.
\#
.MAC COVER_IMAGE END
. if '\\$0'DOC_COVER_IMAGE' .ds DOC_ DOC_
. ds \\*[DOC_]COVER_IMG_FILE \\$1
. nr \\*[DOC_]COVER_IMG_W (z;\\$2)
. nr \\*[DOC_]COVER_IMG_H (z;\\$3)
. if !'\\$4'' \{\
.   ie !\B'\\$4' \{\
.     if '\\$4'-L' .nr \\*[DOC_]COVER_IMG_IND \
        \\n[#L_MARGIN]u
.     if '\\$4'-C' .nr \\*[DOC_]COVER_IMG_IND \
        \\n[#PAGE_WIDTH]u-\\n[\\*[DOC_]COVER_IMG_W]u/2
.     if '\\$4'-R' .nr \\*[DOC_]COVER_IMG_IND \
        \\n[#L_MARGIN]+\\n[.l]u-\\n[\\*[DOC_]COVER_IMG_W]u
.     if '\\$4'-I' \{\
.       nr \\*[DOC_]COVER_IMG_IND \\n[#L_MARGIN]+\\$5
.       if !'\\$6'' .nr \\*[DOC_]COVER_IMG_Y (u;\\$6)
.       shift \\n[#NUM_ARGS]
.     \}
.     if \B'\\$5' .nr \\*[DOC_]COVER_IMG_Y (u;\\$5)
.   \}
.   el \{\
.     nr \\*[DOC_]COVER_IMG_Y (u;\\$4)
.     if \B'\\$5' .nr \\*[DOC_]COVER_IMG_X (u;\\$5)
.   \}
. \}
. rm DOC_
.END
.
.ALIAS DOC_COVER_IMAGE COVER_IMAGE
\#
.MAC DO_COVER_IMAGE END
.    ll \\n[#PAGE_WIDTH]u
.    po 0
.    vs 0
.    sp |0i
.    if \\n[\\*[DOC_]COVER_IMG_Y]   .sp \\n[\\*[DOC_]COVER_IMG_Y]u
.    if \\n[\\*[DOC_]COVER_IMG_X]   .in \\n[\\*[DOC_]COVER_IMG_X]u
.    if \\n[\\*[DOC_]COVER_IMG_IND] .in \\n[\\*[DOC_]COVER_IMG_IND]u
.    if \\n[.u]=1 .nf
.    nop \X'pdf: pdfpic \\*[\\*[DOC_]COVER_IMG_FILE] -L \
\\n[\\*[DOC_]COVER_IMG_W]z \\n[\\*[DOC_]COVER_IMG_H]z'
.    in
.    vs
.    po
.    ll
.END
.
.ALIAS DO_DOC_COVER_IMAGE DO_COVER_IMAGE
\#
\# COVER PAGE LEADING
\# ------------------
\# *Arguments:
\#   <+|- amount by which to in/decrease leading of cover/doc cover>
\# *Function:
\#   Stores user supplied lead in/decrease in string $COVER_LEAD_ADJ
\#   or $DOC_COVER_LEAD_ADJ, depending on whether the macro was called
\#   with an alias (DOC_COVER_LEAD).
\# *Notes:
\#   A unit of measure must be supplied.  Decimal fractions OK.
\#   Default is +0, i.e. same as DOC_LEAD.
\#
.MAC COVER_LEAD END
.    ie '\\$0'DOC_COVER_LEAD' .ds $DOC_COVER_LEAD_ADJ \\$1
.    el .ds $COVER_LEAD_ADJ \\$1
.END
\#
\# MISC_AUTOLEAD functionality has been removed.  Leading for MISCs
\# is now entered as an absolute value.  The macro emits a warning.
\#
.MAC MISC_AUTOLEAD END
.    ds replacement \\$0
.    substring replacement 0 -9
.    ds replacement \\*[replacement]LEAD
.    ds cover-type \\$0
.    substring cover-type 0 2
.    ie '\\*[cover-type]'COV' .ds cover-type cover
.    el .ds cover-type doc-cover
.    tm1 "[mom]: \\$0 at line \\n[.c] of '\\n[.F]' is no longer valid.
.    tm1 "       Leading of \\*[cover-type] MISC items is now set with \\*[replacement], which
.    tm1 "       takes an absolute leading value.  Please update your document.
.    ab   [mom]: Aborting.
.END
.
.ALIAS DOC_COVER_MISC_AUTOLEAD MISC_AUTOLEAD
.ALIAS COVER_MISC_AUTOLEAD     MISC_AUTOLEAD
\#
\# COVER PAGE START POSITION
\# -------------------------
\# *Arguments:
\#   <distance from page top at which to start cover/doc cover>
\# *Function:
\#   Stores user supplied lead in/decrease in #COVER_START_POS
\#   or #DOC_COVER_START_POS, depending on whether the macro was
\#   called by an alias (DOC_COVER_ADVANCE).
\# *Notes:
\#   A unit of measure must be supplied.  Decimal fractions OK.
\#   If user doesn't invoke this macro, the default starting
\#   position for both covers and doc covers is 1/3 of the way
\#   down the page (setup in DO_COVER).
\#
.MAC COVER_ADVANCE END
.    ds COVER_TYPE \\$0
.    substring COVER_TYPE 0 2
.    ie 'COVER_TYPE'DOC' .nr #DOC_COVER_START_POS (\\$1)
.    el .nr #COVER_START_POS (\\$1)
.END
.
.ALIAS DOC_COVER_ADVANCE   COVER_ADVANCE
.ALIAS DOC_COVER_START_POS COVER_ADVANCE
.ALIAS COVER_ADVANCE       COVER_ADVANCE
.ALIAS COVER_START_POS     COVER_ADVANCE
\#
\# COVERS - WHETHER TO PRINT
\# -------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes registers #COVERS and #COVERS_OFF, checked for
\#   in DEFAULTS (in START) prior to printing
\#
.MAC COVERS END
.    ie '\\$0'DOC_COVERS' \{\
.       ie '\\$1'' \{\
.          rr #DOC_COVERS_OFF
.          nr #DOC_COVERS 1
.       \}
.       el \{\
.          rr #DOC_COVERS
.          nr #DOC_COVERS_OFF 1
.       \}
.    \}
.    el \{\
.       ie '\\$1'' \{\
.          rr #COVERS_OFF
.          nr #COVERS 1
.       \}
.       el \{\
.          rr #COVERS
.          nr #COVERS_OFF 1
.       \}
.    \}
.END
\#
\# COVER_COUNTS_PAGES
\# ------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes registers #COVERS_COUNT or #DOCCOVERS_COUNT,
\#   used in END_COVER to determine whether to increment the page
\#   number silently when doc covers or covers are output.
\#
.MAC COVER_COUNTS_PAGES END
.    if '\\$0'DOC_COVER_COUNTS_PAGES' \{\
.       ie '\\$1'' .nr #DOCCOVERS_COUNT 1
.       el .rr #DOCCOVERS_COUNT
.       return
.    \}
.    if '\\$0'COVER_COUNTS_PAGES' \{\
.       ie '\\$1'' .nr #COVERS_COUNT 1
.       el .rr #COVERS_COUNT
.       return
.    \}
.END
\#
.MAC DO_COVER END
.    nr #DOING_COVER 1
.    ev COVER
.    evc 0
.    vpt 0
.    if \\n[#PAGINATE]=1 \{\
.       nr #PAGINATION_WAS_ON 1
.       rr #PAGINATE
.    \}
.    if \\n[#HEADERS_ON]=1 \{\
.       nr #HEADERS_WERE_ON 1
.       HEADERS OFF
.    \}
.    if \\n[#FOOTERS_ON]=1 \{\
.       nr #FOOTERS_WERE_ON 1
.       FOOTERS OFF
.    \}
.    if \\n[#COLUMNS]=1 \{\
.       nr #COLUMNS_WERE_ON 1
.       rr #COLUMNS
.    \}
.    ds PDF_BM
.    ie '\\$0'DO_DOC_COVER' \{\
.       ds  DOC_  DOC_
.       nr #DOC_COVER_DONE 1
.       if '\\*[$PDF_DOC_COVER_LABEL]'' \
.          ds $PDF_DOC_COVER_LABEL Cover:
.    \}
.    el \
.       if '\\*[$PDF_COVER_LABEL]'' \
.          ds $PDF_COVER_LABEL Title Page:
.    ds $COVER_TYPE \\*[DOC_]COVER_
.    if !r#\\*[DOC_]COVER_START_POS \
.       nr #\\*[DOC_]COVER_START_POS \\n[#PAGE_LENGTH]/3
.    if \\n[#PRINT_STYLE]=1 \
.       if !\\n[#SINGLE_SPACE]=1 .vs \\n[#DOC_LEAD]u/2u
.    if \\n[#PRINT_STYLE]=2 \{\
.       vs \\n[#DOC_LEAD]u\\*[$\\*[DOC_]COVER_LEAD_ADJ]
.       nr #\\*[DOC_]COVER_LEAD \\n[.v]
.    \}
.    if \\n[.ns] .rs
.    if '\\$0'DO_COVER' \{\
.       if \\n[TOC.RELOCATE]==5 \
.          if !rTOC_BH .TOC_BEFORE_HERE
.    \}
.    if '\\$0'DO_DOC_COVER' \{\
.       if \\n[TOC.RELOCATE]==3 \
.          if !rTOC_BH .TOC_BEFORE_HERE
.    \}
.    RV_HARD_SET_MARGINS
.\" Cover image
.    if \\n[#\\*[DOC_]COVER_IMAGE]=1 \{\
.       DO_\\*[DOC_]COVER_IMAGE
.       rr #\\*[DOC_]COVER_IMAGE
.    \}
.\" Start cover
.    sp |\\n[#\\*[DOC_]COVER_START_POS]u-1v
.    if !\\n[#PRINT_STYLE]=1 \
.       if \\n[#\\*[DOC_]COVER_COLOR]=1 \
.          COLOR \\*[$\\*[DOC_]COVER_COLOR]
.    \\*[DOC_]COVER_H_POS
.    if \\n[#\\*[DOC_]COVER_TITLE]=2 .ds DOC DOC
.    fam \\*[$\\*[DOC_]COVER_\\*[DOC]TITLE_FAM]
.    ft  \\*[$\\*[DOC_]COVER_\\*[DOC]TITLE_FT]
.    ps  \\*[$\\*[DOC_]COVER_\\*[DOC]TITLE_SIZE_CHANGE]
.    ie \\n[#PRINT_STYLE]=1 .TYPEWRITER
.    el .vs \\n[#\\*[DOC_]COVER_LEAD]u
.    nr PDFHREF.VIEW.LEADING \\n[PDFHREF.VIEW.LEADING.C]
.\" Title and/or doctitle
.    if (\\n[#\\*[DOC_]COVER_TITLE]=1):(\\n[#\\*[DOC_]COVER_TITLE]=2) \{\
.       ie \\n[#PRINT_STYLE]=1 \{\
.          vs \\n[.v]u*2u
.          sp -1.5
.          CAPS
.          nr #ARG_NUM 0 1
.          while \\n[#TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.             UNDERSCORE "\\*[$TITLE_\\n[#ARG_NUM]]"
.             if \\n[#ARG_NUM]>1 .as PDF_BM " \"
.             as PDF_BM \\*[$TITLE_\\n[#ARG_NUM]]
.          \}
.          CAPS OFF
.          vs
.       \}
.       el \{\
.          DO_TITLE
.          rm $PRFX
.       \}
.       PDF_BOOKMARK 1 \\*[$PDF_\\*[DOC_]COVER_LABEL] \\*[PDF_BM]
.    \}
.\" Chapter
.    if \\n[#\\*[DOC_]COVER_TITLE]=3 \{\
.       ie \\n[#PRINT_STYLE]=1 \{\
.          CAPS
.          UNDERSCORE "\\*[$CHAPTER_STRING] \\*[$CHAPTER]
.          CAPS OFF
.       \}
.       el .DO_CHAPTER
.       PDF_BOOKMARK 1 \
\\*[$PDF_\\*[DOC_]COVER_LABEL] \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.       if \\n[#\\*[DOC_]COVER_CHAPTER_CAPS]=1 .CAPS off
.    \}
.\" Chapter title
.    if \\n[#\\*[DOC_]COVER_TITLE]=4 \{\
.       ie \\n[#PRINT_STYLE]=1 \{\
.          CAPS
.          nr #ARG_NUM 0 1
.          vs \\n[.v]u*2u
.          sp -1.5
.             while \\n[#CHAPTER_TITLE_NUM]>=\\n[#ARG_NUM] \{\
.                UNDERSCORE "\\*[$CHAPTER_TITLE_\\n+[#ARG_NUM]]"
.                if \\n[#ARG_NUM]>1 .as PDF_BM " \"
.                as PDF_BM \\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]
.             \}
.          CAPS OFF
.          vs
.       \}
.       el \{\
.          ds $PRFX CHAPTER_
.          DO_TITLE
.          rm $PRFX
.       \}
.       PDF_BOOKMARK 1 \\*[$PDF_\\*[DOC_]COVER_LABEL] \\*[PDF_BM]
.    \}
.\" Chapter + chapter title
.    if \\n[#\\*[DOC_]COVER_TITLE]=5 \{\
.       ie \\n[#PRINT_STYLE]=1 \{\
.          CAPS
.          UNDERSCORE "\\*[$CHAPTER_STRING] \\*[$CHAPTER]
.          CAPS OFF
.       \}
.       el .DO_CHAPTER
.       if !'\\*[$CHAPTER_TITLE_1]'' \{\
.          ie \\n[#PRINT_STYLE]=1 \{\
.             ie \\n[#SINGLE_SPACE]=0 .vs \\n[#DOC_LEAD]u/2u
.             el .vs \\n[#DOC_LEAD]u
.             sp
.             nr #ARG_NUM 0 1
.             while \\n[#CHAPTER_TITLE_NUM]>=\\n+[#ARG_NUM] \{\
.                PRINT "\\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]"
.                if \\n[#ARG_NUM]>1 .as PDF_BM " \"
.                as PDF_BM \\*[$CHAPTER_TITLE_\\n[#ARG_NUM]]
.             \}
.             if \\n[#SINGLE_SPACE]=0 .vs \\n[#DOC_LEAD]u
.          \}
.          el \{\
.             ds $PRFX CHAPTER_
.             if \\n[#PRINT_STYLE]=2 .nr #CHAPTER+TITLE 1
.             if !'\\*[$\\*[DOC_]COVER_CHAPTER_TITLE_SPACER]'' \
.                sp \\*[$\\*[DOC_]COVER_CHAPTER_TITLE_SPACER]
.             DO_TITLE
.             rr #CHAPTER+TITLE
.             rm $PRFX
.          \}
.       \}
.       PDF_BOOKMARK 1 \\*[$PDF_\\*[DOC_]COVER_LABEL] \\*[PDF_BM]
.    \}
.\"  (Doc)covertitle
.\"    Titles to (doc)covers that are entered with
.\"      .TITLE DOC_COVER title
.\"    and included in (DOC)COVER with TITLE get treated as
.\"    (DOC_)COVERTITLEs, so we define the appropriate strings and
.\"    registers from their (DOC_)COVER_TITLE equivalents.
.\"
.    if (\\n[#\\*[DOC_]COVER_TITLE]=6):(\\n[#\\*[DOC_]COVER_TITLE]=7) \{\
.       ds $\\*[DOC_]COVER_\\*[DOC_]COVERTITLE_FAM \
\\*[$\\*[DOC_]COVER_TITLE_FAM]
.       ds $\\*[DOC_]COVER_\\*[DOC_]COVERTITLE_FT \
\\*[$\\*[DOC_]COVER_TITLE_FT]
.       ds $\\*[DOC_]COVER_\\*[DOC_]COVERTITLE_COLOR \
\\*[$\\*[DOC_]COVER_TITLE_COLOR]
.       nr #\\*[DOC_]COVER_\\*[DOC_]COVERTITLE_COLOR \
\\n[#\\*[DOC_]COVER_TITLE_COLOR]
.       nr #\\*[DOC_]COVER_\\*[DOC_]COVERTITLE_CAPS  \
\\n[#\\*[DOC_]COVER_TITLE_CAPS]
.       nr #\\*[DOC_]COVER_\\*[DOC_]COVERTITLE_SMALLCAPS  \
\\n[#\\*[DOC_]COVER_TITLE_SMALLCAPS]
.       ds $\\*[DOC_]COVER_\\*[DOC_]COVERTITLE_LEAD  \
\\*[$\\*[DOC_]COVER_TITLE_LEAD]
.       ds $\\*[DOC_]COVER_\\*[DOC_]COVERTITLE_SIZE_CHANGE \
\\*[$\\*[DOC_]COVER_TITLE_SIZE_CHANGE]
.       nr #\\*[DOC_]COVER_\\*[DOC_]COVERTITLE_UNDERLINE \
\\n[#\\*[DOC_]COVER_TITLE_UNDERLINE]
.       nr #\\*[DOC_]COVER_\\*[DOC_]COVERTITLE_UNDERLINE_WEIGHT \
\\n[#\\*[DOC_]COVER_TITLE_UNDERLINE_WEIGHT]
.       nr #\\*[DOC_]COVER_\\*[DOC_]COVERTITLE_UNDERLINE_WEIGHT_ADJ \
\\n[#\\*[DOC_]COVER_TITLE_UNDERLINE_WEIGHT_ADJ]
.       ds $\\*[DOC_]COVER_\\*[DOC_]COVERTITLE_UNDERLINE_GAP \
\\*[$\\*[DOC_]COVER_TITLE_UNDERLINE_GAP]
.       ds $\\*[DOC_]COVER_\\*[DOC_]COVERTITLE_RULE_GAP \
\\*[$\\*[DOC_]COVER_TITLE_RULE_GAP]
.       ie \\n[#PRINT_STYLE]=1 \{\
.          CAPS
.          vs \\n[.v]u*2u
.          nr #ARG_NUM 0 1
.          while \\n[#\\*[DOC_]COVERTITLE_NUM]>=\\n+[#ARG_NUM] \{\
.             UNDERSCORE "\\*[$\\*[DOC_]COVERTITLE_\\n[#ARG_NUM]]"
.                if \\n[#ARG_NUM]>1 .as PDF_BM " \"
.                as PDF_BM \\*[$\\*[DOC_]COVERTITLE_\\n[#ARG_NUM]]
.          \}
.          vs
.          CAPS OFF
.       \}
.       el \{\
.          ds $PRFX \\*[DOC_]COVER
.          DO_TITLE
.          rm $PRFX
.       \}
.       PDF_BOOKMARK 1 \\*[$PDF_\\*[DOC_]COVER_LABEL] \\*[PDF_BM]
.    \}
.    ie !'\\*[DOC_]'' \
.       if !\\n[#DOC_COVER_TITLE] .PDF_BOOKMARK 1 Cover page
.    el \
.       if !\\n[#COVER_TITLE] .PDF_BOOKMARK 1 Title page
.    rr #\\*[DOC_]COVER_TITLE
.\" Subtitle
.    if \\n[#\\*[DOC_]COVER_SUBTITLE]=1 \{\
.       ie \\n[#PRINT_STYLE]=1 \{\
.          if !'\\*[$\\*[DOC_]COVER_SUBTITLE_1]'' \
.             ds $PRFX \\*[DOC_]COVER_
.          sp 2
.          nr #ARG_NUM 0 1
.          while \\n[#\\*[$PRFX]SUBTITLE_NUM]>=\\n+[#ARG_NUM] \{\
.             PRINT "\\*[$\\*[$PRFX]SUBTITLE_\\n[#ARG_NUM]]"
.          \}
.          rm $PRFX
.       \}
.       el \{\
.          ie !'\\*[$\\*[DOC_]COVER_SUBTITLE_1]'' .ds $PRFX \\*[DOC_]COVER_SUB
.          el .ds $PRFX SUB
.          if !'\\*[$\\*[DOC_]COVER_SUBTITLE_SPACER]'' \
.             sp \\*[$\\*[DOC_]COVER_SUBTITLE_SPACER]
.          DO_SUBTITLE
.          rm $PRFX
.       \}
.    \}
.    if \\n[#PRINT_STYLE]=1 \
.       if !r#\\*[DOC_]COVER_SUBTITLE .sp
.\" Author (plus attribution)
.    if \\n[#\\*[DOC_]COVER_AUTHOR]=1 \{\
.       ie \\n[#PRINT_STYLE]=1 \
.          sp
.       el \{\
.          ie !'\\*[$\\*[DOC_]COVER_AUTHOR_LEAD]'' \
.             vs \\*[$\\*[DOC_]COVER_AUTHOR_LEAD]
.          el .vs \\n[#\\*[DOC_]COVER_LEAD]u
.       \}
.       if '\\*[$\\*[DOC_]COVER_ATTRIBUTE_STRING]'' \
.          ds $\\*[DOC_]COVER_ATTRIBUTE_STRING \
              \\*[$ATTRIBUTE_STRING]
.       ie !\\n[#PRINT_STYLE]=1 \{\
.          fam \\*[$\\*[DOC_]COVER_ATTRIBUTE_FAM]
.          ft  \\*[$\\*[DOC_]COVER_ATTRIBUTE_FT]
.          ps \
\\n[#DOC_PT_SIZE]u\\*[$\\*[DOC_]COVER_ATTRIBUTE_SIZE_CHANGE]
.          if \\n[#\\*[DOC_]COVER_ATTRIBUTE_COLOR]=1 \
.             COLOR \\*[$\\*[DOC_]COVER_ATTRIBUTE_COLOR]
.          if \\n[#\\*[DOC_]COVER_ATTRIBUTE_CAPS]=1 .CAPS
.          if \\n[#\\*[DOC_]COVER_ATTRIBUTE_SMALLCAPS]=1 .SMALLCAPS
.          if !'\\*[$\\*[DOC_]COVER_ATTRIBUTE_SPACER]'' \
.             sp \\*[$\\*[DOC_]COVER_ATTRIBUTE_SPACER]
.          ie \\n[#\\*[DOC_]COVER_ATTRIBUTE_UNDERLINE] \{\
.             ds $TITLE_TYPE \\*[DOC_]COVER_ATTRIBUTE
.             ie \\n[#\\*[DOC_]COVER_ATTRIBUTE_UNDERLINE]=2 \
.                UNDERSCORE2 \\*[$\\*[DOC_]COVER_ATTRIBUTE_UNDERLINE_GAP] \
\\*[$\\*[DOC_]COVER_ATTRIBUTE_RULE_GAP] "\\*[$\\*[DOC_]COVER_ATTRIBUTE_STRING]"
.             el .UNDERSCORE \\*[$\\*[DOC_]COVER_ATTRIBUTE_STRING] 
.          \}
.          el .PRINT "\\*[$\\*[DOC_]COVER_ATTRIBUTE_STRING]"
.          SMALLCAPS off
.          CAPS off
.          if \\n[#\\*[DOC_]COVER_ATTRIBUTE_COLOR]=1 \
.             gcolor
.       \}
.       el \
.          PRINT "\\*[$\\*[DOC_]COVER_ATTRIBUTE_STRING]"
.       ie \\n[#PRINT_STYLE]=1 .sp
.       el \{\
.          if !'\\*[$\\*[DOC_]COVER_AUTHOR_SPACER]'' \
.             sp \\*[$\\*[DOC_]COVER_AUTHOR_SPACER]
.       \}
.       if '\\$0'COVER' \
.          ds $PRFX COVER_
.       if '\\$0'DOC_COVER' \
.          ds $PRFX DOC_COVER_
.       DO_AUTHORS
.       rm $PRFX
.    \}
.\" Named doctype string
.    if \\n[#DOC_TYPE]=3 \{\
.       if \\n[#\\*[DOC_]COVER_DOCTYPE]=1 \{\
.          ie \\n[#PRINT_STYLE]=1 \{\
.             TYPEWRITER
.             sp 1.5
.             UNDERSCORE2 3p 2p "\\*[$DOC_TYPE]
.          \}
.          el \{\
.             fam \\*[$\\*[DOC_]COVER_DOCTYPE_FAM]
.             ft  \\*[$\\*[DOC_]COVER_DOCTYPE_FT]
.             ps \
\\n[#DOC_PT_SIZE]u\\*[$\\*[DOC_]COVER_DOCTYPE_SIZE_CHANGE]
.             if \\n[#\\*[DOC_]COVER_DOCTYPE_COLOR]=1 \
.                COLOR \\*[$\\*[DOC_]COVER_DOCTYPE_COLOR]
.          sp
.          if \\n[#\\*[DOC_]COVER_DOCTYPE_CAPS]=1 .CAPS
.          if \\n[#\\*[DOC_]COVER_DOCTYPE_SMALLCAPS]=1 .SMALLCAPS
.          if !'\\*[$\\*[DOC_]COVER_DOCTYPE_SPACER]'' \
.             sp \\*[$\\*[DOC_]COVER_DOCTYPE_SPACER]
.          ie \\n[#\\*[DOC_]COVER_DOCTYPE_UNDERLINE] \{\
.             ds $TITLE_TYPE \\*[DOC_]COVER_DOCTYPE
.             ie \\n[#\\*[DOC_]COVER_DOCTYPE_UNDERLINE]=2 \
.                UNDERSCORE2 \\*[$\\*[DOC_]COVER_DOCTYPE_UNDERLINE_GAP] \
\\*[$\\*[DOC_]COVER_DOCTYPE_RULE_GAP] "\\*[$DOC_TYPE]"
.             el .UNDERSCORE "\\*[$DOC_TYPE]" 
.          \}
.          el .PRINT "\\*[$DOC_TYPE]"
.          SMALLCAPS off
.          CAPS off
.          if \\n[#\\*[DOC_]COVER_DOCTYPE_COLOR]=1 \
.             gcolor
.          \}
.       \}
.    \}
.\" Covertext
.    if \\n[#\\*[DOC_]COVERTEXT]=1 \{\
.       nr #DOING_COVERTEXT 1
.       if !\\n[#\\*[DOC_]COVERTEXT_START_POS] .sp
.       if \\n[#\\*[DOC_]COVERTEXT]=1 \{\
.          ev \\*[DOC_]COVERTEXT
.          nf
.          \\*[DOC_]COVER_TEXT
.          ev
.       \}
.       rr #\\*[DOC_]COVERTEXT
.       rm \\*[DOC_]COVER_TEXT
.       rr #DOING_COVERTEXT
.       rr #\\*[DOC_]COVERTEXT_START_POS
.    \}
.    sp |\\n[#VISUAL_B_MARGIN]u
.\" Copyright
.    ie \\n[#PRINT_STYLE]=1 \
.       if !\\n[#SINGLE_SPACE] .sp
.    el \{\
.       fam \\*[$\\*[DOC_]COVER_COPYRIGHT_FAM]
.       ft  \\*[$\\*[DOC_]COVER_COPYRIGHT_FT]
.       ps \\n[#DOC_PT_SIZE]u\\*[$\\*[DOC_]COVER_COPYRIGHT_SIZE_CHANGE]
.       nr #COPYRIGHT_V_POS \\n[#DOC_LEAD]-\\n[.v]
.       sp \\n[#COPYRIGHT_V_POS]u
.       rr #COPYRIGHT_V_POS
.    \}
.    if \\n[#\\*[DOC_]COVER_COPYRIGHT]=1 \{\
.       QUAD \\*[$\\*[DOC_]COVER_COPYRIGHT_QUAD]
.       if \\n[#\\*[DOC_]COVER_COPYRIGHT_COLOR]=1 \
.          COLOR \\*[$\\*[DOC_]COVER_COPYRIGHT_COLOR]
.       ie !'\\*[$COPYRIGHT_V_ADJ]'' \
.          PRINT \v'\\*[$COPYRIGHT_V_ADJ]'\\*[$\\*[DOC_]COVER_COPYRIGHT]
.       el \
.          PRINT \\*[$\\*[DOC_]COVER_COPYRIGHT]
.       if \\n[#\\*[DOC_]COVER_COPYRIGHT_COLOR]=1 \
.          gcolor
.    \}
.    sp |\\n[#VISUAL_B_MARGIN]u
.\" Misc
.    if \\n[#\\*[DOC_]COVER_MISC]=1 \{\
.       if \\n[#PRINT_STYLE]=2 \{\
.          fam \\*[$\\*[DOC_]COVER_MISC_FAM]
.          ft  \\*[$\\*[DOC_]COVER_MISC_FT]
.          ps \\n[#DOC_PT_SIZE]u\\*[$\\*[DOC_]COVER_MISC_SIZE_CHANGE]
.          vs \\*[$\\*[DOC_]COVER_MISC_LEAD]
.          if \\n[#\\*[DOC_]COVER_MISC_COLOR]=1 \
.             COLOR \\*[$\\*[DOC_]COVER_MISC_COLOR]
.       \}
.       ie !'\\*[$\\*[DOC_]COVER_MISC_1]'' \{\
.          QUAD \\*[$\\*[DOC_]COVER_MISC_QUAD]
.          da MISC_DIV
.          nr #NEXT_MISC 0 1
.          while \\n[#\\*[DOC_]COVER_MISC_LINES]>=\\n+[#NEXT_MISC] \{\
.             nop \\*[$\\*[DOC_]COVER_MISC_\\n[#NEXT_MISC]]
.             br
.          \}
.          da
.       \}
.       el \{\
.          QUAD \\*[$MISC_QUAD]
.          da MISC_DIV
.          nr #NEXT_MISC 0 1
.          while \\n[#MISC_LINES]>=\\n+[#NEXT_MISC] \{\
.             nop \\*[$MISC_\\n[#NEXT_MISC]]
.             br
.          \}
.          da
.       \}
.       nr #MISC_V_ADJ \\n[#DOC_LEAD]-\\n[.v]
.       sp \\n[#MISC_V_ADJ]u
.       sp -\\n[dn]u+1
.       nf
.       MISC_DIV
.       if \\n[#MISC_COLOR]=1 .gcolor
.       if \\n[#\\*[DOC_]COVER_MISC_COLOR]=1 .gcolor
.       rm MISC_DIV
.       rr #MISC_DEPTH
.    \}
.    if \\n[TOC.RELOCATE]==1 \{\
.       if !\\n[#COVER_BLANKPAGE] \
.          if !rTOC_BH .TOC_AFTER_HERE
.    \}
.    if '\\$0'DO_COVER' \{\
.       if \\n[TOC.RELOCATE]==6 \
.          if !rTOC_BH .TOC_AFTER_HERE
.    \}
.    if '\\$0'DO_DOC_COVER' \{\
.       if \\n[TOC.RELOCATE]==4 \
.          if !rTOC_BH .TOC_AFTER_HERE
.    \}
.    if '\\$0'DO_DOC_COVER' .rm DOC_
.    END_COVER
.END
\#
\# Macro to terminate (doc)cover processing
\#
.MAC END_COVER END
.    EOL
.    vpt
.    if '\\*[$COVER_TYPE]'DOC_COVER_' .ds DOC DOC
.    rm $COVER_TYPE
.    if \\n[#DOC_TYPE]=5 .nr #SKIP 1
.    nr #END_COVER 1
.    NEWPAGE
.    rr #NEWPAGE
.    rr #SKIP
.    if \\n[#PAGINATION_WAS_ON]=1 .nr % +1
.    ie \\n[#\\*[DOC]COVER_BLANKPAGE]=1 \{\
.       if \\n[TOC.RELOCATE] \
.          if !\\n[#TOC_BH] .TOC_AFTER_HERE
.\" Without the empty PDF_BOOKMARK, (doc)cover BLANKPAGE causes
.\" the PDF outline to place the first doc or chapter before the TOC,
.\" even though PDF output is correct.
.       PDF_BOOKMARK 1
.       nop \&
.       bp
.       rr #\\*[DOC]COVER_BLANKPAGE
.       if !\\n[#\\*[DOC]COVERS_COUNT]=1 .nr % -2
.    \}
.    el \
.       if !\\n[#\\*[DOC]COVERS_COUNT]=1 .nr #PAGE_NUM_ADJ -1
.    if !'\\n[.ev]'0' .ev
.    if \\n[#PAGINATION_WAS_ON] \{\
.       rr #PAGINATION_WAS_ON
.       PAGINATE
.       PAGENUMBER \\n%+\\n[#PAGE_NUM_ADJ]-1
.    \}
.    if \\n[#HEADERS_WERE_ON] \{\
.       rr #HEADERS_WERE_ON
.       HEADERS
.    \}
.    if \\n[#FOOTERS_WERE_ON] \{\
.       rr #FOOTERS_WERE_ON
.       FOOTERS
.    \}
.    if \\n[#COLUMNS_WERE_ON]=1 \{\
.       rr #COLUMNS_WERE_ON 1
.       nr #COLUMNS 1
.    \}
.    rr #DOING_COVER
.    if \\n[.ns] .nop \&
.    if \\n[#RECTO_VERSO] .nr #RV_POST_COVER 1
.END
\#
\# +++START THE DOCUMENT+++
\#
\# THE START MACRO
\# ---------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Macro to start document processing.  Reads in default document
\#   style parameters and any parameters the user has changed before
\#   issuing START.  Using the information gathered in the opening
\#   macros, prints appropriate title (or chapter #), subtitle,
\#   author and document type (if appropriate).
\# *Notes:
\#   The .PRINT \& (zero-width character) is required to get the
\#   subsequent .sp request to work as advertised.
\#
\#   The overall document line length, family, and point-size
\#   are stored in #DOC_L_LENGTH, $DOC_FAM, and #DOC_PT_SIZE for
\#   use in the HEADER and FOOTER macros.
\#
.MAC START END
.    nr #DOCS 1
.    if \\n[TOC.RELOCATE]==2 \
.       if !\\n[TOC_BH] .TOC_BEFORE_HERE
.    if !n .nop \X'ps: exec 0 setlinejoin'\X'ps: exec 0 setlinecap'
.    if !\\n[#PRINT_STYLE] \{\
.       PRINTSTYLE TYPEWRITE
.       PRINT \&
.       po 6P
.       ll 39P
.       ta \\n[.l]u
.       sp |1i-1v
.       CENTER
.       PRINT "You neglected to enter a PRINTSTYLE."
.       ab [mom]: PRINTSTYLE missing.  Aborting '\\n[.F]'.
.    \}
.    if \\n[#LINENUMBERS]=1 \{\
.       nm
.       NUMBER_LINES OFF
.       nr #LINENUMBERS 2
.    \}
.    if \\n[#COLLATE] \{\
.       COPYSTYLE \\*[$COPY_STYLE]
.       nr #HEADERS_ON \\n[#HEADER_STATE]
.       if \\n[#PAGE_NUM_V_POS]=1 .nr #PAGINATE \\n[#PAGINATION_STATE]
.       PRINT \&
.       if !'\\*[$RESTORE_PAGENUM_STYLE]'' \{\
.          PAGENUM_STYLE \\*[$RESTORE_PAGENUM_STYLE]
.          rm $RESTORE_PAGENUM_STYLE
.       \}
.       if \\n[#PAGINATE_WAS_ON] \{\
.          PAGINATE
.          rr #PAGINATE_WAS_ON
.       \}
.    \}
.    DEFAULTS
.    nr #PAGE_TOP \\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.    rr #RESET_TRAPS
.    if !r#EN_Q_AUTOLEAD  .nr #EN_Q_LEAD \\n[#EN_LEAD]
.    if !r#EN_BQ_AUTOLEAD .nr #EN_BQ_LEAD \\n[#EN_LEAD]
.\"  TOC/recto-verso stuff
.    nr @L_MARGIN \\n[#DOC_L_MARGIN]
.    nr @R_MARGIN \\n[#DOC_R_MARGIN]
.\" Covers and doc covers
.    if \\n[#DOC_COVERS]=1 \
.       if \\n[#DOC_COVER]=1 .DO_DOC_COVER
.    if \\n[#COVERS]=1 \
.       if \\n[#COVER]=1 .DO_COVER
.    nr PDFHREF.VIEW.LEADING \\n[PDFHREF.VIEW.LEADING.T]
.    if !\\n[#TOC] .RV_HARD_SET_MARGINS
.    if \\n[#COLUMNS] .COLUMNS \\n[#NUM_COLS] \\n[#GUTTER]u
.    sp |\\n[#DOCHEADER_ADVANCE]u-\\n[#DOC_LEAD]u
.\" Collect TITLE for TOC.
.    if !\\n[#TOC]=1 \{\
.       nr #TOC_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.       af #TOC_ENTRY_PN \\g[#PAGENUMBER]
.       ie \\n[#USER_SET_TITLE_ITEM] \{\
.          ds $TOC_TITLE_ITEM \\*[$USER_SET_TITLE_ITEM]
.          rr #USER_SET_TITLE_ITEM
.          rm $USER_SET_TITLE_ITEM
.       \}
.       el \{\
.          ie \\n[#DOC_TYPE]=2 \{\
.             ie '\\*[$CHAPTER_TITLE]'' \
.                ds $TOC_TITLE_ITEM \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.             el \{\
.                ie '\\*[$CHAPTER]'' \
.                   ds $TOC_TITLE_ITEM \\*[$CHAPTER_TITLE]
.                el \
.                   ds $TOC_TITLE_ITEM \
\\*[$CHAPTER_STRING] \\*[$CHAPTER]: \\*[$CHAPTER_TITLE]
.             \}
.          \}
.          el \
.             ds $TOC_TITLE_ITEM \\*[$TITLE]
.       \}
.       if \\n[#TOC_AUTHORS]=1 \{\
.          ie '\\*[$TOC_AUTHORS]'' \
.             as $TOC_TITLE_ITEM / \\*[$AUTHOR_1]
.          el \{\
.             as $TOC_TITLE_ITEM / \\*[$TOC_AUTHORS]
.             rm $TOC_AUTHORS
.          \}
.       \}
.       as $TOC_TITLE_ITEM \|
.       if \\n[#PREFIX_CH_NUM] \
.          ds $TOC_CH_NUM \
              \\n[#CH_NUM].\[toc-hd-num-spacer]
.       if \\n[#TOC_PREFIX_CH_NUM] \{\
.          rn $TOC_TITLE_ITEM $TOC_TITLE_ITEM_OLD
.          ds $TOC_CH_NUM \
              \\n[#CH_NUM].\[toc-hd-num-spacer]
.          if (\\n[#PAD_TOC_CH_NUM]=2)&(\\n[#CH_NUM]<10) \
.                ds $TOC_CH_NUM \h'\w'\0'u'\\*[$TOC_CH_NUM]
.          if \\n[#PAD_TOC_CH_NUM]=3 \{\
.             if \\n[#CH_NUM]<10 \
.                ds $TOC_CH_NUM \h'\w'\0'u*2u'\\*[$TOC_CH_NUM]
.             if (\\n[#CH_NUM]>=10)&(\\n[#CH_NUM]<100) \
.                ds $TOC_CH_NUM \h'\w'\0'u'\\*[$TOC_CH_NUM]
.          \}
.          if \\n[#PAD_TOC_CH_NUM]=4 \{\
.             if \\n[#CH_NUM]<10 \
.                ds $TOC_CH_NUM \h'\w'\0'u*3u'\\*[$TOC_CH_NUM]
.             if (\\n[#CH_NUM]>=10)&(\\n[#CH_NUM]<100) \
.                ds $TOC_CH_NUM \h'\w'\0'u*2u'\\*[$TOC_CH_NUM]
.             if (\\n[#CH_NUM]>=100)&(\\n[#CH_NUM]<1000) \
.                ds $TOC_CH_NUM \h'\w'\0'u'\\*[$TOC_CH_NUM]
.          \}
.          ds $TOC_TITLE_ITEM \\*[$TOC_CH_NUM]\\*[$TOC_TITLE_ITEM_OLD]
.          rm $TOC_TITLE_ITEM_OLD
.       \}
.    \}
.    if !\\n[#TOC] \{\
.       if !'\\*[$TOC_TITLE_ITEM]'' \{\
.          PDF_BOOKMARK 1 \\*[$TOC_TITLE_ITEM]
.          TITLE_TO_TOC
.       \}
.    \}
.    if !\\n[#TOC] .nr #POST_TOP 1
.\" End TITLE collection
.    if \\n[#PRINT_PAGENUM_ON_PAGE_1] \{\
.       if \\n[#PAGE_NUM_V_POS]=1 \{\
.          br
.          sp |\\n[#HEADER_MARGIN]u
.          PRINT_PAGE_NUMBER
.       \}
.    \}
.    rr #COLLATE
.    rr #PAGINATION_STATE
.\" End collate stuff
.    sp |\\n[#DOCHEADER_ADVANCE]u-\\n[#DOC_LEAD]u
.    ie \\n[#DOC_HEADER]=0 \{\
.       if \\n[.ns] .rs
.       if \\n[#DOC_TYPE]=4 \
.          if !'\\n[.z]'' .di
.       nr #STORED_PP_INDENT \\n[#PP_INDENT]
.       PARA_INDENT 0
.       PP
.       PARA_INDENT \\n[#STORED_PP_INDENT]u
.       rr #STORED_PP_INDENT
.       ie r#ADVANCE_FROM_TOP \{\
.          br
.          sp |\\n[#ADVANCE_FROM_TOP]u-1v
.          if \\n[#ADJ_DOC_LEAD]=1 \
.             if !\\n[#DOCHEADER_NO_SHIM] .SHIM_1
.       \}
.       el \{\
.          br
.          sp |\\n[#T_MARGIN]u-1v
.       \}
.       if \\n[#COLUMNS] \{\
.          mk dc
.          nr #COL_NUM 0 1
.          po \\n[#COL_\\n+[#COL_NUM]_L_MARGIN]u
.          nr #L_MARGIN \\n[.o]
.          ll \\n[#COL_L_LENGTH]u
.       \}
.       nr #PP 0
.    \}
.    el \{\
.       if \\n[#AUTO_LEAD] .nr #RESTORE_AUTO_LEAD 1
.       nr #CURRENT_LEAD \\n[.v]
.       if \\n[#PRINT_STYLE]=2 .vs \\n[#DOC_LEAD]u\\*[$DOCHEADER_LEAD_ADJ]
.       nr #DOCHEADER_LEAD_DIFF \\n[#CURRENT_LEAD]-\\n[.v]
.       sp +\\n[#DOCHEADER_LEAD_DIFF]u
.       if \\n[#RESTORE_AUTO_LEAD] \{\
.          nr #AUTO_LEAD 1
.          nr #AUTOLEAD_VALUE  \\n[#SAVED_AUTOLEAD_VALUE]
.       \}
.       nr #DOCHEADER_LEAD \\n[.v]
.       vpt 0
.\" Default doctype
.       if \\n[#DOC_TYPE]=1 \{\
.          if \\n[.ns] \{\
.             rs
.             nop \&
.             sp -1
.          \}
.          ev DOCHEADER
.          evc 0
.          L_MARGIN \\n[#DOC_L_MARGIN]u
.          LL       \\n[#DOC_L_LENGTH]u
.          ta \\n[.l]u
.          if \\n[#PRINT_STYLE]=1 .DEFAULT_DOCHEADER_TYPEWRITE
.          if \\n[#PRINT_STYLE]=2 .DEFAULT_DOCHEADER
.          ev
.       \}
.\" Chapter doctype
.       if \\n[#DOC_TYPE]=2 \{\
.          if \\n[.ns] .rs
.          ev DOCHEADER
.          evc 0
.          if \\n[#DOCHEADER_COLOR]=1 \
.             COLOR \\*[$DOCHEADER_COLOR]
.          L_MARGIN \\n[#DOC_L_MARGIN]u
.          LL       \\n[#DOC_L_LENGTH]u
.          ta \\n[.l]u
.          if \\n[#PRINT_STYLE]=1 .CHAPTER_DOCHEADER_TYPEWRITE
.          if \\n[#PRINT_STYLE]=2 .CHAPTER_DOCHEADER
.          ev
.       \}
.\" Named
.       if \\n[#DOC_TYPE]=3 \{\
.          if \\n[.ns] \{\
.             rs
.             nop \&
.             sp -1
.          \}
.          ev DOCHEADER
.          evc 0
.          if \\n[#DOCHEADER_COLOR]=1 \
.             COLOR \\*[$DOCHEADER_COLOR]
.          L_MARGIN \\n[#DOC_L_MARGIN]u
.          LL       \\n[#DOC_L_LENGTH]u
.          ta \\n[.l]u
.          if \\n[#PRINT_STYLE]=1 \{\
.             DEFAULT_DOCHEADER_TYPEWRITE
.             if !\\n[#NO_PRINT_DOCTYPE] \{\
.                sp
.                UNDERSCORE2 3p 2p "\\*[$DOC_TYPE]"
.             \}
.          \}
.          if \\n[#PRINT_STYLE]=2 .NAMED_DOCHEADER
.          ev
.       \}
.       if !\\n[#DOC_TYPE]=4 \{\
.          if \\n[#PRINT_STYLE]=1 .sp
.          if \\n[#PRINT_STYLE]=2 .sp \\n[#DOC_LEAD]u*2u
.          if \\n[#COLUMNS] \{\
.             nr #COL_NUM 0 1
.             nr #L_LENGTH_FOR_EPI \\n[#L_LENGTH]
.             ie \\n[#RV_POST_COVER] \{\
.                nr #COL_\\n+[#COL_NUM]_L_MARGIN \\n[#DOC_L_MARGIN]
.                po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.                nr #L_MARGIN \\n[.o]
.                rr #RV_POST_COVER
.             \}
.             el \{\
.                po \\n[#COL_\\n+[#COL_NUM]_L_MARGIN]u
.                nr #L_MARGIN \\n[.o]
.             \}
.             LL \\n[#COL_L_LENGTH]u
.             ta \\n[.l]u
.          \}
.       \}
.       nr #NO_PRINT_AUTHOR  1
.       nr #NO_PRINT_DOCTYPE 1
.    \}
.    vs \\n[#DOC_LEAD]u
.    if \\n[#PRINT_STYLE]=1 \
.       if \\n[#SINGLE_SPACE]=1 .sp
.    if \\n[#ADJ_DOC_LEAD]=1 \
.       if \\n[#ADVANCE_FROM_TOP]=0 \
.          if \\n[#DOC_HEADER]=1 \
.             if !\\n[#DOCHEADER_NO_SHIM] .SHIM_1
.    if \\n[#COLUMNS] .mk dc
.    FAMILY \\*[$DOC_FAM]
.    QUAD \\*[$DOC_QUAD]
.    CLEANUP_DEFAULTS
.    nr #START_FOR_FOOTERS 1
.    if !\\n[#DOC_TYPE]=4 .em TERMINATE
.    if \\n[#LINENUMBERS]=2 \{\
.       ie \\n[#PER_SECTION] .NUMBER_LINES 1
.       el .NUMBER_LINES RESUME
.       nr #LINENUMBERS 1
.    \}
.    if \\n[#RUN_ON]=1 \{\
.       if \\n[#FN_MARKER_STYLE]=1 .RUNON_WARNING
.       if \\n[#FN_MARKER_STYLE]=2 .RUNON_WARNING
.    \}
.    nr PDFHREF.VIEW.LEADING \\n[PDFHREF.VIEW.LEADING.H]
.    vpt
.    if !r flex .nr flex 1
.    nr flex-spaces 0
.\" If one-page, don't flex.
.    if !dPDF.EXPORT \{\
.       if \\n[#FLEX_ACTIVE] \{\
.          if !\\n[#NO_FLEX] \{\
.             if d pre-toc-\\n%@\\n[#COL_NUM] \
.                nr #NO_FLEX 1
.             if d pre-list-\\n%@\\n[#COL_NUM] \
.                nr #NO_FLEX 1
.             if d page-\\n%@\\n[#COL_NUM] \
.                nr #NO_FLEX 1
.             if '\\*[last-page]'\\n%@\\n[#COL_NUM]' \
.                nr #NO_FLEX 1
.          \}
.       \}
.    \}
.    if \\n[#DOC_TYPE]=5 \{\
.       if \\n[#HDRFTR_BOTH] \
.          HEADER_RECTO \\*[$HDR_RECTO_QUAD] "\\*[$HDR_RECTO_STRING]"
.       if \\n[#SLIDE_HEADERS] .HEADER
.       if \\n[#HDRFTR_BOTH] \
.          FOOTER_RECTO \\*[$FTR_RECTO_QUAD] "\\*[$FTR_RECTO_STRING]"
.       if \\n[#SLIDE_FOOTERS] \
.          PRINT_FOOTER
.       sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.       vpt
.    \}
.END
\#
.MAC RR_ADVANCE_FROM_TOP END
.    rr #ADVANCE_FROM_TOP
.    ch RR_ADVANCE_FROM_TOP
.END
\#
.MAC CLEANUP_DEFAULTS END
.    nr #START 1
.    if \\n[#DOC_HEADER]=1 .nr #DOC_HEADER 2
.    rm $TOC_TITLE_ITEM
.    rr #MISC_NUM
.    rr #MISCS
.    rr #NEXT_AUTHOR
.    rr #NEXT_MISC
.    wh \\n[nl]u+1u RR_ADVANCE_FROM_TOP
.    rr #DOCHEADER_NO_SHIM
.END
\#
\# ====================================================================
\#
\# +++MACROS TO CHANGE SOME DEFAULTS+++
\#
\# DOCUMENT HEADER
\# ---------------
\# *Argument:
\#   <none> | <anything> [distance to advance from top of page] [NO_SHIM]
\# *Function:
\#   Turns printing of document header on or off.  If a second
\#   numeric argument with units of measure is given, advances that
\#   distance from the top of the page without printing the document
\#   header.
\# *Notes:
\#   Default is on.  If the 1st argument is <anything> (which turns
\#   document headers off), the optional 2nd argument may be given
\#   (with a unit of measure).
\#
.MAC DOCHEADER END
.    if \\n[#NUM_ARGS]=0 .nr #DOC_HEADER 1
.    if \\n[#NUM_ARGS]=1 \{\
.       ie '\\$1'NO_SHIM' .nr #DOCHEADER_NO_SHIM 1
.       el .nr #DOC_HEADER 0
.    \}
.    if \\n[#NUM_ARGS]>1 \{\
.       nr #DOC_HEADER 0
.       if \B'\\$2' .nr #ADVANCE_FROM_TOP \\$2
.       if '\\$3'NO_SHIM' .nr #DOCHEADER_NO_SHIM 1
.    \}
.END
\#
\# DOCUMENT HEADER LEADING
\# -----------------------
\# *Arguments:
\#   <+|- amount by which to in/decrease leading of doc header>
\# *Function:
\#   Stores user supplied lead in/decrease in string $DOCHEADER_LEAD_ADJ.
\# *Notes:
\#   A unit of measure must be supplied.  Decimal fractions OK.
\#   Default is +0, i.e. same as DOC_LEAD.
\#
.MAC DOCHEADER_LEAD END
.    ds $DOCHEADER_LEAD_ADJ \\$1
.END
\#
\# DOCHEADER ADVANCE
\# -----------------
\# *Arguments:
\#   <docheader start position>
\# *Function:
\#   Creates register #DOCHEADER_ADVANCE, used in START.
\# *Notes:
\#   Unit of measure required.
\#   Default is same as T_MARGIN.
\#
.MAC DOCHEADER_ADVANCE END
.    nr #DOCHEADER_ADVANCE \\$1
.END
\#
\# DOCUMENT LEFT MARGIN
\# --------------------
\# *Argument:
\#   <left margin of document>
\# *Function:
\#   Creates or modifies register #DOC_L_MARGIN.
\# *Notes:
\#   Affects everything on the page.
\#
.MAC DOC_LEFT_MARGIN END
.    if !\\n[#DOCS] .DOC_MACRO_ERROR \\$0
.    br
.    nr #DOC_L_MARGIN (\\$1)
.    L_MARGIN \\n[#DOC_L_MARGIN]u
.END
\#
\# DOCUMENT RIGHT MARGIN
\# ---------------------
\# *Argument:
\#   <right margin of document>
\# *Function:
\#   Creates or modifies register #DOC_R_MARGIN.
\# *Notes:
\#   Affects everything on the page.
\#
.MAC DOC_RIGHT_MARGIN END
.    br
.    nr #DOC_R_MARGIN (\\$1)
.    R_MARGIN \\n[#DOC_R_MARGIN]
.    nr #DOC_L_LENGTH \\n[#L_LENGTH]
.END
\#
\# DOCUMENT LINE LENGTH
\# --------------------
\# *Argument:
\#   <line length of document>
\# *Function:
\#   Creates or modifies register #DOC_L_LENGTH.
\# *Notes:
\#   Affects everything on the page.
\#
.MAC DOC_LINE_LENGTH END
.    if !\\n[DOCS] .DOC_MACRO_ERROR \\$0
.    br
.    nr #DOC_L_LENGTH (\\$1)
.    LL \\n[#DOC_L_LENGTH]u
.    ta \\n[.l]u
.END
\#
\# DOCUMENT FAMILY
\# ---------------
\# *Argument:
\#   <family of running text>
\# *Function:
\#   Creates or modifies string $DOC_FAM.
\# *Notes:
\#   Affects everything except headers and footers.
\#
.MAC DOC_FAMILY END
.    if !\\n[DOCS] .DOC_MACRO_ERROR \\$0
.    br
.    ds $DOC_FAM \\$1
.    ds $FAMILY  \\*[$DOC_FAM]
.    AUTHOR_FAMILY     \\*[$DOC_FAM]
.    BLOCKQUOTE_FAMILY \\*[$DOC_FAM]
.    DOCHEADER_FAMILY  \\*[$DOC_FAM]
.    DOCTYPE_FAMILY    \\*[$DOC_FAM]
.    EPIGRAPH_FAMILY   \\*[$DOC_FAM]
.    FOOTNOTE_FAMILY   \\*[$DOC_FAM]
.    HDRFTR_FAMILY     \\*[$DOC_FAM]
.    LINENUMBER_FAMILY \\*[$DOC_FAM]
.    QUOTE_FAMILY      \\*[$DOC_FAM]
.    SUBTITLE_FAMILY   \\*[$DOC_FAM]
.    TITLE_FAMILY      \\*[$DOC_FAM]
.END
\#
\# DOCUMENT POINT SIZE
\# -------------------
\# *Argument:
\#   <point size of running text>
\# *Function:
\#   Creates or modifies register #DOC_PT_SIZE.
\# *Notes:
\#   DOC_PT_SIZE is the basis for calculating all type sizes in
\#   a document.  Ignored if PRINTSTYLE TYPEWRITE.
\#
.ALIAS DOC_PT_SIZE PT_SIZE
\#
\# DOCUMENT LEAD
\# -------------
\# *Argument:
\#   <lead (".vs") of running text> [ADJUST]
\# *Function:
\#   Creates or modifies register #DOC_LEAD.  If the optional
\#   ADJUST argument is given, adjusts leading so that the last
\#   line of text falls exactly on #B_MARGIN.
\# *Notes:
\#   DOC_LEAD is the basis for calculating all leading changes in
\#   a document.  Default for TYPESET is 16; 24 for TYPEWRITE.
\#
\#   Because the visible bottom or footer margin of a page depends
\#   on the overall document lead supplied by the register #DOC_LEAD,
\#   DOC_LEAD, in the body of a document, should always be associated
\#   with the start of a new page (in other words, just before or
\#   just after a manual NEWPAGE).  Ignored if PRINTSTYLE TYPEWRITE.
\#
.MAC DOC_LEAD END
.    if \\n[#IGNORE] .return
.    if !\\n[#DOCS] .DOC_MACRO_ERROR \\$0
.    br
.    if '\\$0'DOC_LEAD' \{\
.       vs \\$1
.       rr #DOC_AUTOLEAD
.       rr #DOC_AUTOLEAD_FACTOR
.       nr #DOC_LEAD \\n[.v]
.    \}
.    nr #RESET_TRAPS 1
.    if !\\n[#ADJ_DOC_LEAD] .nr #REMOVE_ADJ 1
.    if !'\\$0'DOC_LEAD' \{\
.       if '\\$0'EN_LEAD'  .nr #DOC_LEAD \\n[#EN_LEAD]
.       if '\\$0'BIB_LEAD' .nr #DOC_LEAD \\n[#BIB_LEAD]
.       if '\\$0'TOC_LEAD' .nr #DOC_LEAD \\n[#TOC_LEAD]
.       if '\\$2'ADJUST'   .TRAPS
.       rr #RESET_TRAPS
.    \}
.END
\#
\# ADJUST DOCUMENT LEAD
\# --------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Adjusts document lead so that the last line of text falls exactly
\#   on #B_MARGIN.
\#
.MAC DOC_LEAD_ADJUST END
.    ie '\\$1'' \{\
.       nr #ADJ_DOC_LEAD 1
.       rr #DOC_LEAD_ADJUST_OFF
.    \}
.    el \{\
.       nr #ADJ_DOC_LEAD 0
.       nr #DOC_LEAD_ADJUST_OFF 1
.    \}
.END
\#
\# SHIM
\# ----
\# *Argument:
\#   None
\# *Function:
\#   Advances to the next valid baseline.
\# *Notes:
\#   If a user plays around with spacing in a doc (say, with ALD),
\#   it isn't easy to get mom back on track so she can achieve
\#   perfectly flush bottom margins.  Any time SHIM is used, it
\#   ensures that the next output line falls on a valid baseline.
\#
\# First, a little convenience macro
\#
.MAC PROCESS_SHIM END
.    if !\\n[nl]=\\n[#VALID_BASELINE] \{\
.       while \\n+[#VALID_BASELINE]<\\n[#CURRENT_V_POS] .
.       nr #SHIM \\n[#VALID_BASELINE]-\\n[#CURRENT_V_POS]
.    \}
.END
\#
\# And a macro to disable SHIM
\#
.MAC NO_SHIM END
.    ie '\\$1'' \{\
.       nr #NO_SHIM 1
.       nr #FLEX_ACTIVE 1
.    \}
.    el \{\
.       rr #NO_SHIM
.       rr #SHIM
.       rr #FLEX_ACTIVE 1
.   \}
.END
\#
.nr #NO_SHIM 2 \" Restored to 1 in DEFAULTS.
\#
.MAC SHIM END
.    if \\n[#NO_SHIM] \
.       if !'\\$0'SHIM_1' .return
.    if !\\n[#NO_FLEX] \{\
.       if !'\\$0'SHIM_1' \{\
.          tm1 "[mom]: 
SHIM, line \\n[.c], is incompatible with flex-spacing, which is enabled.
.          tm1 "       
Flex-spacing must be disabled with NO_FLEX before using SHIM.
.          ab [mom]: Aborting '\\n[.F]', line \\n[.c].
.       \}
.    \}
.    nr #VALID_BASELINE \\n[#T_MARGIN]-\\n[#DOC_LEAD] \\n[#DOC_LEAD]
.    if !r#CURRENT_V_POS .nr #CURRENT_V_POS \\n[.d]
.    ie \\n[#ADVANCE_FROM_TOP] \{\
.       ie \\n[#CURRENT_V_POS]<(\\n[#T_MARGIN]-1v) \{\
.          while \\n-[#VALID_BASELINE]>\\n[#CURRENT_V_POS] .
.          nr #VALID_BASELINE +\\n[#DOC_LEAD]
.          nr #SHIM \\n[#VALID_BASELINE]-\\n[#CURRENT_V_POS]
.       \}
.       el .PROCESS_SHIM
.    \}
.    el .PROCESS_SHIM
.    nr #SHIM_MAX \\n[#DOC_LEAD]*10/15
.    if !\\n[#CALCULATE_ONLY] \{\
.       if !\\n[defer-count] \
.          if \\n[#SHIM]>\\n[#SHIM_MAX] .sp -1
'          sp \\n[#SHIM]u
.       \}
.    rr #CURRENT_V_POS
.END
\#
.ALIAS SHIM_1 SHIM
\#
\# ====================================================================
\#
\# +++FLEX SPACING+++
\#
\# INSERT FLEX SPACE
\# -----------------
\# *Arguments:
\#   FORCE
\# *Function:
\#   Inserts flexible whitespace ("flex-space").
\# *Notes:
\#   FORCE restores flex-spacing if an .ns is preventing it.
\#   Useful in conjunction with deferred floated material that
\#   plants an .ns after outputting the last deferred float.
\#
.MAC FLEX END
.    if !\\n[#NO_SHIM] \{\
.       if \\n[#NO_FLEX] \{\
.          tm1 "[mom]: \
FLEX, line \\n[.c], is incompatible with shimming, which is presently enabled.
.          tm1 "       \
Shimming must be disabled with NO_SHIM before using FLEX.
.          ab   [mom]: Aborting '\\n[.F]', line \\n[.c].
.       \}
.    \}
.    if '\\$1'FORCE' \{\
.       nr flex:force 1
.       return
.    \}
.    if !\\n[#NO_FLEX] \{\
.       if !\\n[.ns] \{\
.          if !\\n[.t]<=\\n[.v] \{\
.             nr flex-spaces +1
.             if dflex-space:\\n[flex]@\\n[#COL_NUM] \{\
.                sp \\*[flex-space:\\n[flex]@\\n[#COL_NUM]]
.             \}
.          \}
.       \}
.    \}
.END
\#
.MAC NO_FLEX END
.    rr flexed
.    ie '\\$1'' \{\
.       nr #NO_FLEX 1
.       if \\n[#FLEX_ACTIVE] .rr #FLEX_ACTIVE
.    \}
.    el \
.       if !\\n[#DOC_TYPE]=5 .rr #NO_FLEX
.END
\#
\# CALCULATE FLEX SPACES
\# ---------------------
\# *Function:
\#   Derives flex-space size by dividing the space remaining before
\#   FOOTER by the number of times FLEX was used on the page/col.
\# *Notes:
\#   .h is reliable for determining space remaining, but can't be used
\#   for columns because it can't be zeroed from one col to the
\#   next.  Workaround is to use nl for columns and compensate for
\#   .br's, .sp's, and .ne's.  Here be dragons.
\#
.MAC CALCULATE_FLEX END
.    nr flex:target-pos \\n[.p]+\\n[#VARIABLE_FOOTER_POS]-1
.    nr flex:current-pos \\n[.h]-\\n[.v]
.    if \\n[#COLUMNS] \{\
.       ie \\n[.trunc] \
.          nr flex:current-pos \\n[nl]-\\n[.v]-(\\n[.trunc]-1)
.       el .nr flex:current-pos \\n[nl]-\\n[.v]
.       if '\\n[.ev]'tbl*end' \{\
.          nr flex:current-pos \\n[nl]-(\\n[.trunc]-1)
.          if \\n[tbl*boxed] .nr flex:current-pos -.65v
.       \}
.       ie \\n[nl-from-heading] \{\
.          nr flex:current-pos \\n[nl-from-heading]-\\n[.v]
.          rr nl-from-heading
.       \}
.       el \{\
.          if !\\n[.pe] \{\
.             if \\n[nl]=(\\n[.p]+(\\n[#VARIABLE_FOOTER_POS]-1)) \
.                nr flex-spaces -1
.          \}
.       \}
.    \}
.    nr flex:space-remaining \
        \\n[flex:target-pos]-\\n[flex:current-pos]
.    if \\n[flex-spaces] \{\
.       nr flex-space:\\n[flex]@\\n[#COL_NUM] \
           \\n[flex:space-remaining]/\\n[flex-spaces]
.       if dPDF.EXPORT \{\
.          tm .ds flex-space:\\n[flex]@\\n[#COL_NUM] \
              \\n[flex-space:\\n[flex]@\\n[#COL_NUM]]u
.\" For debugging: catch edge-cases that result in negative
.\" flex-spacing and don't apply flex to the page/column.
.          if \\n[flex-space:\\n[flex]@\\n[#COL_NUM]]<0 \{\
.             tm .ds flex-space:\\n[flex]@\\n[#COL_NUM] 0
.             tm .ds Negative flex space \\n%@\\n[#COL_NUM] (\\n[flex-space:\\n[flex]@\\n[#COL_NUM]])
.          \}
.       \}
.    \}
.END
\#
\# ====================================================================
\#
\# +++INTERNATIONALIZATION+++
\#
\# ATTRIBUTE STRING
\# ----------------
\# *Argument:
\#   <what goes in the "by" slot before author in the document header>
\# *Function:
\#   Creates or modifies string $ATTRIBUTE_STRING.
\# *Notes:
\#   Default is "by".  A blank string ("") may be used if no
\#   attribution is desired.  Blank line results.
\#
.MAC ATTRIBUTE_STRING END
.    if !'\\$1'DOC_COVER' \
.       if !'\\$1'COVER' .nr #NEITHER 1
.    if !'\\$1'COVER' \
.       if !'\\$1'DOC_COVER' .nr #NEITHER 1
.    if '\\$1'DOC_COVER' \{\
.       ds $DOC_COVER_ATTRIBUTE_STRING \\$2
.       if '\\*[$DOC_COVER_ATTRIBUTE_STRING]'' \
.          ds $DOC_COVER_ATTRIBUTE_STRING \&
.    \}
.    if '\\$1'COVER' \{\
.       ds $COVER_ATTRIBUTE_STRING \\$2
.       if '\\*[$COVER_ATTRIBUTE_STRING]'' \
.          ds $COVER_ATTRIBUTE_STRING \&
.    \}
.    if \\n[#NEITHER]=1 \{\
.       ds $ATTRIBUTE_STRING \\$1
.       rr #NEITHER
.    \}
.END
\#
\# CHAPTER STRING
\# --------------
\# *Argument:
\#   <what to print any time the word "chapter" is required>
\# *Function:
\#   Creates or modifies string $CHAPTER_STRING.
\# *Notes:
\#   Default is "chapter".
\#
.MAC CHAPTER_STRING END
.    ds $CHAPTER_STRING \\$1
.END
\#
\# DRAFT STRING
\# ------------
\# *Argument:
\#   <what to print any time the word "draft" is required>
\# *Function:
\#   Creates or modifies string $DRAFT_STRING.
\# *Notes:
\#   Default is "draft".
\#
.MAC DRAFT_STRING END
.    ds $DRAFT_STRING \\$1
.END
\#
\# REVISION STRING
\# ---------------
\# *Argument:
\#   <what to print any time the word "revision" is required>
\# *Function:
\#   Creates or modifies string $REVISION_STRING.
\# *Notes:
\#   Default is "revision".
\#
.MAC REVISION_STRING END
.    ds $REVISION_STRING \\$1
.END
\#
\# FINIS STRING
\# ------------
\# *Argument:
\#   <what to print with the finis macro>
\# *Function:
\#   Creates or modifies string $FINIS_STRING.
\# *Notes:
\#   Default is "END".
\#
.MAC FINIS_STRING END
.    ds $FINIS_STRING \\$1
.END
\#
\# ====================================================================
\#
\# +++RECTO/VERSO+++
\#
\# RECTO_VERSO
\# -----------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Switches HDRFTR_LEFT and HDRFTR_RIGHT on alternate pages.  Also
\#   switches page numbers left and right if either is chosen rather
\#   than the default centered page numbers.  Switches left and right
\#   margins if differing values have been entered.
\# *Notes:
\#   Default is OFF.
\#
.MAC RECTO_VERSO END
.    ie '\\$1'' .nr #RECTO_VERSO 1
.    el .nr #RECTO_VERSO 0
.END
\#
\# FORCE RECTO
\# -----------
\# *Function:
\#   Forces doccover and cover pages to recto
\#
.MAC FORCE_RECTO END
.    ie '\\$1'' .nr #FORCE_RECTO 1
.    el .rr #FORCE_RECTO
.END
\#
.MAC RV_HARD_SET_MARGINS END
.    DOC_LEFT_MARGIN  \\n[@L_MARGIN]u
.    DOC_RIGHT_MARGIN \\n[@R_MARGIN]u
.    po \\n[#DOC_L_MARGIN]u
.    LL \\n[#DOC_L_LENGTH]u
.END
\#
\# ====================================================================
\#
\# +++EPIGRAPHS+++
\#
\# EPIGRAPH INDENT
\# ---------------
\# *Argument:
\#   <value by which to multiply PP_INDENT for block epigraphs>
\# *Function:
\#   Creates or modifies register #EPI_OFFSET_VALUE.
\# *Notes:
\#   Default is 2 for TYPEWRITE, 3 for TYPESET.
\#
.MAC EPIGRAPH_INDENT END
.    rr #EPI_OFFSET_VALUE
.    rm $EPI_OFFSET_VALUE
.    ds $EVAL_EI_ARG \\$1
.    substring $EVAL_EI_ARG -1
.    ie \B'\\*[$EVAL_EI_ARG]' .nr #EPI_OFFSET_VALUE \\$1
.    el .ds $EPI_OFFSET_VALUE \\$1
.    rm $EVAL_EI_ARG
.END
\#
\# EPIGRAPH AUTOLEAD
\# -----------------
\# *Argument:
\#   <amount of lead to add to the epigraph ps for epigraph leading>
\# *Function:
\#   Creates or modifies register #EPI_AUTOLEAD.
\# *Notes:
\#   Default is 2 (for TYPESET; TYPEWRITE doesn't require this).
\#
.MAC EPIGRAPH_AUTOLEAD END
.    nr #EPI_AUTOLEAD (p;\\$1)
.END
\#
\# EPIGRAPH
\# --------
\# *Arguments:
\#   BLOCK | <anything>
\# *Function:
\#   Places an epigraph before the document's text, after the
\#   document header, or after a HEAD.
\# *Notes:
\#   #EPIGRAPH 1 = centered; 2 = block
\#
\#   By default, epigraphs are centered, allowing the user
\#   to input them on a line per line basis.  To change this
\#   behaviour, the user can supply the argument BLOCK, which
\#   will produce indented, filled text similar to BLOCKQUOTE.
\#
\#   If a block epigraph contains more than one para, ALL paras of
\#   the epigraph must be preceded by PP.  Otherwise, PP is optional.
\#
.MAC EPIGRAPH END
.    nr #PP_STYLE 2
.    nr #Q_PP     0
.    if \\n[#LINENUMBERS]=1 \{\
.       NUMBER_LINES OFF
.       nr #LINENUMBERS 2
.    \}
.    if \\n[#START] \{\
.       if \\n[#PRINT_STYLE]=1 \
.          if \\n[#AUTHOR_LINES]=1 .sp \\n[#DOC_LEAD]u
.    \}
.    ie '\\$1'' \{\
.       nr #EPIGRAPH 1
.       ev EPIGRAPH
.       nr #IN_DIVER 1
.       ll \\n[#L_LENGTH]u
.       ta \\n[.l]u
.       CHECK_INDENT
.       if \\n[#COLUMNS] \{\
.          ie \\n[#START] \{\
.              ll \\n[#DOC_L_LENGTH]u
.              ta \\n[.l]u
.          \}
.          el \{\
.             ll \\n[#COL_L_LENGTH]u
.             ta \\n[.l]u
.          \}
.       \}
.       CENTER
.       if \\n[#PRINT_STYLE]=1 \{\
.          fam \\*[$TYPEWRITER_FAM]
.          ft  R
.          if '\\*[$EPI_FT]'I' .FT I
.          ps  \\*[$TYPEWRITER_PS]
.          ie \\n[#SINGLE_SPACE] .vs \\n[#DOC_LEAD]u
.          el .vs \\n[#DOC_LEAD]u/2u
.          nr #EPI_LEAD      \\n[#LEAD]
.          nr #EPI_LEAD_DIFF \\n[#DOC_LEAD]-\\n[#EPI_LEAD]
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          FAMILY   \\*[$EPI_FAM]
.          FT       \\*[$EPI_FT]
.          ps  \\n[#DOC_PT_SIZE]u\\*[$EPI_SIZE_CHANGE]
.          if \\n[#EPI_COLOR]=1 \{\
.             nf
\m[\\*[$EPI_COLOR]]
.             EOL
.          \}
.          vs \\n[.ps]u+\\n[#EPI_AUTOLEAD]u
.          nr #EPI_LEAD      \\n[#LEAD]
.          nr #EPI_LEAD_DIFF \\n[#DOC_LEAD]-\\n[#EPI_LEAD]
.       \}
.       di EPI_TEXT
.       nr #DIVERSIONS_HY_MARGIN (p;\\n[.ps]u*2.75)/1000
.       HY_SET 1 \\n[#DIVERSIONS_HY_MARGIN]u (\\n[#PT_SIZE]u/1000u/8u)p
.       hy 14
.       nr #EPI_ACTIVE 1
.    \}
.    el \{\
.       ie '\\$1'BLOCK' \{\
.          nr #EPIGRAPH 2
.          ev EPIGRAPH
.          evc 0
.          ie \\n[#START] \{\
.             ie \\n[#COLUMNS] \{\
.                ie r#EPI_OFFSET_VALUE \
.                   ll \
\\n[#L_LENGTH_FOR_EPI]u-(\\n[#PP_INDENT]u*(\\n[#EPI_OFFSET_VALUE]u*2u))
.                el \
.                   ll \
\\n[#L_LENGTH_FOR_EPI]u-(\\*[$EPI_OFFSET_VALUE]u*2u)
.                ta \\n[.l]u
.             \}
.             el \{\
.                ie r#EPI_OFFSET_VALUE \
.                   ll \
\\n[#L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#EPI_OFFSET_VALUE]u*2u))
.                el \
.                   ll \\n[#L_LENGTH]u-(\\*[$EPI_OFFSET_VALUE]*2u)
.                ta \\n[.l]u
.             \}
.          \}
.          el \{\
.             ie r#EPI_OFFSET_VALUE \
.                ll \
\\n[#L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#EPI_OFFSET_VALUE]u*2u))
.             el \
.                ll \\n[#L_LENGTH]u-(\\*[$EPI_OFFSET_VALUE]*2u)
.             ta \\n[.l]u
.             if \\n[#COLUMNS] \{\
.                ie r#EPI_OFFSET_VALUE \
.                   ll \
\\n[#COL_L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#EPI_OFFSET_VALUE]u*2u))
.                el \
.                   ll \\n[#COL_L_LENGTH]u-(\\*[$EPI_OFFSET_VALUE]*2u)
.                ta \\n[.l]u
.             \}
.             CHECK_INDENT
.          \}
.          if \\n[#PRINT_STYLE]=1 \{\
.             fam \\*[$TYPEWRITER_FAM]
.             ft  R
.             if '\\*[$EPI_FT]'I' .FT I
.             ps  \\*[$TYPEWRITER_PS]
.             ie \\n[#SINGLE_SPACE] .vs \\n[#DOC_LEAD]u
.             el .vs \\n[#DOC_LEAD]u/2u
.             QUAD LEFT
.             HY OFF
.             nr #EPI_LEAD \\n[#LEAD]
.             nr #EPI_LEAD_DIFF \\n[#DOC_LEAD]-\\n[#EPI_LEAD]
.             di EPI_TEXT
.             nr #EPI_ACTIVE 1
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             FAMILY   \\*[$EPI_FAM]
.             FT       \\*[$EPI_FT]
.             ps  \\n[#DOC_PT_SIZE]u\\*[$EPI_SIZE_CHANGE]
.             if \\n[#EPI_COLOR]=1 \{\
.                nf
\m[\\*[$EPI_COLOR]]
.                EOL
.             \}
.             vs \\n[.ps]u+\\n[#EPI_AUTOLEAD]u
.             QUAD     \\*[$EPI_QUAD]
.             nr #DIVERSIONS_HY_MARGIN (p;\\n[.ps]u*2.75)/1000
.             HY_SET 1 \\n[#DIVERSIONS_HY_MARGIN]u (\\n[#PT_SIZE]u/1000u/8u)p
.             hy 14
.             nr #EPI_LEAD \\n[#LEAD]
.             nr #EPI_LEAD_DIFF \\n[#DOC_LEAD]-\\n[#EPI_LEAD]
.             di EPI_TEXT
.             nr #EPI_ACTIVE 1
.          \}
.       \}
.       el .DO_EPIGRAPH
.    \}
.END
\#
\# DO EPIGRAPH
\# -----------
\# *Arguments:
\#   <none>
\# *Function:
\#   Ends diversion started in EPIGRAPH.  Makes spacing
\#   adjustments to compensate for the difference between epigraph
\#   leading and overall document leading, so that the bottom of
\#   the pages remain flush.
\# *Notes:
\#   In addition to its usual place at the beginning of a
\#   document, EPIGRAPH may also be used after HEAD.
\#
.MAC DO_EPIGRAPH END
.    br
.    di
.    rr #IN_DIVER
.    if \\n[#RESET_FN_COUNTERS]=2 \{\
.       if !\\n[#FN_COUNT]=1 \{\
.          if ((\\n[#PAGE_LENGTH]+\\n[#VARIABLE_FOOTER_POS])+\\n[#DIVER_DEPTH])>(\\n[#PAGE_LENGTH]+\\n[#VARIABLE_FOOTER_POS]) \{\
.             DIVER_FN_2_POST
.             rr #RESET_FN_COUNTERS
.          \}
.       \}
.    \}
.    nr #SAVED_FN_NUMBER \\n[#FN_NUMBER]
.    nr #DONE_ONCE 0 1
.    REMOVE_INDENT
.    ev
.    nr #EPI_DEPTH \\n[#DIVER_DEPTH]-\\n[#EPI_LEAD]
.    nr #EPI_LINES \\n[#EPI_DEPTH]/\\n[#EPI_LEAD]
.    ie \\n[#START] \{\
.       if !\\n[#NO_SHIM] .RLD \\n[#SHIM]u
.       nr #EPI_WHITESPACE (\\n[#DOC_LEAD]*\\n[#EPI_LINES])-\\n[#EPI_DEPTH]
.       while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.          nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.       \}
.       if \\n[#PRINT_STYLE]=1 \
.          if !\\n[#SINGLE_SPACE]=1 .ALD \\n[#DOC_LEAD]u
.       if \\n[#PRINT_STYLE]=2 \{\
.          ie !\\n[#DOC_TYPE]=2 .RLD \\n[#DOC_LEAD]u
.          el \{\
.             ie '\\*[$CHAPTER_TITLE]'' .RLD \\n[#DOC_LEAD]u
.             el .if '\\*[$CHAPTER]''   .RLD \\n[#DOC_LEAD]u
.          \}
.          if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \
.             ALD \\n[#EPI_LEAD_DIFF]u+(\\n[#EPI_WHITESPACE]u/2u)
.          if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \
.             ALD \
\\n[#EPI_LEAD_DIFF]u+(\\n[#EPI_WHITESPACE]u/2u)-\\n[#DOC_LEAD]u
.       \}
.    \}
.    el \{\
.       ie \\n[#EPI_DEPTH]<\\n[#TRAP_DISTANCE] \{\
.          nr #EPI_FITS 1
.          nr #EPI_WHITESPACE (\\n[#DOC_LEAD]*\\n[#EPI_LINES])-\\n[#EPI_DEPTH]
.          while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.             nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.          \}
.          ie \\n[#PRINT_STYLE]=1 \{\
.             if \\n[#EPI_WHITESPACE]=\\n[#DOC_LEAD] \
.                ALD \\n[#EPI_WHITESPACE]u/2u
.          \}
.          el \{\
.             if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \
.                ALD \
\\n[#EPI_LEAD_DIFF]u+(\\n[#EPI_WHITESPACE]u/2u)
.             if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \
.                ALD \
\\n[#EPI_LEAD_DIFF]u+(\\n[#EPI_WHITESPACE]u/2u)-\\n[#DOC_LEAD]u
.          \}
.          if \\n[#DIVER_FN]=2 .rr #DIVER_FN
.       \}
.       el \{\
.          nr #EPI_LINES_TO_TRAP 0 1
.          while \\n[#EPI_LEAD]*\\n+[#EPI_LINES_TO_TRAP]<\\n[#TRAP_DISTANCE] \{\
.             nr #LOOP 1
.          \}
.          nr #EPI_LINES_TO_TRAP -1
.          nr #EPI_WHITESPACE \
(\\n[#EPI_LINES_TO_TRAP]*\\n[#DOC_LEAD])-(\\n[#EPI_LINES_TO_TRAP]*\\n[#EPI_LEAD])
.          while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.             nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.          \}
.          if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \
.             ALD \\n[#EPI_WHITESPACE]u
.          if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \
.             ALD \\n[#EPI_WHITESPACE]u-\\n[#DOC_LEAD]u
.       \}
.    \}
.    if \\n[#EPIGRAPH]=1 \{\
.       po \\n[#L_MARGIN]u
.       if \\n[#COLUMNS] \{\
.          po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.          nr #L_MARGIN \\n[.o]
.       \}
.    \}
.    if \\n[#EPIGRAPH]=2 \{\
.       ie !\\n[#EPI_OFFSET_VALUE]=0 \
.          nr #EPI_OFFSET \
\\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE])
.       el \
.          if !'\\*[$EPI_OFFSET_VALUE]'' \
.             nr #EPI_OFFSET \\n[#L_MARGIN]+\\*[$EPI_OFFSET_VALUE]
.       if \\n[#COLUMNS] \{\
.          ie !\\n[#EPI_OFFSET_VALUE]=0 \
.             nr #EPI_OFFSET \
\\n[#COL_\\n[#COL_NUM]_L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE])
.          el \
.             if !'\\*[$EPI_OFFSET_VALUE]'' \
.                nr #EPI_OFFSET \
\\n[#COL_\\n[#COL_NUM]_L_MARGIN]+\\*[$EPI_OFFSET_VALUE]
.       \}
.       if !\\n[#EPI_OFFSET]=0 .po \\n[#EPI_OFFSET]u
.    \}
.    nf
.    EPI_TEXT
.    br
.    ie \\n[#START] \{\
.       if \\n[#PRINT_STYLE]=1 .SHIM
.       if \\n[#PRINT_STYLE]=2 \{\
.          if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \
.             ALD \\n[#EPI_WHITESPACE]u/2u
.          if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \
.             ALD (\\n[#EPI_WHITESPACE]u/2u)-\\n[#DOC_LEAD]u
.          SHIM
.       \}
.    \}
.    el \{\
.       rr #EPI_ACTIVE
.       ie \\n[#EPI_FITS] \{\
.          ie \\n[#FN_FOR_EPI] \{\
.             nr #EPI_LINES_TO_END 1
.             nr #EPI_WHITESPACE \
(\\n[#EPI_LINES_TO_END]*\\n[#DOC_LEAD])-(\\n[#EPI_LINES_TO_END]*\\n[#EPI_LEAD])
.             while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.                nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.             \}
.             ALD \\n[#EPI_WHITESPACE]u-(\\n[#DOC_LEAD]u-\\n[#EPI_LEAD]u)
.          \}
.          el \{\
.             ie \\n[#PRINT_STYLE]=1 \{\
.                if \\n[#EPI_WHITESPACE]=\\n[#DOC_LEAD] \
.                   ALD \\n[#EPI_WHITESPACE]u
.             \}
.             el \{\
.                if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \
.                   ALD \\n[#EPI_WHITESPACE]u/2u
.                if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \
.                   ALD (\\n[#EPI_WHITESPACE]u/2u)-\\n[#DOC_LEAD]u
.             \}
.          \}
.       \}
.       el \{\
.          nr #EPI_LINES_TO_END \\n[#EPI_LINES]-\\n[#EPI_LINES_TO_TRAP]
.          if \\n[#LOOP] .nr #EPI_LINES_TO_END +1
.          rr #LOOP
.          nr #EPI_WHITESPACE \
(\\n[#EPI_LINES_TO_END]*\\n[#DOC_LEAD])-(\\n[#EPI_LINES_TO_END]*\\n[#EPI_LEAD])
.          while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.             nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.          \}
.          ALD \\n[#EPI_WHITESPACE]u-(\\n[#DOC_LEAD]u-\\n[#EPI_LEAD]u)
.          if \\n[#PRINT_STYLE]=1 \{\
.             if !\\n[#SINGLE_SPACE] \{\
.                nr #EPI_LINES_EVEN \\n[#EPI_LINES_TO_END]%2
.                ie \\n[#EPI_LINES_EVEN] .ALD .5v
.                el .RLD .5v
.                rr #EPI_LINES_EVEN
.             \}
.          \}
.       \}
.    \}
.    nr #PP_STYLE 1
.    rr #EPI_FITS
.    ALD \\n[#DOC_LEAD]u
.    QUAD \\*[$DOC_QUAD]
.    po \\n[#L_MARGIN]u
.    if \\n[#COLUMNS] \{\
.       po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.       nr #L_MARGIN \\n[.o]
.    \}
.    if \\n[#START] \{\
.       if \\n[#COLUMNS] \{\
.          po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.          nr #L_MARGIN \\n[.o]
.          mk dc
.       \}
.    \}
.    if \\n[#LINENUMBERS]=2 \{\
.       NUMBER_LINES RESUME
.       nr #LINENUMBERS 1
.    \}
.END
\#
\# ====================================================================
\#
\# +++FINIS MACRO+++
\#
\# FINIS
\# -----
\# *Arguments:
\#   <none>
\# *Function:
\#   Deposits --END-- at the end of a document.
\#
.MAC FINIS END
.    if !\\n[@TOP] \{\
.       if \\n[.t]<=2v \{\
.          tm1 "[mom]: '\\n[.F]': Insufficient room to print \\$0 on last page.
.          return
.       \}
.    \}
.    br
.    ev FINIS
.    evc 0
.    if \\n[#TAB_ACTIVE] .TQ
.    if \\n[#INDENT_ACTIVE] .IQ CLEAR
.    nr #EM_ADJUST (1m/8)
.    if \\n[#COLUMNS] \{\
.       po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.       nr #L_MARGIN \\n[.o]
.    \}
.    ALD \\n[#DOC_LEAD]u
.    CENTER
.    if \\n[#FINIS_STRING_CAPS]=1 .CAPS
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie !\\n[#FINIS_NO_DASHES] .PRINT "--\\*[$FINIS_STRING]--
.       el .PRINT "\\*[$FINIS_STRING]
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       if \\n[#FINIS_COLOR]=1 .COLOR \\*[$FINIS_COLOR]
.       ie !\\n[#FINIS_NO_DASHES] .ds $FINIS_DASH \
\v'-\\n[#EM_ADJUST]u'\[em]\v'+\\n[#EM_ADJUST]u'
.       el .rm $FINIS_DASH
.       PRINT \
\\*[$FINIS_DASH]\\*[$FINIS_STRING]\\*[$FINIS_DASH]\c
.    \}
.    EL
.    if \\n[#FINIS_COLOR]=1 .gcolor
.    if \\n[#FINIS_STRING_CAPS]=1 .CAPS OFF
.    ev
.    pdfsync
.END
\#
.MAC FINIS_STRING_CAPS END
.    ie '\\$1'' .nr #FINIS_STRING_CAPS 1
.    el .nr #FINIS_STRING_CAPS 0
.END
.
.ALIAS FINIS_CAPS FINIS_STRING_CAPS
\#
.MAC FINIS_NO_DASHES END
.    nr #FINIS_NO_DASHES 1
.END
\#
\# ====================================================================
\#
\# +++HEADERS/FOOTERS+++
\#
\# Define a string so that the current page number can be incorporated
\# into the strings for hdrftr left, right, and center.  NOTE: This is
\# not the same thing as using the shortform # in hdrftr strings.
\#
.ds PAGE# \En[#PAGENUMBER]
.ALIAS SLIDE# PAGE#
\#
.MAC RESTORE_SPACE END
.   vpt 0
.   if \\n[@TOP] \{\
.      ch RR_@TOP
.      rr @TOP
.   \}
.   if \\n[#NEWPAGE] .rr #NEWPAGE
.   if \\n[.u]=1 .nr #FILLED 1
.   nf
.   rs
.   nop \&
.   sp -1
.   if \\n[#FILLED] \{\
.      fi
.      rr #FILLED
.   \}
.   vpt
.END
\#
\# HDRFTR RULE GAP
\# ---------------
\# *Argument:
\#   <amount of space between header/footer and header/footer rule>
\# *Function:
\#   Creates or modifies register #HDRFTR_RULE_GAP to hold amount
\#   of space between header/footer and header/footer rule.
\# *Notes:
\#   Default is 4p.
\#
.MAC HDRFTR_RULE_GAP END
.    nr #HDRFTR_RULE_GAP (\\$1)
.    if '\\$0'HEADER_RULE_GAP' \
.       nr #HEADER_RULE_GAP \\n[#HDRFTR_RULE_GAP]
.    if '\\$0'FOOTER_RULE_GAP' \
.       nr #FOOTER_RULE_GAP \\n[#HDRFTR_RULE_GAP]
.END
\#
\# HDRFTR LEFT
\# -----------
\# *Argument:
\#   <what to put in the left position of page header/footers>
\# *Function:
\#   Creates or modifies string $HDRFTR_LEFT.
\#   Creates register #USER_DEF_HDRFTR_LEFT, which, if 1,
\#   overrides the $HDRFTR_LEFT string created by default
\#   in DEFAULTS.
\# *Notes:
\#   Especially useful if doc has more than one author, and a list
\#   of authors by last name is desired in header/footers.
\#   Default is author.
\#
\#   If the argument is the # character, simply prints the current
\#   page number.
\#
\#   If the user wants to incorporate the page number into the string,
\#   \*[PAGE#] must be used.  For example, if the user wants to put
\#   an ellipsis before the page number in the string, s/he should use
\#   ...\*[PAGE#], not ...#
\#
.MAC HDRFTR_LEFT END
.    nr #USER_DEF_HDRFTR_LEFT 1
.    ds $HDRFTR_LEFT \\$1
.END
\#
\# HDRFTR <POSITION> CAPS AND SMALLCAPS
\# ------------------------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Turns capitalisation of $HDRFTR_<POSITION> on or off.
\# *Notes:
\#   Default for RIGHT (ie AUTHOR) is on.
\#
.MAC CAPS_SMALLCAPS_WARNING END
.    tm1 "[mom]: At line \\n[.c], both CAPS and SMALLCAPS have been enabled for HEADER_\\$1.
.    tm1 "       CAPS takes precedence.
.END
.
.MAC _HDRFTR_CAPS END
.    ds $HDR_FTR \\$0
.    substring $HDR_FTR 0 5 \" HEADER or FOOTER
.    ds POSITION \\$0
.    substring POSITION 7 7
.    if '\\*[POSITION]'L' .ds POSITION LEFT
.    if '\\*[POSITION]'C' .ds POSITION CENTER
.    if '\\*[POSITION]'R' .ds POSITION RIGHT
.    if \\n[#HDRFTR_\\*[POSITION]_SMALLCAPS]=1 \
.       CAPS_SMALLCAPS_WARNING \\*[POSITION]
.    ie '\\$1'' .nr #HDRFTR_\\*[POSITION]_CAPS 1
.    el \{\
.       nr #HDRFTR_\\*[POSITION]_CAPS 0
.       ds $HDRFTR_\\*[POSITION]_SIZE_CHANGE +0
.    \}
.END
.
.MAC _HDRFTR_SMALLCAPS END
.    ds $HDR_FTR \\$0
.    substring $HDR_FTR 0 5 \" HEADER or FOOTER
.    ds POSITION \\$0
.    substring POSITION 7 7
.    if '\\*[POSITION]'L' .ds POSITION LEFT
.    if '\\*[POSITION]'C' .ds POSITION CENTER
.    if '\\*[POSITION]'R' .ds POSITION RIGHT
.    if \\n[#HDRFTR_\\*[POSITION]_CAPS]=1 \
.       CAPS_SMALLCAPS_WARNING \\*[POSITION]
.    ie '\\$1'' .nr #HDRFTR_\\*[POSITION]_SMALLCAPS 1
.    el \
.       nr #HDRFTR_\\*[POSITION]_SMALLCAPS 0
.END
\#
\# HDRFTR CENTER
\# -------------
\# *Argument:
\#   <what to put in the centre position of page header/footers>
\# *Function:
\#   Creates or modifies string $HDRFTR_CENTER.
\#   Creates register #USER_DEF_HDRFTR_CENTER, which, if 1,
\#   overrides the $HDRFTR_CENTER string created by default
\#   in COPYSTYLE.
\# *Notes:
\#   Default is document type if DOCTYPE NAMED, Chapter # if DOCTYPE
\#   CHAPTER, draft and revision number if COPYSTYLE DRAFT.
\#
\#   If the argument is the # character, simply prints the current
\#   page number.
\#
\#   If the user wants to incorporate the page number into the string,
\#   \*[PAGE#] must be used.  For example, if the user wants to put
\#   an ellipsis before the page number in the string, s/he should use
\#   ...\*[PAGE#], not ...#
\#
.MAC HDRFTR_CENTER END
.    nr #USER_DEF_HDRFTR_CENTER 1
.    if '\\$0'HEADER_CENTER' \{\
.       ds $HDRFTR_CENTER_OLD \\*[$HDRFTR_CENTER]
.       ds $HDRFTR_CENTER_NEW \\$1
.    \}
.    if '\\$0'FOOTER_CENTRE' \{\
.       ds $HDRFTR_CENTER_OLD \\*[$HDRFTR_CENTER]
.       ds $HDRFTR_CENTER_NEW \\$1
.    \}
.    ie '\\$1'TOC' .ds $TOC_HDRFTR_CENTER \\$2
.    el .ds $HDRFTR_CENTER \\$1
.END
\#
\# HDRFTR CENTER CAPS AND SMALLCAPS
\# --------------------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Turns capitalisation of $HDRFTR_CENTER (typically, doctype of
\#   the document) on or off.
\# *Notes:
\#   Default is on.
\#
.MAC HDRFTR_CENTER_SMALLCAPS END
.    if \\n[#HDRFTR_CENTER_SMALLCAPS]=1 \
.       CAPS_SMALLCAPS_WARNING CENTER
.    ie '\\$1'' .nr #HDRFTR_CENTER_SMALLCAPS 1
.    el \
.       nr #HDRFTR_CENTER_SMALLCAPS 0
.END
\#
\# HDRFTR CENTER PADDING
\# ---------------------
\# *Argument:
\#   LEFT | RIGHT <amount of padding to put left or right of hdrftr
\#   center string>
\# *Function:
\#   Creates or modifies registers #HDRFTR_CTR_PAD_LEFT or
\#   #HDRFTR_CTR_PAD_RIGHT.
\# *Notes:
\#   By default, the HDRFTR_CENTER string is centered on the doc
\#   line length.  Long titles or long author names can screw up
\#   visual centering, or create overprints.  This macro allows the
\#   user to pad the center string by the specified amount of space
\#   to fix these problems.
\#
\#   A unit of measure is required.
\#
.MAC HDRFTR_CENTER_PAD END
.    if '\\$1'LEFT'  .nr #HDRFTR_CTR_PAD_LEFT  (\\$2)
.    if '\\$1'RIGHT' .nr #HDRFTR_CTR_PAD_RIGHT (\\$2)
.END
\#
\# SWITCH HDRFTR CENTER PADDING SIDE (support macro)
\# -------------------------------------------------
\# *Argument:
\#   <none>
\# *Function:
\#   Switches the padding side of hdrftr center padding.
\# *Notes:
\#   Required to keep spacing around hdrftr string constant
\#   in recto/verso documents.
\#
.MAC SWITCH_HDRFTR_CENTER_PAD END
.    nr #HDRFTR_CTR_PAD_TMP  \\n[#HDRFTR_CTR_PAD_LEFT]
.    HDRFTR_CENTER_PAD LEFT  \\n[#HDRFTR_CTR_PAD_RIGHT]u
.    HDRFTR_CENTER_PAD RIGHT \\n[#HDRFTR_CTR_PAD_TMP]u
.END
\#
\# HDRFTR RIGHT
\# ------------
\# *Argument:
\#   <what to put in the right position of page header/footers>
\# *Function:
\#   Creates or modifies string $HDRFTR_RIGHT.
\#   Creates register #USER_DEF_HDRFTR_RIGHT, which, if 1,
\#   overrides the $HDRFTR_RIGHT string created by default
\#   in DEFAULTS.
\# *Notes:
\#   Default is document title.
\#
\#   If the argument is the # character, simply prints the current
\#   page number.
\#
\#   If the user wants to incorporate the page number into the string,
\#   \*[PAGE#] must be used.  For example, if the user wants to put
\#   an ellipsis before the page number in the string, s/he should use
\#   ...\*[PAGE#], not ...#
\#
.MAC HDRFTR_RIGHT END
.    nr #USER_DEF_HDRFTR_RIGHT 1
.    ds $HDRFTR_RIGHT \\$1
.END
\#
\# HDRFTR RIGHT CAPS AND SMALLCAPS
\# -------------------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Turns capitalisation of $HDRFTR_RIGHT (typically, the title of
\#   the document) on or off.
\# *Notes:
\#   Default is on.
\#
.MAC HDRFTR_RIGHT_SMALLCAPS END
.    if \\n[#HDRFTR_RIGHT_SMALLCAPS]=1 \
.       CAPS_SMALLCAPS_WARNING RIGHT
.    ie '\\$1'' .nr #HDRFTR_RIGHT_SMALLCAPS 1
.    el \
.       nr #HDRFTR_RIGHT_SMALLCAPS 0
.END
\#
\# HDRFTR RULE
\# -----------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   If invoked via the alias HDRFTR_RULE_INTERNAL in HDRFTR, prints a rule
\#   under the header/over the footer.  Otherwise, turns HDRFTR_RULE
\#   on or off.
\#
.MAC HDRFTR_RULE END
.    if r #HEADERS_ON \
.       if \\n[#HEADERS_ON]=1 .nr #HDRFTR_RULE_GAP \\n[#HEADER_RULE_GAP]
.    if r #FOOTERS_ON \
.       if \\n[#FOOTERS_ON]=1 .nr #HDRFTR_RULE_GAP \\n[#FOOTER_RULE_GAP]
.    if '\\$0'HDRFTR_RULE_INTERNAL' \{\
.       ie \\n[#USERDEF_HDRFTR] \{\
.          nr #CAP_HEIGHT_ADJUST \\n[#HDRFTR_HEIGHT]
.          if \\n[#HEADERS_ON] \{\
.             rt \\n[y]u
.             ALD \\n[#HDRFTR_RULE_GAP]u
.             nr #HDRFTR_RULE_WEIGHT \\n[#HEADER_RULE_WEIGHT]
.             nr #HDRFTR_RULE_WEIGHT_ADJ \\n[#HEADER_RULE_WEIGHT_ADJ]
.          \}
.          if \\n[#FOOTERS_ON] \{\
.             rt \\n[y]u
.             RLD \
\\n[#HDRFTR_RULE_GAP]u+\\n[#CAP_HEIGHT_ADJUST]u+\\n[#FOOTER_RULE_WEIGHT]u
.             nr #HDRFTR_RULE_WEIGHT \\n[#FOOTER_RULE_WEIGHT]
.             nr #HDRFTR_RULE_WEIGHT_ADJ \\n[#FOOTER_RULE_WEIGHT_ADJ]
.          \}
.          ie \\n[#HDRFTR_RULE_COLOR]=1 \{\
\m[\\*[$HDRFTR_RULE_COLOR]]\
\D't \\n[#HDRFTR_RULE_WEIGHT]u'\
\h'|0'\
\v'+\\n[#HDRFTR_RULE_WEIGHT_ADJ]u'\
\D'l \\n[#DOC_L_LENGTH]u 0'\
\D't \\n[#RULE_WEIGHT]u'\
\h'-\\n[#RULE_WEIGHT]u'\
\m[]
.          \}
.          el \{\
\D't \\n[#HDRFTR_RULE_WEIGHT]u'\
\h'|0'\
\v'+\\n[#HDRFTR_RULE_WEIGHT_ADJ]u'\
\D'l \\n[#DOC_L_LENGTH]u 0'\
\D't \\n[#RULE_WEIGHT]u'\
\h'-\\n[#RULE_WEIGHT]u'
.          \}
.          br
.       \}
.       el \{\
.          if \\n[#PRINT_STYLE]=1 .nr #CAP_HEIGHT_ADJUST \\n[#CAP_HEIGHT]
.          if \\n[#PRINT_STYLE]=2 \{\
.             ie \\n[#LEFT_CAP_HEIGHT]>\\n[#CENTER_CAP_HEIGHT] \
.                nr #CAP_HEIGHT_ADJUST \\n[#LEFT_CAP_HEIGHT]
.             el .nr #CAP_HEIGHT_ADJUST \\n[#CENTER_CAP_HEIGHT]
.             ie \\n[#CAP_HEIGHT_ADJUST]>\\n[#RIGHT_CAP_HEIGHT] \
.                nr #CAP_HEIGHT_ADJUST \\n[#CAP_HEIGHT_ADJUST]
.             el .nr #CAP_HEIGHT_ADJUST \\n[#RIGHT_CAP_HEIGHT]
.          \}
.          if \\n[#HEADERS_ON] \{\
.             rt \\n[y]u
.             ALD \\n[#HDRFTR_RULE_GAP]u
.             nr #HDRFTR_RULE_WEIGHT \\n[#HEADER_RULE_WEIGHT]
.             nr #HDRFTR_RULE_WEIGHT_ADJ \\n[#HEADER_RULE_WEIGHT_ADJ]
.          \}
.          if \\n[#FOOTERS_ON] \{\
.             rt \\n[y]u
.             RLD \
\\n[#HDRFTR_RULE_GAP]u+\\n[#CAP_HEIGHT_ADJUST]u+\\n[#FOOTER_RULE_WEIGHT]u
.             nr #HDRFTR_RULE_WEIGHT \\n[#FOOTER_RULE_WEIGHT]
.             nr #HDRFTR_RULE_WEIGHT_ADJ \\n[#FOOTER_RULE_WEIGHT_ADJ]
.          \}
.          ie \\n[#HDRFTR_RULE_COLOR]=1 \{\
\m[\\*[$HDRFTR_RULE_COLOR]]\
\D't \\n[#HDRFTR_RULE_WEIGHT]u'\
\h'|0'\
\v'+\\n[#HDRFTR_RULE_WEIGHT_ADJ]u'\
\D'l \\n[#DOC_L_LENGTH]u 0'\
\D't \\n[#RULE_WEIGHT]u'\
\h'-\\n[#RULE_WEIGHT]u'\
\m[]
.          \}
.          el \{\
\D't \\n[#HDRFTR_RULE_WEIGHT]u'\
\h'|0'\
\v'+\\n[#HDRFTR_RULE_WEIGHT_ADJ]u'\
\D'l \\n[#DOC_L_LENGTH]u 0'\
\D't \\n[#RULE_WEIGHT]u'\
\h'-\\n[#RULE_WEIGHT]u'
.          \}
.          br
.       \}
.    \}
.    if '\\$0'HEADER_RULE' \{\
.       ie '\\$1'' \{\
.          nr #HEADER_RULE 1
.          nr #HDRFTR_RULE 1
.       \}
.       el \{\
.          nr #HEADER_RULE 0
.          nr #HDRFTR_RULE 0
.       \}
.    \}
.    if '\\$0'FOOTER_RULE' \{\
.       ie '\\$1'' \{\
.          nr #FOOTER_RULE 1
.          nr #HDRFTR_RULE 1
.       \}
.       el \{\
.          nr #FOOTER_RULE 0
.          nr #HDRFTR_RULE 0
.       \}
.    \}
.    if '\\$0'HDRFTR_RULE' \{\
.       ie '\\$1'' .nr #HDRFTR_RULE 1
.       el .nr #HDRFTR_RULE 0
.    \}
.END
.
.ALIAS HDRFTR_RULE_INTERNAL HDRFTR_RULE
\#
\# HDRFTR PLAIN
\# ------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Sets the family, font, and point size of all strings in
\#   header/footers to the same family and point size as running
\#   text.  Font for the header/footer becomes roman throughout.
\#
.MAC HDRFTR_PLAIN END
.    nr #HDRFTR_PLAIN 1
.    rm $HDRFTR_FAMILY
.    rm #HDRFTR_PT_SIZE
.    rm $HDRFTR_COLOR
.    rm $HDRFTR_LEFT_FAMILY
.    rm $HDRFTR_LEFT_FONT
.    rm $HDRFTR_LEFT_SIZE_CHANGE
.    rr #HDRFTR_LEFT_CAPS
.    rr #HDRFTR_LEFT_SMALLCAPS
.    rr #HDRFTR_LEFT_COLOR
.    rm $HDRFTR_CENTER_FAMILY
.    rm $HDRFTR_CENTER_FONT
.    rm $HDRFTR_CENTER_SIZE_CHANGE
.    rr #HDRFTR_CENTER_CAPS
.    rr #HDRFTR_CENTER_SMALLCAPS
.    rr #HDRFTR_CENTER_COLOR
.    rm $HDRFTR_RIGHT_FAMILY
.    rm $HDRFTR_RIGHT_FONT
.    rm $HDRFTR_RIGHT_SIZE_CHANGE
.    rr #HDRFTR_RIGHT_CAPS
.    rr #HDRFTR_RIGHT_SMALLCAPS
.    rr #HDRFTR_RIGHT_COLOR
.END
\#
\# SWITCH HDRFTR
\# -------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or modifies register #SWITCH_HDRFTR, used to switch
\#   default location of HDRFTR_LEFT and HDRFTR_RIGHT.
\# *Notes:
\#   Default is OFF.
\#
\# Typically, the author string appears at the left of header/footers,
\# and the title string appears at the right.  This switches the
\# location of the two.  Useful in conjunction with RECTO_VERSO to tweak
\# switches on alternate pages to come out as the user wishes.  The
\# assumption of RECTO_VERSO is that the first page of the document
\# (recto) is odd, and even though it has no header/footer, if it did
\# have one, it would print as AUTHOR...CENTER...TITLE (or whatever
\# strings the user has supplied for HDRFTR_LEFT/RIGHT), meaning that
\# the next page, which does have a header/footer, will come out as
\# TITLE...CENTER...AUTHOR (or whatever strings the user has supplied
\# for HDRFTR_LEFT/RIGHT).  SWITCH_HDRFTRS allows the user to get the
\# desired string in the desired place on the desired recto/verso page.
\#
.MAC SWITCH_HDRFTR END
.    ie '\\$1'' .nr #SWITCH_HDRFTR 1
.    el .nr #SWITCH_HDRFTR 0
.END
\#
\# USER DEFINED HDRFTR RECTO
\# -------------------------
\# *Arguments:
\#   L | LEFT | C | CENTER | CENTER | R | RIGHT <hdrftr_recto_string>
\# *Function:
\#   Toggles #USERDEF_HDRFTR on, stores quad as #USERDEF_HDRFTR_RECTO_QUAD,
\#   stores string in $USERDEF_HDRFTR_RECTO.
\# *Notes:
\#   For use when users don't want 3-part headers/footers, but rather
\#   want to design their own headers/footers and need different
\#   headers/footers on recto and verso pages.  Using just
\#   HEADER_RECTO or FOOTER_RECTO, even when recto/verso is not on,
\#   allows users to design their own headers/footers for doc pages.
\#
.MAC HDRFTR_RECTO END
.    nr #USERDEF_HDRFTR 1
.    ds $QUAD_TYPE \\$1
.    substring $QUAD-TYPE 0 0
.    if '\\*[$QUAD_TYPE]'L' .nr #USERDEF_HDRFTR_RECTO_QUAD 1
.    if '\\*[$QUAD_TYPE]'C' .nr #USERDEF_HDRFTR_RECTO_QUAD 2
.    if '\\*[$QUAD_TYPE]'R' .nr #USERDEF_HDRFTR_RECTO_QUAD 3
.    shift
.    ie '\\$1'CAPS' \{\
.       nr #HDRFTR_RECTO_CAPS 1
.       ds $USERDEF_HDRFTR_RECTO \\$2
.    \}
.    el .ds $USERDEF_HDRFTR_RECTO \\$1
.END
\#
\# USER DEFINED HDRFTR VERSO
\# -------------------------
\# *Arguments:
\#   L | LEFT | C | CENTER | CENTER | R | RIGHT <hdrftr_verso_string>
\# *Function:
\#   Toggles #USERDEF_HDRFTR on, stores quad as #USERDEF_HDRFTR_VERSO_QUAD,
\#   stores string in $USERDEF_HDRFTR_VERSO.
\# *Notes:
\#   For use when users don't want 3-part headers/footers, but rather
\#   want to design their own headers/footers and need different
\#   headers/footers on recto and verso pages.
\#
.MAC HDRFTR_VERSO END
.    nr #USERDEF_HDRFTR 1
.    ds $QUAD_TYPE \\$1
.    substring $QUAD-TYPE 0 0
.    if '\\*[$QUAD_TYPE]'L'     .nr #USERDEF_HDRFTR_VERSO_QUAD 1
.    if '\\*[$QUAD_TYPE]\\$1'C' .nr #USERDEF_HDRFTR_VERSO_QUAD 2
.    if '\\*[$QUAD_TYPE]\\$1'R' .nr #USERDEF_HDRFTR_VERSO_QUAD 3
.    shift
.    ie '\\$1'CAPS' \{\
.       nr #HDRFTR_VERSO_CAPS 1
.       ds $USERDEF_HDRFTR_VERSO \\$2
.    \}
.    el .ds $USERDEF_HDRFTR_VERSO \\$1
.END
\#
\# PRINT FOOTER ON FIRST PAGE
\# --------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles register #PRINT_FOOTER_ON_PAGE_1
\# *Notes:
\#   Lets user choose whether to print footer on first
\#   page of doc.
\#
.MAC FOOTER_ON_FIRST_PAGE END
.    ie '\\$1'' .nr #PRINT_FOOTER_ON_PAGE_1 1
.    el .rr #PRINT_FOOTER_ON_PAGE_1
.END
\#
\# PRINT PAGE NUMBER ON FIRST PAGE
\# -------------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles register #PRINT_PAGENUM_ON_PAGE_1
\# *Notes:
\#   Lets user choose whether to print page number on first
\#   page of doc and after collate when footers are on or page numbering
\#   has been user set at top of page.
\#
.MAC PAGENUM_ON_FIRST_PAGE END
.    ie '\\$1'' .nr #PRINT_PAGENUM_ON_PAGE_1 1
.    el .rr #PRINT_PAGENUM_ON_PAGE_1
.END
\#
\# PRINT HEADER/FOOTER
\# -------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Based on defaults or values entered by user, prints a
\#   three-part title at either the top or the bottom of the page.
\# *Notes:
\#   Called from within either HEADER or FOOTER.
\#
.MAC PRINT_HDRFTR END
.    if \\n[#DOC_TYPE]=4 .nr #SUITE \En[.pn]
.    if \\n[#FOOTERS_ON] \{\
.       if \\n[#START_FOR_FOOTERS] \{\
.          rr #START_FOR_FOOTERS
.          if \\n[#DOC_TYPE]=5 \{\
.             if !\\n[#HDRFTR_BOTH] .PRINT_USERDEF_HDRFTR
.             return
.          \}
.          if !\\n[#PRINT_FOOTER_ON_PAGE_1] \{\
.             ie !\\n[#HDRFTR_BOTH] .return
.             el \{\
.                rr #FOOTERS_ON
.                if !\\n[#COLLATE] .nr #HEADERS_ON 1
.                ie \\n[#HEADER_RULE]=1 .HEADER_RULE
.                el .HEADER_RULE OFF
.                ie \\n[#HDRFTR_BOTH] .HEADER_VERSO \\*[$HDR_VERSO_QUAD] "\\*[$HDR_VERSO_STRING]"
.                el .HEADER_RECTO \\*[$HDR_RECTO_QUAD] "\\*[$HDR_RECTO_STRING]"
.                return
.             \}
.          \}
.       \}
.    \}
.    if \\n[#USERDEF_HDRFTR] \{\
.       PRINT_USERDEF_HDRFTR
.       return
.    \}
.    if \\n[#SWITCH_HDRFTR] \{\
.       ds $HDRFTR_TMP_SWITCH             \\*[$HDRFTR_LEFT]
.       ds $HDRFTR_LEFT                   \\*[$HDRFTR_RIGHT]
.       ds $HDRFTR_RIGHT                  \\*[$HDRFTR_TMP_SWITCH]
.       ds $HDRFTR_TMP_SIZE_CHANGE_SWITCH \\*[$HDRFTR_LEFT_SIZE_CHANGE]
.       ds $HDRFTR_LEFT_SIZE_CHANGE       \\*[$HDRFTR_RIGHT_SIZE_CHANGE]
.       ds $HDRFTR_RIGHT_SIZE_CHANGE      \\*[$HDRFTR_TMP_SIZE_CHANGE_SWITCH]
.       nr #HDRFTR_TMP_CAPS_SWITCH        \\n[#HDRFTR_LEFT_CAPS]
.       nr #HDRFTR_LEFT_CAPS              \\n[#HDRFTR_RIGHT_CAPS]
.       nr #HDRFTR_TMP_SMALLCAPS_SWITCH   \\n[#HDRFTR_LEFT_SMALLCAPS]
.       nr #HDRFTR_LEFT_SMALLCAPS         \\n[#HDRFTR_RIGHT_SMALLCAPS]
.       nr #HDRFTR_RIGHT_CAPS             \\n[#HDRFTR_TMP_CAPS_SWITCH]
.       ds $HDRFTR_TMP_COLOR_SWITCH       \\*[$HDRFTR_LEFT_COLOR]
.       ds $HDRFTR_LEFT_COLOR             \\*[$HDRFTR_RIGHT_COLOR]
.       ds $HDRFTR_RIGHT_COLOR            \\*[$HDRFTR_TMP_COLOR_SWITCH]
.       rr #HDRFTR_TMP_CAPS_SWITCH
.       rm $HDRFTR_TMP_SWITCH
.       rm $HDRFTR_TMP_SIZE_CHANGE_SWITCH
.       rm $HDRFTR_TMP_COLOR_SWITCH
.       nr #SWITCH_HDRFTR 0
.    \}
.    nr #PAGENUMBER \\n%+\\n[#PAGE_NUM_ADJ]
.    if \\n[#ENDNOTES] .PAGENUM_STYLE \\*[$EN_PN_STYLE]
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #LEFT_CAP_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.       if o .RIGHT
.       if e .LEFT
.       if \\n[#RECTO_VERSO]=0 .LEFT
.       if \\n[#HDRFTR_LEFT_CAPS] .CAPS
.       ie '\\*[$HDRFTR_LEFT]'#' .PRINT \\n[#PAGENUMBER]
.       el \{\
.          ie !'\\*[$HDRFTR_LEFT]'' .PRINT \\*[$HDRFTR_LEFT]
.          el .PRINT \&
.       \}
.       if \\n[#HDRFTR_LEFT_CAPS] .CAPS OFF
.       CENTER
.       if \\n[#HDRFTR_CENTER_CAPS] .CAPS
.       rt \\n[y]u
.       ie '\\*[$HDRFTR_CENTER]'#' .PRINT \
\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\\n[#PAGENUMBER]\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'
.       el \{\
.          ie !'\\*[$HDRFTR_CENTER]'' .PRINT \
\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\\*[$HDRFTR_CENTER]\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'
.          el .PRINT \&
.       \}
.       if \\n[#HDRFTR_CENTER_CAPS] .CAPS OFF
.       if o .LEFT
.       if e .RIGHT
.       if \\n[#RECTO_VERSO]=0 .RIGHT
.       if \\n[#HDRFTR_RIGHT_CAPS] .CAPS
.       rt \\n[y]u
.       ie '\\*[$HDRFTR_RIGHT]'#' .PRINT \\n[#PAGENUMBER]
.       el \{\
.          ie !'\\*[$HDRFTR_RIGHT]'' .PRINT \\*[$HDRFTR_RIGHT]
.          el .PRINT \&
.       \}
.       if \\n[#HDRFTR_RIGHT_CAPS] .CAPS OFF
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       if \\n[#HDRFTR_COLOR]=1 \{\
.          nf
\m[\\*[$HDRFTR_COLOR]]
.       \}
.       fam \\*[$HDRFTR_LEFT_FAM]
.       ft  \\*[$HDRFTR_LEFT_FT]
.       ps  \\n[#HDRFTR_PT_SIZE]u\\*[$HDRFTR_LEFT_SIZE_CHANGE]
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #LEFT_CAP_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.       if o .LEFT
.       if e .RIGHT
.       if \\n[#RECTO_VERSO]=0 .LEFT
.       if \\n[#HDRFTR_LEFT_SMALLCAPS] .SMALLCAPS
.       if \\n[#HDRFTR_LEFT_CAPS] .CAPS
.       ie '\\*[$HDRFTR_LEFT]'#' \{\
.          ie \\n[#HDRFTR_LEFT_COLOR]=1 \
.             PRINT \m[\\*[$HDRFTR_LEFT_COLOR]]\\n[#PAGENUMBER]\m[]
.          el \
.             PRINT \\n[#PAGENUMBER]
.       \}
.       el \{\
.          ie !'\\*[$HDRFTR_LEFT]'' \{\
.             ie \\n[#HDRFTR_LEFT_COLOR]=1 \
.                PRINT \m[\\*[$HDRFTR_LEFT_COLOR]]\\*[$HDRFTR_LEFT]\m[]
.             el \
.                PRINT \\*[$HDRFTR_LEFT]
.          \}
.          el .nop \&
.       \}
.       if \\n[#HDRFTR_LEFT_CAPS] .CAPS OFF
.       if \\n[#HDRFTR_LEFT_SMALLCAPS] .SMALLCAPS OFF
.       fam     \\*[$HDRFTR_CENTER_FAM]
.       ft      \\*[$HDRFTR_CENTER_FT]
.       ps      \\n[#HDRFTR_PT_SIZE]u\\*[$HDRFTR_CENTER_SIZE_CHANGE]
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #CENTER_CAP_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.       CENTER
.       if \\n[#HDRFTR_CENTER_SMALLCAPS] .SMALLCAPS
.       if \\n[#HDRFTR_CENTER_CAPS] .CAPS
.       rt \\n[y]u
.       ie '\\*[$HDRFTR_CENTER]'#' \{\
.          ie \\n[#HDRFTR_CENTER_COLOR]=1 .PRINT \
\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\m[\\*[$HDRFTR_CENTER_COLOR]]\
\\n[#PAGENUMBER]\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'\m[]
.          el .PRINT \
\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\\n[#PAGENUMBER]\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'
.       \}
.       el \{\
.          ie !'\\*[$HDRFTR_CENTER]'' \{\
.             ie \\n[#HDRFTR_CENTER_COLOR]=1 .PRINT \
\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\m[\\*[$HDRFTR_CENTER_COLOR]]\
\\*[$HDRFTR_CENTER]\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'\m[]
.             el .PRINT \
\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\\*[$HDRFTR_CENTER]\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'
.          \}
.          el .PRINT \&
.       \}
.       if \\n[#HDRFTR_CENTER_CAPS] .CAPS OFF
.       if \\n[#HDRFTR_CENTER_SMALLCAPS] .SMALLCAPS OFF
.       fam \\*[$HDRFTR_RIGHT_FAM]
.       ft  \\*[$HDRFTR_RIGHT_FT]
.       ps  \\n[#HDRFTR_PT_SIZE]u\\*[$HDRFTR_RIGHT_SIZE_CHANGE]
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #RIGHT_CAP_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.       if o .RIGHT
.       if e .LEFT
.       if \\n[#RECTO_VERSO]=0 .RIGHT
.       if \\n[#HDRFTR_RIGHT_SMALLCAPS] .SMALLCAPS
.       if \\n[#HDRFTR_RIGHT_CAPS] .CAPS
.       rt \\n[y]u
.       ie '\\*[$HDRFTR_RIGHT]'#' \{\
.          ie \\n[#HDRFTR_RIGHT_COLOR]=1 \
.             PRINT \m[\\*[$HDRFTR_RIGHT_COLOR]]\\n[#PAGENUMBER]\m[]
.          el \
.             PRINT \\n[#PAGENUMBER]
.       \}
.       el \{\
.          ie !'\\*[$HDRFTR_RIGHT]'' \{\
.             ie \\n[#HDRFTR_RIGHT_COLOR]=1 \
.                PRINT \m[\\*[$HDRFTR_RIGHT_COLOR]]\\*[$HDRFTR_RIGHT]\m[]
.             el \
.                PRINT \\*[$HDRFTR_RIGHT]
.          \}
.          el .PRINT \&
.       \}
.       if \\n[#HDRFTR_RIGHT_CAPS] .CAPS OFF
.       if \\n[#HDRFTR_RIGHT_SMALLCAPS] .SMALLCAPS OFF
.    \}
.    if \\n[#HDRFTR_RULE] .HDRFTR_RULE_INTERNAL
.    br
.END
\#
\# PRINT USER DEFINED HEADER/FOOTER
\# --------------------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Based on defaults or values entered by user, prints a single part
\#   (i.e. not 3-part) title at either the top or the bottom of the page.
\# *Notes:
\#   Called from within PRINT_HDRFTR.
\#
.MAC PRINT_USERDEF_HDRFTR END
.    nr #PAGENUMBER \\n%+\\n[#PAGE_NUM_ADJ]
.    fc ^ #
.    if \\n[#PRINT_STYLE]=2 \{\
.       fam \\*[$HDRFTR_FAM]
.       ft  R
.       ps \\n[#HDRFTR_PT_SIZE]u
.       if \\n[#HDRFTR_COLOR]=1 \{\
.          nf
.          COLOR \\*[$HDRFTR_COLOR]
.       \}
.    \}
.    ie \\n[#RECTO_VERSO] \{\
.       if o \{\
.          if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=1 .LEFT
.          if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=2 .CENTER
.          if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=3 .RIGHT
.          if \\n[#HDRFTR_RECTO_CAPS]=1 .CAPS
.          if '\\n[.ev]'FOOTER' .vs 0
.          PRINT \\*[$USERDEF_HDRFTR_RECTO]
.          if '\\n[.ev]'FOOTER' .vs
.          if \\n[#HDRFTR_RECTO_CAPS]=1 .CAPS OFF
.          EOL
.          if \\n[#FOOTERS_ON] \{\
.             di NULL
.             SIZESPECS
.             nr #HDRFTR_HEIGHT \\n[#CAP_HEIGHT]
.             di
.          \}
.       \}
.       if e \{\
.          ie !'\\*[$USERDEF_HDRFTR_VERSO]'' \{\
.             if \\n[#USERDEF_HDRFTR_VERSO_QUAD]=1 .LEFT
.             if \\n[#USERDEF_HDRFTR_VERSO_QUAD]=2 .CENTER
.             if \\n[#USERDEF_HDRFTR_VERSO_QUAD]=3 .RIGHT
.             if \\n[#HDRFTR_VERSO_CAPS]=1 .CAPS
.             if '\\n[.ev]'FOOTER' .vs 0
.             PRINT \\*[$USERDEF_HDRFTR_VERSO]
.             if '\\n[.ev]'FOOTER' .vs
.             if \\n[#HDRFTR_VERSO_CAPS]=1 .CAPS OFF
.             EOL
.             if \\n[#FOOTERS_ON] \{\
.                di NULL
.                SIZESPECS
.                nr #HDRFTR_HEIGHT \\n[#CAP_HEIGHT]
.                di
.             \}
.          \}
.          el \{\
.             if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=1 .LEFT
.             if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=2 .CENTER
.             if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=3 .RIGHT
.             if \\n[#HDRFTR_RECTO_CAPS]=1 .CAPS
.             if '\\n[.ev]'FOOTER' .vs 0
.             PRINT \\*[$USERDEF_HDRFTR_RECTO]
.             if '\\n[.ev]'FOOTER' .vs
.             if \\n[#HDRFTR_RECTO_CAPS]=1 .CAPS OFF
.             EOL
.             if \\n[#FOOTERS_ON] \{\
.                di NULL
.                SIZESPECS
.                nr #HDRFTR_HEIGHT \\n[#CAP_HEIGHT]
.                di
.             \}
.          \}
.       \}
.    \}
.    el \{\
.       if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=1 .LEFT
.       if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=2 .CENTER
.       if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=3 .RIGHT
.       if \\n[#HDRFTR_RECTO_CAPS]=1 .CAPS
.       if '\\n[.ev]'FOOTER' .vs 0
.       if !r #SKIP .PRINT \\*[$USERDEF_HDRFTR_RECTO]
.       if '\\n[.ev]'FOOTER' .vs
.       if \\n[#HDRFTR_RECTO_CAPS]=1 .CAPS OFF
.       EOL
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #HDRFTR_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.    \}
.    fc
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#HDRFTR_COLOR]=1 \m[\\*[$HDRFTR_COLOR]]
.       el \m[black]
.    \}
.    if \\n[#HDRFTR_RULE] \
.       HDRFTR_RULE_INTERNAL
.END
\#
\# +++HEADERS+++
\#
\# HEADERS (off or on)
\# -------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns headers at the top of the page off or on.
\# *Notes:
\#   Default is on.
\#
.MAC HEADERS END
.    ie '\\$1'' .nr #HEADERS_ON 1
.    el .nr #HEADERS_ON 0
.END
\#
\# HEADER MARGIN
\# -------------
\# *Argument:
\#   <amount of space between top of page and header>
\# *Function:
\#   Creates or modifies register #HEADER_MARGIN to hold amount
\#   of space between top of page and header.
\# *Notes:
\#   Requires unit of measure.  Default is 4P+6p, measured top-of-page
\#   to baseline.
\#
.MAC HEADER_MARGIN END
.    nr #HEADER_MARGIN (\\$1)
.END
\#
\# HEADER GAP
\# ----------
\# *Argument:
\#   <amount of space between header and running text>
\# *Function:
\#   Creates or modifies register #HEADER_GAP to hold amount
\#   of space between header and running text.
\# *Notes:
\#   Default is 1P+6p.
\#
.MAC HEADER_GAP END
.    nr #HEADER_GAP (\\$1)
.END
\#
\# HEADER
\# ------
\# *Arguments:
\#   <none>
\# *Function:
\#   Resets margin notes, processes footnote and margin note
\#   leftover, takes care of recto-verso, prepares for columns after
\#   first, determines whether to flex-space the page,,outputs
\#   deferred floats, and does some tbl magic.  If headers are
\#   enabled, prints header appropriate to DOC_TYPE, PRINTSTYLE, and
\#   COPYSTYLE.
\#
.MAC HEADER END
.    vpt 0
.    if \\n[#DOC_TYPE]=5 \{\
.       if \\n[#SLIDE_FOOTERS] \{\
.          PRINT_FOOTER
.       if \\n[#HDRFTR_BOTH] \
.          HEADER_RECTO \\*[$HDR_RECTO_QUAD] "\\*[$HDR_RECTO_STRING]"
.       \}
.    \}
.    nr flex-spaces 0
.    nr flex +1
.    if \\n[#NEW_DOC_PT_SIZE] .nr #DOC_PT_SIZE \\n[#NEW_DOC_PT_SIZE]
.    rr #NEW_DOC_PT_SIZE
.    if \\n[#RESET_TRAPS] \{\
.       TRAPS
.       if \\n[#REMOVE_ADJ] .nr #DOC_LEAD -\\n[#DOC_LEAD_ADJ]
.    \}
.    rr #REMOVE_ADJ
.    rr #RESET_TRAPS
.    MNtop
.    rr #FROM_FOOTER
.    nr #FROM_HEADER 1
.    nr #LAST_FN_COUNT_FOR_COLS \\n[#FN_COUNT_FOR_COLS]
.    if \\n[#FN_DEPTH] .PROCESS_FN_LEFTOVER
.    rr #RULED
.    if \\n[#RESET_FN_NUMBER] .nr #FN_NUMBER 0 1
.    if !\\n[#DIVERTED] .rr #PREV_FN_DEFERRED
.    po \\n[#DOC_L_MARGIN]u
.    if \\n[#RECTO_VERSO] \{\
.       if !\\n[#TOC_RV_SWITCH]=2 \{\
.          nr #DOC_LR_MARGIN_TMP \\n[#DOC_L_MARGIN]
.          DOC_LEFT_MARGIN  \\n[#DOC_R_MARGIN]u
.          if \\n[#CROPS] .DOC_LEFT_MARGIN  \\n[#DOC_R_MARGIN]u+\\n[cropmarks]u
.          DOC_RIGHT_MARGIN \\n[#DOC_LR_MARGIN_TMP]u
.          if \\n[#CROPS] .DOC_RIGHT_MARGIN \\n[#DOC_LR_MARGIN_TMP]u-\\n[cropmarks]u
.          SWITCH_HDRFTR_CENTER_PAD
.       \}
.    \}
.    ev HEADER
.    if \\n[#PAGE_NUM_V_POS]=1 .vs 0
.    sp |\\n[#HEADER_MARGIN]u-1v
.    mk y
.    ll \\n[#DOC_L_LENGTH]u
.    ta \\n[.l]u
.    if \\n[#PRINT_STYLE]=1 \{\
.       fam \\*[$TYPEWRITER_FAM]
.       ft  R
.       ps  \\*[$TYPEWRITER_PS]\\*[$HDRFTR_SIZE_CHANGE]
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.      fam \\*[$HDRFTR_FAM]
.      ft  R
.      ps  \\n[#DOC_PT_SIZE]u\\*[$HDRFTR_SIZE_CHANGE]
.    \}
.    nr #HDRFTR_PT_SIZE \\n[#PT_SIZE]
.    if \\n[#CAPS_ON] \{\
.       nr #CAPS_WAS_ON 1
.       CAPS OFF
.    \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#ENDNOTES]=1 \{\
.\" Single-spaced endnotes have a different lead
.          if \\n[#EN_SINGLESPACE] \{\
.             nr #RESTORE_DOC_LEAD \\n[#DOC_LEAD]
.             nr #DOC_LEAD \\n[#EN_LEAD]u
.          \}
.       \}
.    \}
.    if !n .nop \X'ps: exec 0 setlinejoin'\X'ps: exec 0 setlinecap'
.    sp -1v
.    if \\n[#DOC_TYPE]=5 \{\
.       if \\n[#SLIDE_HEADERS] \{\
.          HEADERS
.          if \\n[#SLIDE_FOOTERS] \{\
.             FOOTERS off
.\" So rule prints after header on first page
.             if !r #SKIP_RULE \{\
.                sp
.                if \\n[#HEADER_RULE] .HEADER_RULE
.                nr #SKIP_RULE 1
.             \}
.          \}
.       \}
.    \}
.    ie \\n[#HEADERS_ON] .PRINT_HDRFTR
.    el \{\
.       if \\n[#PAGE_NUM_V_POS]=1 \
.          if \\n[#PAGINATE] .PRINT_PAGE_NUMBER
.    \}
.    sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#ENDNOTES]=1 \{\
.          if \\n[#EN_SINGLESPACE] \{\
.             nr #DOC_LEAD \\n[#RESTORE_DOC_LEAD]u
.             rr #RESTORE_DOC_LEAD
.          \}
.       \}
.    \}
.    nr #PAGE_TOP \\n[nl]
.    ev
.    po \\n[#L_MARGIN]u
.    if \\n[#RECTO_VERSO] .nr #L_MARGIN +\\n[#L_MARGIN_DIFF]
.    if \\n[#CAPS_WAS_ON] \{\
.       CAPS
.       rr #CAPS_WAS_ON
.    \}
.    if \\n[#TAB_ACTIVE] .TAB \\n[#CURRENT_TAB]
.    if \\n[#QUOTE] \{\
.       ie \\n[#TAB_ACTIVE] .TAB \\n[#CURRENT_TAB]
.       el \{\
.          ie \\n[#Q_OFFSET_VALUE] .nr #Q_OFFSET \
\\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE])
.          el .nr #Q_OFFSET \\n[#L_MARGIN]+\\*[$Q_OFFSET_VALUE]
.          po \\n[#Q_OFFSET]u
.       \}
.       if \\n[#PRINT_STYLE]=2 .sp \\n[#Q_LEAD_DIFF]u
.    \}
.    if \\n[#IN_LIST] \
.       po +\\n[#LIST_OFFSET_VALUE]u
.    if \\n[#RESET_FN_COUNTERS]=1 \{\
.       rr #RESET_FN_COUNTERS
.       PROCESS_FN_IN_DIVER
.       nr #FN_COUNT \\n[#SAVED_FN_COUNT] 1
.       if \\n[#COLUMNS]=1 .nr #FN_COUNT_FOR_COLS \\n[#SAVED_FN_COUNT_FOR_COLS] 1
.       ie \\n[#RESET_FN_NUMBER]=1 .nr #FN_NUMBER \\n[#SAVED_FN_NUMBER] 1
.       el .nr #FN_NUMBER \\n[#FN_NUMBER] 1
.       rm FN_IN_DIVER
.       if dRUNON_FN_IN_DIVER .rm RUNON_FN_IN_DIVER
.    \}
.    if \\n[#EPIGRAPH] \{\
.       ie \\n[#TAB_ACTIVE] .TAB \\n[#CURRENT_TAB]
.       el \{\
.          ie r#EPI_OFFSET_VALUE \
.             nr #EPI_OFFSET \
\\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE])
.          el \
.             nr #EPI_OFFSET \\n[#L_MARGIN]+\\*[$EPI_OFFSET_VALUE]
.          po \\n[#EPI_OFFSET]u
.       \}
.    \}
.    ie \\n[#EPIGRAPH] \{\
.       ie !\\n[#EPI_ACTIVE] \{\
.          ns
.          rr #EPI_ACTIVE
.       \}
.       el \{\
.          ie \\n[#EPI_FITS] .ns
.          el .sp \\n[#DOC_LEAD]u-\\n[#EPI_LEAD]u
.       \}
.    \}
.    el .ns
.    if \\n[#COLUMNS] \{\
.       nr #FN_COUNT_FOR_COLS 0 1
.       nr #L_MARGIN \\n[#DOC_L_MARGIN]
.       if \\n[#RECTO_VERSO] .COLUMNS \\n[#NUM_COLS] \\n[#GUTTER]u
.       nr #COL_NUM 0 1
.       mk dc
.       po \\n[#COL_\\n+[#COL_NUM]_L_MARGIN]u
.       nr #L_MARGIN \\n[.o]
.       if \\n[#TAB_ACTIVE] .TAB \\n[#CURRENT_TAB]
.       ll \\n[#COL_L_LENGTH]u
.       ta \\n[.l]u
.       if \\n[#QUOTE] \{\
.          ie \\n[#\\*[BQ]_OFFSET_VALUE] \
.             po +(\\n[#PP_INDENT]u*\\n[#\\*[BQ]_OFFSET_VALUE]u)
.          el \
.             po +\\*[$\\*[BQ]_OFFSET_VALUE]
.       \}
.       if \\n[#EPIGRAPH] \{\
.          if \\n[#EPI_ACTIVE] \{\
.             ie \\n[#EPI_FITS] .
.             el .nr dc -\\n[#EPI_LEAD_DIFF]
.          \}
.          ie r#EPI_OFFSET_VALUE \{\
.             po \
\\n[#COL_\\n[#COL_NUM]_L_MARGIN]u+(\\n[#PP_INDENT]u*\\n[#EPI_OFFSET_VALUE]u)
.          \}
.          el .po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u+\\*[$EPI_OFFSET_VALUE]
.       \}
.    \}
.    rr #FROM_HEADER
.    rr #DEFER_SPACE_ADDED
.    if !\\n[#FN_DEPTH] .if r #DIVERTED .rr #DIVERTED
.    if \\n[#MN_OVERFLOW_LEFT]=1 \{\
.       MN LEFT
.       nf
.       MN_OVERFLOW_LEFT
.       MN
.    \}
.    if \\n[#MN_OVERFLOW_RIGHT]=1 \{\
.       MN RIGHT
.       nf
.       MN_OVERFLOW_RIGHT
.       MN
.    \}
.    rm MN_OVERFLOW_LEFT
.    rr #MN_OVERFLOW_LEFT
.    rr #no-repeat-MN-left
.    rm MN_OVERFLOW_RIGHT
.    rr #MN_OVERFLOW_RIGHT
.    rr #no-repeat-MN-right
.    if \\n[#PRE_COLLATE]=1 .rr #PRE_COLLATE
.    if \\n[#UNDERLINE_WAS_ON]=1 \{\
.       vs 0
.       ie !n \
.          nop \R'#UNDERLINE_ON 1'\X'ps: exec \\n[_w] \\n[_d] decorline'
.       el .ul 1000
.       br
.       ns
.       rr #UNDERLINE_WAS_ON
.    \}
.    if \\n[#RESTORE_PAGINATION] \{\
.       PAGINATE
.       rr #RESTORE_PAGINATION
.    \}
.    ch RR_@TOP
.    ie \\n[tbl*have-header] .rr @TOP
.    el .wh \\n[nl]u+1u RR_@TOP
.    if \\n[#FLEX_ACTIVE] \{\
.       if \\n[#RESTORE_FLEX] \{\
.          rr #NO_FLEX
.          rr #RESTORE_FLEX
.       \}
.       if \\n[#RESTORE_COL_FLEX] \{\
.          rr #NO_FLEX
.          rr #RESTORE_COL_FLEX
.       \}
.    \}
.\" Don't flex the last page/col, or the page/col before a COLLATE,
.\" NEWPAGE, COL_NEXT, or BLANKPAGE.
.    if !dPDF.EXPORT \{\
.       if \\n[#FLEX_ACTIVE] \
.          if !\\n[#NO_FLEX] \
.             nr #RESTORE_FLEX 1
.       if '\\*[last-page]'\\n%@\\n[#COL_NUM]' \
.          if !\\n[#NO_FLEX] .nr #NO_FLEX 1
.       if '\\*[pre-collate-\\n%]'\\n%@\\n[#COL_NUM]' \
.          if !\\n[#NO_FLEX] .nr #NO_FLEX 1
.       if '\\*[pre-newpage-\\n%]'\\n%@\\n[#COL_NUM]' \
.          if !\\n[#NO_FLEX] .nr #NO_FLEX 1
.       if d page-\\n%@\\n[#COL_NUM] .nr #NO_FLEX 1
.    \}
.    ie \\n[defer] .PROCESS_FLOATS
.    el \{\
.\" These two sets of conditions only occur if the .br in .TS causes
.\" a page break.
.       if !\\n[doing-tbl] \{\
.          if (\\n[tbl*have-caption]=1)&(\\n[tbl*caption-after-label]=0) \{\
.             RESTORE_SPACE
.             if !\\n[span] \{\
.                ie \\n[#MLA] .sp \\n[tbl*label-lead-diff]u
.                el .sp \\n[tbl*caption-lead-diff]u
.             \}
.          \}
.       \}
.    \}
.\" So tables without TH that don't fit don't overprint first row
.\" at top of page
.    ie \\n[tbl*no-header] \{\
.       rs
.       nop \&
.       vpt
.       rr \\n[tbl*no-header]
.       SHIM_1
.    \}
.    el .vpt
.    if \\n[span] \{\
.       ev FLOAT
.       if \\n[#INDENT_LEFT_ACTIVE] .in \\n[#L_INDENT]u/2u
.       nf
.       RESTORE_SPACE
.       if !\\n[tbl*no-top-hook] \
.          if \\n[tbl*have-header:1] .tbl*print-header
.       ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.       ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u
.    \}
.    if !\\n[begin-tbl] \
.       if !r tbl*no-top-hook .tbl@top-hook
.    rr tbl*no-top-hook
.    if r flex:force .rr flex:force
.    rr ref*last
.    if !\\n[float*defer] .ev 0
.END
\#
\# ====================================================================
\#
\# +++FOOTERS+++
\#
\# FOOTERS (off or on)
\# -------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns footers at the bottom of the page off or on.
\# *Notes:
\#   Default is off.  If on, page numbers automatically go at
\#   the top, centered, unless pagination has been turned off,
\#   or the pagenumber position has been changed to left or right.
\#
.MAC FOOTERS END
.    ie '\\$1'' \{\
.       rr #HEADERS_ON
.       nr #FOOTERS_ON 1
.       PAGENUM_POS TOP CENTER
.    \}
.    el .nr #FOOTERS_ON 0
.END
\#
\# FOOTER MARGIN
\# -------------
\# *Argument:
\#   <footer margin>
\# *Function:
\#   Creates or modifies register #FOOTER_MARGIN which holds the
\#   amount of space to leave between the page number and the bottom
\#   of the page.
\# *Notes:
\#   Unit of measure required.  Default is 3P.
\#
.MAC FOOTER_MARGIN END
.    ie \\n%>0 .nr #FOOTER_MARGIN (\\$1)
.    el .
.END
\#
\# FOOTER GAP
\# ----------
\# *Argument:
\#   <distance from end of running text to page # or footer>
\# *Function:
\#   Creates or modifies register #FOOTER_GAP which holds the
\#   amount of space to leave between running text and the page number.
\# *Notes:
\#   Requires unit of measure.  Default is 3P.  Measured baseline to
\#   baseline.
\#
.MAC FOOTER_GAP END
.    ie \\n%>0 .nr #FOOTER_GAP (\\$1)
.    el .
.END
\#
\# FOOTER
\# ------
\# *Arguments:
\#   <none>
\# *Function:
\#   Gathers strings for flex-spacing, processes margin notes and
\#   footnotes, prepares for move to next column or page.  Places
\#   footer at bottom of page if #FOOTERS=1, otherwise places page
\#   number at bottom of page (if #PAGINATE=1).  Page numbers are
\#   in arabic or roman according to COPYSTYLE.  DRAFT starts the
\#   document at page 1 regardless of PAGENUMBER.  FINAL respects
\#   PAGENUMBER.
\#
.MAC FOOTER END
.    if r #START .rr #START
.    CALCULATE_FLEX
.    if \\n[#DOING_COVERTEXT] \{\
.       tm1 "[mom]: COVERTEXT exceeds cover page depth.
.       ab   [mom]: Aborting '\\n[.F]'.
.    \}
.    vpt 0
.    rr #LB_4_HD
.    rr #QUOTE_4_HD
.    nr #SAVED_LEAD \\n[.v]
.    if !r pg-trans .nr pg-trans 0 1
.    ev PAGE_TRANSITION\\n+[pg-trans]
.    pdfmarksuspend
.    ie !n .nop \X'ps: exec decornone'
.    el .ul 0
.    br
.    if \\n[#UNDERLINE_ON]=1 .nr #UNDERLINE_WAS_ON 1
.    if \\n[MN-left]>0 \{\
.       if !\\n[#no-repeat-MN-left]=1 \{\
.          MNbottom-left
.          nr #no-repeat-MN-left 1
.       \}
.       if '\\n[.z]'MN_OVERFLOW_LEFT' \{\
.          di
.          nr #MN_OVERFLOW_LEFT 1
.          rr #OVERFLOW_LEFT
.       \}
.    \}
.    if \\n[MN-right]>0 \{\
.       if !\\n[#no-repeat-MN-right]=1 .MNbottom-right
.       if '\\n[.z]'MN_OVERFLOW_RIGHT' \{\
.          di
.          nr #MN_OVERFLOW_RIGHT 1
.          rr #OVERFLOW_RIGHT
.       \}
.    \}
\# Table bottom hook, draws the table borders in
\# multipage boxed tables.
.    tbl@bottom-hook
.    ch MN_OVERFLOW_TRAP
.    nr #L_MARGIN_DIFF \\n[#L_MARGIN]-\\n[#DOC_L_MARGIN]
.    if !\\n[#FN_DEFER] \{\
.       nr #DIVER_DEPTH 0
.       if \\n[#FN_DEPTH] \{\
.          if \\n[#DIVERTED]=3 .nr #FN_DEPTH +\\n[#VFP_DIFF]
.          vpt 0
.          sp \
|\\n[#PAGE_LENGTH]u-(\\n[#B_MARGIN]u+\\n[#FN_DEPTH]u-\\n[#DOC_LEAD]u)
.          vpt
.          po \\n[#DOC_L_MARGIN]u
.          if \\n[#COLUMNS] \{\
.             po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.             nr #L_MARGIN \\n[.o]
.             nr #FROM_FOOTER 1
.          \}
.          nf
.          ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u
.          FOOTNOTES
.          rm FOOTNOTES
.          if d RUNON_FOOTNOTES   .rm RUNON_FOOTNOTES
.          if \\n[#PRINT_STYLE]=1 .vs \\n[#SAVED_LEAD]u
.          if \\n[#PRINT_STYLE]=2 .vs \\n[#SAVED_LEAD]u
.          if '\\n[.z]'FN_OVERFLOW' \{\
.             di
.             nr #FN_OVERFLOW_DEPTH \\n[#DIVER_DEPTH]
.          \}
.          nr #FN_COUNT_AT_FOOTER \\n[#FN_COUNT]
.          nr #FN_COUNT 0
.          if \\n[#COL_NEXT] \{\
.             ie !\\n[#COL_NUM]=\\n[#NUM_COLS] .nr #COL_NUM \\n-[#COL_NUM]
.             el .nr #COL_NUM \\n[#NUM_COLS] 1
.          \}
.       \}
.       rr #DIVERTED
.    \}
.    nr @TOP 1
.    ie \\n[#COLUMNS]=1 \{\
.       ie (\\n[#COL_NUM]=\\n[#NUM_COLS]):(\\n[#NEWPAGE]=1) .DO_FOOTER
.       el \{\
.          ie (\\n[#ENDNOTES]=1):(\\n[#BIBLIOGRAPHY]=1) \{\
.             if \\n[#ENDNOTES] .sp |\\n[ec]u-\\n[#EN_LEAD]u
.             if \\n[#BIBLIOGRAPHY] .sp |\\n[bc]u-\\n[#BIB_LEAD]u
.          \}
.          el \{\
.            vs \\n[#SAVED_LEAD]u
.            rt \\n[dc]u
.            nr flex-spaces 0
.          \}
.          if d page-\\n%@\\n[#COL_NUM] \{\
.             rr #NO_FLEX
.             rr #RESTORE_COL_FLEX
.          \}
.          po \\n[#COL_\\n+[#COL_NUM]_L_MARGIN]u
.          if !dPDF.EXPORT \{\
.             if \\n[#FLEX_ACTIVE] \{\
.                if !\\n[#NO_FLEX] \{\
.                   if '\\*[last-page]'\\n%@\\n[#COL_NUM]' \
.                       nr #NO_FLEX 1
.                   if '\\*[pre-collate]'\\n%@\\n[#COL_NUM]' \
.                       nr #NO_FLEX 1
.                   if '\\*[pre-newpage-\\n%]'\\n%@\\n[#COL_NUM]' \{\
.                      nr #NO_FLEX 1
.                      nr #RESTORE_FLEX 1
.                   \}
.                   if d page-\\n%@\\n[#COL_NUM] \{\
.                      nr #NO_FLEX 1
.                      nr #RESTORE_COL_FLEX 1
.                   \}
.                \}
.             \}
.          \}
.          nr #L_MARGIN \\n[.o]
.          if \\n[#FN_DEPTH] .PROCESS_FN_LEFTOVER
.          vs \\n[#SAVED_LEAD]u
.          if \\n[#PREV_FN_DEFERRED] .nr #PREV_FN_DEFERRED 2
.          rr #RULED
.          if !\\n[#EPIGRAPH] .rr #COL_NEXT
.          if !\\n[#QUOTE] .rr #COL_NEXT
.          if \\n[#RESET_FN_COUNTERS]=1 \{\
.             rr #RESET_FN_COUNTERS
.             PROCESS_FN_IN_DIVER
.             LS \\n[#SAVED_LEAD]u
.             nr #FN_COUNT \\n[#FN_COUNT] 1
.             nr #FN_COUNT_FOR_COLS \\n[#FN_COUNT_FOR_COLS] 1
.             rm FN_IN_DIVER
.             if dRUNON_FN_IN_DIVER .rm RUNON_FN_IN_DIVER
.          \}
.          rr #DEFER_SPACE_ADDED
.          if \\n[#TAB_ACTIVE] .TAB \\n[#CURRENT_TAB]
.          if \\n[#QUOTE] \{\
.             ie \\n[#TAB_ACTIVE] .TAB \\n[#CURRENT_TAB]
.             el \{\
.                ie \\n[#Q_OFFSET_VALUE] \
.                   nr #Q_OFFSET \
\\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE])
.                el \
.                   nr #Q_OFFSET \\n[#L_MARGIN]+\\*[$Q_OFFSET_VALUE]
.                if \\n[#COLUMNS] \{\
.                   ie \\n[#Q_OFFSET_VALUE] .nr #Q_OFFSET \
\\n[#COL_\\n[#COL_NUM]_L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE])
.                   el .nr #Q_OFFSET \
\\n[#COL_\\n[#COL_NUM]_L_MARGIN]+\\*[$Q_OFFSET_VALUE]
.                \}
.                po \\n[#Q_OFFSET]u
.             \}
.          \}
.          if \\n[#EPIGRAPH] \{\
.             ie \\n[#TAB_ACTIVE] .TAB \\n[#CURRENT_TAB]
.             el \{\
.                ie r#EPI_OFFSET_VALUE .nr #EPI_OFFSET \
\\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE])
.                el .nr #EPI_OFFSET \
\\n[#L_MARGIN]+\\*[$EPI_OFFSET_VALUE]
.                if \\n[#COLUMNS] \{\
.                   ie r#EPI_OFFSET_VALUE .nr #EPI_OFFSET \
\\n[#COL_\\n[#COL_NUM]_L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE])
.                   el .nr #EPI_OFFSET \
\\n[#COL_\\n[#COL_NUM]_L_MARGIN]+\\*[$EPI_OFFSET_VALUE]
.                \}
.                po \\n[#EPI_OFFSET]u
.             \}
.          \}
.          ie \\n[tbl*interrupted] \{\
.             tbl*print-header
.             rr tbl*interrupted
.            \}
.          el .if !r tbl*no-top-hook .tbl@top-hook
.          rr tbl*no-top-hook
.          ie \\n[#EPIGRAPH] \{\
.             ie !\\n[#EPI_ACTIVE] \{\
.                ns
.                rr #EPI_ACTIVE
.             \}
.             el \{\
.                sp |\\n[dc]u+(\\n[#DOC_LEAD]u-\\n[#EPI_LEAD]u)
.                rr #EPI_ACTIVE
.             \}
.          \}
.          el .ns
.          ev
.       \}
.       ns
.       rr #DIVERTED
.       ch RR_@TOP
.       wh \\n[nl]u+1u RR_@TOP
.       if \\n[tbl*have-header] .tbl@bottom-hook
.       if \\n[defer] .PROCESS_FLOATS
.       ie \\n[tbl*no-header] \{\
.          rs
.          nop \&
.          vpt
.          rr \\n[tbl*no-header]
.          SHIM_1
.       \}
.       el .vpt
.       if '\\n[.ev]'caption' .rs
.       if \\n[tbl*interrupted] .tbl*print-header
.       rr tbl*interrupted
.    \}
.    el .DO_FOOTER
.    pdfmarkrestart
.END
\#
\# PROCESS FOOTER
\# --------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Prints footer (page number, or 3-part footer).
\#   Resets CAPS and UNDERLINE if they were on.
\#
.MAC DO_FOOTER END
.\" Part of workaround for refer spitting out a blank page if the
.\" last reference falls on the bottom line.
.    if \\n[num*refs] \{\
.       if \\n[ref*num]=\\n[num*refs] \{\
.          rr num*refs
.          nr ref*last 1
.       \}
.    \}
.    ie !\\n[#DOC_TYPE]=5 .PRINT_FOOTER
.    el .vpt
.    if !\\n[ref*last] \{\
.       ie \\n[defer]>0 \{\
\c
'          bp
.       \}
.       el 'bp
.    \}
.END
\#
.MAC PRINT_FOOTER END
.    if r #SAVED_FOOTER_POS .ch FOOTER \\n[#SAVED_FOOTER_POS]u
.    rr #SAVED_FOOTER_POS
.    vpt 0
.    sp -1
.    ev FOOTER
.    ie n \
.       sp |\\n[#PAGE_LENGTH]u-\\n[#FOOTER_MARGIN]u
.    el \
.       sp |\\n[#PAGE_LENGTH]u-\\n[#FOOTER_MARGIN]u-\\n[#FOOTER_ADJ]u
.    mk y
.    UNDERLINE OFF
.    po \\n[#DOC_L_MARGIN]u
.    ll \\n[#DOC_L_LENGTH]u
.    ta \\n[.l]u
.    if \\n[#PRINT_STYLE]=1 .TYPEWRITER
.    if \\n[#PRINT_STYLE]=2 \{\
.       fam  \\*[$HDRFTR_FAM]
.       ft   R
.       ps \\n[#DOC_PT_SIZE]u\\*[$HDRFTR_SIZE_CHANGE]
.    \}
.    nr #HDRFTR_PT_SIZE \\n[#PT_SIZE]
.    if \\n[#CAPS_ON] \{\
.       nr #CAPS_WAS_ON 1
.       CAPS OFF
.    \}
.    ie \\n[#FOOTERS_ON] \{\
.       if !\\n[#SKIP_FOOTER]>0 .PRINT_HDRFTR
.       if \\n[#HDRFTR_BOTH] \
.          HEADER_RECTO \\*[$HDR_RECTO_QUAD] "\\*[$HDR_RECTO_STRING]"
.       if \\n[#DOC_TYPE]=5 .FOOTERS
.    \}
.    el \{\
.       if \\n[#PAGINATE] \{\
.          if \\n[#PAGE_NUM_V_POS]=2 \
.             if !\\n[#SKIP_FOOTER]>0 .PRINT_PAGE_NUMBER
.       \}
.    \}
.    rr #SKIP_FOOTER
.    if \\n[#CAPS_WAS_ON] \{\
.       CAPS
.       rr #CAPS_WAS_ON
.    \}
.    ev
.    vpt
.END
\#
\# ====================================================================
\#
\# +++HEADERS AND FOOTERS+++
\#
\# HEADERS_AND_FOOTERS
\# -------------------
\# *Arguments:
\#   HEADER_RECTO_QUAD \
\#   HEADER_RECTO_STRING \
\#   FOOTER_RECTO_QUAD \
\#   FOOTER_RECTO_STRING \
\#   HEADER_VERSO_QUAD \
\#   HEADER_VERSO_STRING \
\#   FOOTER_VERSO_QUAD \
\#   FOOTER_VERSO_STRING
\#   | <anything>
\# *Function:
\#   Allows having both headers and footers.  Sets register
\#   #HDRFTR_BOTH to 1; collects HEADER/FOOTER_RECTO/VERSO
\#   information; appends FOOTER_RECTO and FOOTER_VERSO to
\#   START and turns off pagination; appends to macros
\#   PRINT_USERDEF_HDRFTR and HEADER the necessary number
\#   register manipulations and redefinitions of the
\#   HEADER/FOOTER_RECTO/VERSO strings so that both
\#   headers and footers get printed, with the appropriate
\#   strings for each
\# *Notes:
\#   Works in conjunction with HDRFTR_RECTO and HDRFTR_VERSO (qqv.),
\#   ergo all style changes must be done inline in the strings
\#   passed as arguments.
\#
.MAC HEADERS_AND_FOOTERS END
.    ie \\n[#NUM_ARGS]>1 \{\
.    nr #HDRFTR_BOTH 1
.    nr #FOOTERS_ON  1
.    if !r#HEADER_RULE .nr #HEADER_RULE 1
.    if !r#FOOTER_RULE .nr #FOOTER_RULE 1
.    ds $HDR_RECTO_QUAD   \\$1
.    ds $HDR_RECTO_STRING \\$2
.    ds $FTR_RECTO_QUAD   \\$3
.    ds $FTR_RECTO_STRING \\$4
.    ds $HDR_VERSO_QUAD   \\$5
.    ds $HDR_VERSO_STRING \\$6
.    ds $FTR_VERSO_QUAD   \\$7
.    ds $FTR_VERSO_STRING \\$8
.am START DONE
.   if \\\\n[#HDRFTR_BOTH]=1 \{\
.      FOOTER_RECTO \\\\*[$FTR_RECTO_QUAD] "\\\\*[$FTR_RECTO_STRING]"
.      FOOTER_VERSO \\\\*[$FTR_VERSO_QUAD] "\\\\*[$FTR_VERSO_STRING]"
.      if \\\\n[#HEADER_RULE]=1 .HEADER_RULE
.      ie \\\\n[#FOOTER_RULE]=1 .FOOTER_RULE
.      el .FOOTER_RULE OFF
.      if r #PAGINATE .rr #PAGINATE
.      if r #PAGE_NUM_V_POS .rr #PAGE_NUM_V_POS
.   \}
.DONE
.am PRINT_USERDEF_HDRFTR DONE
.   if \\\\n[#HDRFTR_BOTH]=1 \{\
.      if \\n[#FOOTERS_ON]=1 \{\
.         if !\\\\n[#COLLATE]=1 \{\
.            HEADER_RECTO \\*[$HDR_RECTO_QUAD] "\\*[$HDR_RECTO_STRING]"
.            HEADER_VERSO \\*[$HDR_VERSO_QUAD] "\\*[$HDR_VERSO_STRING]"
.            rr #FOOTERS_ON
.            nr #HEADERS_ON 1
.            ie \\\\n[#HEADER_RULE]=1 .HEADER_RULE
.            el .HEADER_RULE OFF
.         \}
.      \}
.      if \\n[#HEADERS_ON]=1 \{\
.         FOOTER_RECTO \\*[$FTR_RECTO_QUAD] "\\*[$FTR_RECTO_STRING]"
.         FOOTER_VERSO \\*[$FTR_VERSO_QUAD] "\\*[$FTR_VERSO_STRING]"
.      \}
.   \}
.DONE
.am HEADER DONE
.   if \\\\n[#HDRFTR_BOTH]=1 \{\
.      if r #START_FOR_FOOTERS .rr #START_FOR_FOOTERS
.      rr #HEADERS_ON
.      nr #FOOTERS_ON 1
.      FOOTER_RECTO \\*[$FTR_RECTO_QUAD] "\\*[$FTR_RECTO_STRING]"
.      FOOTER_VERSO \\*[$FTR_VERSO_QUAD] "\\*[$FTR_VERSO_STRING]"
.      ie \\\\n[#FOOTER_RULE]=1 .FOOTER_RULE
.      el .FOOTER_RULE OFF
.   \}
.DONE
.    \}
.    el \{\
.       rr #HDRFTR_BOTH
.       rr #USERDEF_HDRFTR
.       rm $USERDEF_HDRFTR_RECTO
.       rm $USERDEF_HDRFTR_VERSO
.       FOOTERS OFF
.       HEADERS
.       if \\n[#COLLATE]=1 \{\
.          nr #HEADER_STATE 1
.          nr #PAGINATION_STATE 1
.       \}
.       PAGINATE
.       PAGENUM_POS BOTTOM CENTER
.       nr #HF_OFF 1
.    \}
.END
\#
\# ====================================================================
\#
\# +++HEADINGS+++
\#
.char \[hd-num-spacer]     \0
.char \[parahead-spacer]   \~\~
.char \[toc-hd-num-spacer] \h'\w'\[en]'u'
.ds toc-word-space \ \" ie an unbreakable space
\#
\# HEADING
\# -------
\# *Arguments:
\#   <heading level> [PARAHEAD] [NAMED <pdf-id>] <heading text>
\# *Function:
\#   Assigns a heading level to the heading text and prints heading
\#   in the style set up for that level.  If PARAHEAD given, the
\#   heading is attached to the body of the paragraph.  If NAMED
\#   given, creates a target for pdf links.  Collects the heading
\#   for the TOC and sets TOC indenting appropriate for the level.
\# *Notes:
\#   If PARAHEAD given, HEADING must come after PP.
\#
.MAC HEADING END
'    br
.    if \\n[@TOP] .br
.    if !\B'\\$1' \{\
.       tm1 "[mom]: The first argument to \\$0 must be a numeric heading level.
.       ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.    \}
.    if r #QUOTE     .rr #QUOTE
.    if r #END_QUOTE .rr #END_QUOTE
.    if r #EPIGRAPH  .rr #EPIGRAPH
.    vs \\n[#DOC_LEAD]u
.    if \\$1<\\n[#LEVEL] \
.       nr #ACTIVE_LEVELS \\n[#LEVEL] \" loop count for resetting numbering registers
.    nr #LAST_LEVEL \\n[#LEVEL]       \" used during TOC collection, if SPACE_TOC_ITEMS
.    nr #LEVEL \\$1                   \" resets #LEVEL to arg
.    shift
.    nr #ARG_NUM 0 1
.    while \\n+[#ARG_NUM]<=2 \{\
.      if '\\$1'NAMED' \{\
.         ds PDF_NM "\\$1 \\$2
.         shift 2 \" \\$1 is now heading text
.      \}
.      if '\\$1'PARAHEAD' \{\
.         nr #PARAHEAD 1
.         shift \" \\$1 is now NAMED, if we have it; otherwise heading text
.      \}
.    \}
.\" Spacing
.    if \\n[#Q_LEAD_DIFF_CHECK] .sp -1
.    if \\n[.t]<\\n[.v] .nr nl-from-heading \\n[nl]
.    ie !\\n[#PARAHEAD] \{\
.       if !\\n[@TOP] \{\
.          nr #HEAD 1
.          ie !\\n[#START] \{\
.             nr #HEADING_NEEDS \\n[#NUM_ARGS]v+\\*[$HEAD_\\n[#LEVEL]_NEEDS]v+1v
.             if \\n[#HEAD_\\n[#LEVEL]_SPACE_AFTER] .nr #HEADING_NEEDS +1v
.             if \\n[.t]<\\n[#HEADING_NEEDS] .sp \\n[.t]u
.             vpt 0
.             if !\\n[#SPACE_ADDED] .if !\\n[#LINEBREAK] .sp
.          \}
.          el \{\
.             ie !\\n[#PP] \{\
.                rr #START
.                RESTORE_SPACE
.                if !\\n[#SPACE_ADDED] \
.                   if !\\n[#COLUMNS] .sp
.             \}
.             el .sp
.          \}
.          if \\n[#EPIGRAPH] \
.             if \\n[#SINGLE_SPACE] .sp
.       \}
.       if \\n[#PP_SPACE] \
.          if \\n[#QUOTE_4_HD] .sp .5v
.       ie !\\n[#SPACE_ADDED] \{\
.          if !\\n[.ns] \{\
.             ie !\\n[#NO_SHIM] \
.                if !\\n[#HEAD_\\n[#LEVEL]_NO_SHIM] .SHIM
.             el \{\
.                if !\\n[#NO_FLEX] \
.                   if !\\n[#HEAD_\\n[#LEVEL]_NO_FLEX] .FLEX 
.             \}
.          \}
.       \}
.       el .rr #SPACE_ADDED
.       vpt
.    \}
.    el \{\
.       if \\n[#NUM_ARGS]>1 \{\
.          tm1 "[mom]: Error at line \\n[.c], \\$0.
.          tm1 "       PARAHEAD may not be given more than 1 line of text.
.          ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.       \}
.       vpt 0
.       if !(\\n[#PRINT_STYLE]=1)&(\\n[#SINGLE_SPACE]=1) .sp -1v
.       if \\n[#QUOTE_4_HD] \{\
.          sp -1v
.          if \\n[#PP_SPACE] \{\
.             sp .5v
.             SHIM
.         \}
.       \}
.       if (\\n[#QUOTE_4_HD]=0)&(\\n[#LB_4_HD]=0)&(\\n[#START]=0) \
.          if !\\n[#LB_4_PARAHEAD] .sp -1v
.    \}
.    ev HEADING
.    evc 0
.\" Style
.    if \\n[#PRINT_STYLE]=2 \{\
.       fam \\*[$HEAD_\\n[#LEVEL]_FAM]
.       ft  \\*[$HEAD_\\n[#LEVEL]_FT]
.       ps  \\n[#DOC_PT_SIZE]u\\*[$HEAD_\\n[#LEVEL]_SIZE]
.       nf
.    \}
.\" Numbering
.    ds $TOC_HD_NUM_PREV \\*[$TOC_HD_NUM]
.    rm $TOC_HD_NUM
.    rm $PDF_HD_NUM
.    ie \\n[#NUMBER_HEAD_\\n[#LEVEL]] \{\
.       if \\n[#PREFIX_CH_NUM] .ds $HD_NUM \\n[#CH_NUM].
.       nr #HEAD_\\n[#LEVEL]_NUM +1       \" incremented manually here; still auto-increments
.\" Reset numbering registers for headings beneath current level
.       nr @LEVEL \\n[#LEVEL] 1           \" loop step
.       nr #LOOP \\n[#ACTIVE_LEVELS]      \" loop count
.       while \\n+[@LEVEL]<=\\n[#LOOP] \
.          if \\n[#HEAD_\\n[@LEVEL]_NUM] \
.             nr #HEAD_\\n[@LEVEL]_NUM 0 1
.\" Build numbering strings for body and toc
.       nr @LEVEL 0 1                     \" loop step
.       nr #LOOP \\n[#LEVEL]              \" loop count
.       while \\n+[@LEVEL]<=\\n[#LOOP] \
.          if \\n[#HEAD_\\n[@LEVEL]_NUM] \
.             as $HD_NUM \\n[#HEAD_\\n[@LEVEL]_NUM].
.       ie \\n[#TRUNC_TOC_HD_NUM] \
.          ds $TOC_HD_NUM \\n[#HEAD_\\n[#LEVEL]_NUM].
.       el .ds $TOC_HD_NUM \\*[$HD_NUM]
.       if \\n[#LEVEL]=1 \
.          ds $TOC_HD_NUM_PREV \\*[$TOC_HD_NUM]
.       if \\n[#TOC_NO_HD_NUM] .rm $TOC_HD_NUM
.       if !\\n[#HEAD_\\n[#LEVEL]_NUM]] .rm $TOC_HD_NUM
.       as $HD_NUM \[hd-num-spacer]
.       ds $PDF_HD_NUM \\*[$TOC_HD_NUM]
.       if !'\\*[$TOC_HD_NUM]'' .as $TOC_HD_NUM \[toc-hd-num-spacer]
.       if !'\\*[$PDF_HD_NUM]'' .as $PDF_HD_NUM " "
.    \}
.    el .nr @LEVEL \\n[#LEVEL] 1
.\" TOC collection and formatting
.    nr #TOC_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.    af #TOC_ENTRY_PN \\g[#PAGENUMBER]
.    nr #ARG_NUM 0 1
.    while \\n[#ARG_NUM]<\\n[#NUM_ARGS] \{\
.       as $TOC_HEAD_\\n[#LEVEL]_ITEM "\\$[\\n+[#ARG_NUM]]
.       if \\n[#NUM_ARGS]>\\n[#ARG_NUM] \
.          as $TOC_HEAD_\\n[#LEVEL]_ITEM "\\*[toc-word-space]
.    \}
.    PDF_BOOKMARK \
        \\*[PDF_NM] \\n[#LEVEL]+1 \
        \\*[$PDF_HD_NUM] \\*[$TOC_HEAD_\\n[#LEVEL]_ITEM]
.    rm PDF_NM
.    rm $PDF_HD_NUM
.    ev TOC_EV
.    ie \\n[#PRINT_STYLE]=1 \{\
.       fam \\*[$TYPEWRITER_FAM]
.       ft  R
.       ps  \\*[$TYPEWRITER_PS]
.    \}
.    el \{\
.       FAMILY  \\*[$TOC_HEAD_\\n[#LEVEL]_FAM]
.       FT      \\*[$TOC_HEAD_\\n[#LEVEL]_FT]
.       ps \\n[#TOC_PS]u\\*[$TOC_HEAD_\\n[#LEVEL]_SIZE]
.    \}
.\" Indents for TOC heading levels.
.\" First, numbered heads.  @LEVEL here is #LEVEL+1
.    ie \\n[#NUMBER_HEAD_\\n[#LEVEL]] \{\
.       ie !\\n[#TOC_NO_HD_NUM] \{\
.          ie \\n[#TRUNC_TOC_HD_NUM] \{\
.             if !\\n[#TOC_HEAD_\\n[@LEVEL]_INDENT_SET] \{\
.                ie !\\n[#FROM_STYLE_\\n[@LEVEL]] \{\
.                   ie !\\n[#NUMBER_HEAD_\\n[@LEVEL]] \
.                      nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
\\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]+\
\w'\\*[$TOC_HD_NUM]'+\
1.5m
.                   el \
.                      nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
\\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]+\
\w'\\*[$TOC_HD_NUM]'
.                \}
.                el \
.                   nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
                      \\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]
.             \}
.          \}
.          el \{\
.             if !\\n[#TOC_HEAD_\\n[@LEVEL]_INDENT_SET] \{\
.                ie !\\n[#FROM_STYLE_\\n[@LEVEL]] \{\
.                   ie \\n[#NUMBER_HEAD_\\n-[@LEVEL]] \{\
.                      ie !\\n[#NUMBER_HEAD_\\n+[@LEVEL]] \
.                         nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
\\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]+\
\w'\\*[$TOC_HD_NUM_PREV]'+\
1.5m
.                      el \{\
.\" Get the number of digits in the chapter number
.                         ds ch-num-width \\n[#CH_NUM]
.                         length ch-num-width \\*[ch-num-width]
.                         nr ch-num-width -1
.                         nr num-ch-digits \w'\0'*\\n[ch-num-width]
.                         nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
\\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]+\
\\n[num-ch-digits]+\
\w'.\[toc-hd-num-spacer]'
.                      \}
.                   \}
.                   el \
.                      nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
\\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]+\
\w'\\n[#TOC_HD_NUM].'
.                   ie \\n[#LEVEL]=1 \
.                      nr #TOC_HEAD_\\n+[@LEVEL]_INDENT +\w'\0'
.                   el \{\
.                      if !\\n[#NUMBER_HEAD_\\n[@LEVEL]] \{\
.                         nr @LEVEL \\n+[@LEVEL] 1
.                         nr #TOC_HEAD_\\n+[@LEVEL]_INDENT +\w'\0'
.                      \}
.                   \}
.                \}
.                el \
.                   nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
\\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]+\
\\n[#TOC_HEAD_\\n+[@LEVEL]_INDENT]
.             \}
.             if \\n[#LEVEL]=1 \{\
.                if \\n[#NUMBER_HEAD_\\n[@LEVEL]] \{\
.                   if \\n[#PREFIX_CH_NUM] \
.                      nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
\w'\\*[$TOC_HD_NUM]'
.                \}
.             \}
.          \}
.       \}
.       el \{\
.          ie !\\n[#FROM_STYLE_\\n[@LEVEL]] \{\
.             if !\\n[#TOC_HEAD_\\n[@LEVEL]_INDENT_SET] \
.                nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
                    \\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]+1.5m
.          \}
.          el \{\
.             if !\\n[#TOC_HEAD_\\n[@LEVEL]_INDENT_SET] \
.                nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
\\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]+\
\\n[#TOC_HEAD_\\n+[@LEVEL]_INDENT]
.          \}
.       \}
.    \}
.\" Non-numbered heads
.    el \{\
.       nr @LEVEL \\n[#LEVEL] 1
.\" increments @LEVEL even if false
.       ie \\n[#FROM_STYLE_\\n+[@LEVEL]] \{\
.          if !\\n[#TOC_HEAD_\\n[@LEVEL]_INDENT_SET] \{\
.             nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
\\n[#TOC_HEAD_\\n[#LEVEL]_INDENT]+\
\\n[#TOC_HEAD_\\n[@LEVEL]_INDENT]
.             if !\\n[#LEVEL]=\\n[#LAST_LEVEL] \{\
.                if \\n[#NUMBER_HEAD_\\n[@LEVEL]] \
.                   nr #TOC_HEAD_\\n[#LEVEL]_INDENT \
\\n[#TOC_HEAD_\\n[@LEVEL]_INDENT]+\
\w'\\*[$TOC_HD_NUM_PREV]'
.             \}
.          \}
.       \}
.       el \{\
.          nr #TOC_HEAD_\\n[@LEVEL]_INDENT \
              \\n[#TOC_HEAD_\\n-[@LEVEL]_INDENT]+1.5m
.          if \\n[#LEVEL]=1 \{\
.             if !\\n[#FROM_STYLE_1] \
.                nr #TOC_HEAD_1_INDENT 0
.          \}
.       \}
.    \}
.    nr #TOC_HEAD_\\n[@LEVEL]_INDENT_SET 1
.    HD_TO_TOC
.    rm $TOC_HEAD_\\n[#LEVEL]_ITEM
.\" Print heading
.    if !\\n[#PARAHEAD] .\\*[$HEAD_\\n[#LEVEL]_QUAD]
.    if \\n[#CAPS_ON] \{\
.       CAPS OFF
.       nr #CAPS_RESTORE 1
.    \}
.    if \\n[#HEAD_\\n[#LEVEL]_CAPS] \{\
.       CAPS 
.       nr #CAPS_OFF 1
.    \}
.    if \\n[#SMALLCAPS_ON] \{\
.       SMALLCAPS OFF
.       nr #SMALLCAPS_RESTORE 1
.    \}
.    if \\n[#HEAD_\\n[#LEVEL]_SMALLCAPS] \{\
.       SMALLCAPS 
.       nr #SMALLCAPS_OFF 1
.    \}
.    if !'\\*[$HEAD_\\n[#LEVEL]_COLOR]'' \
.       COLOR \\*[$HEAD_\\n[#LEVEL]_COLOR]
.    nop \X'ps: exec decornone'\c
.    nr #ARG_NUM 0 1
.    while \\n+[#ARG_NUM]<=\\n[#NUM_ARGS] \{\
.       if \\n[#PARAHEAD] \
.          nr #PP_TEXT_OFFSET \
              \w'\\*[$HD_NUM]\\$[\\n[#ARG_NUM]]'+\w'\[parahead-spacer]'
.       if (\\n[#HEAD_\\n[#LEVEL]_UNDERSCORE]=0)&(\\n[#HEAD_\\n[#LEVEL]_UNDERSCORE2]=0) \{\
.          ie \\n[#HD_NUM_INDENT] \{\
.             if !'\\*[$HEAD_\\n[#LEVEL]_QUAD]'CENTER' \
.                ti \\n[#HD_NUM_INDENT]u 
.             PRINT \
"\v'-\\*[$HEAD_\\n[#LEVEL]_BASELINE_ADJ]'\\$[\\n[#ARG_NUM]]
.             br
.          \}
.          el \{\
.             ie !\\n[#PARAHEAD] \{\
.                PRINT \
"\v'-\\*[$HEAD_\\n[#LEVEL]_BASELINE_ADJ]'\\*[$HD_NUM]\\$[\\n[#ARG_NUM]]
.                br
.             \}
.             el \{\
.                if (\\n[#PP]>0):(\\n[#INDENT_FIRST_PARAS]) \{\
.                   if !\\n[#LB_4_PARAHEAD] \{\
.                      if !\\n[#START] \{\
.                         if \\n[#PP_ACTIVE] \{\
.                            ie \\n[#PP]=1 .br
.                            el \{\
.                               nr #PP_TEXT_OFFSET +\\n[#PP_INDENT]
.                               ti \\n[#PP_INDENT]u
.                            \}
.                         \}
.                      \}
.                   \}
.                \}
.                ie \\n[#PRINT_STYLE]=1 \
.                   PRINT "\\*[UL]\\*[$HD_NUM]\\$[\\n[#ARG_NUM]]\\*[ULX]
.                el .PRINT "\\*[$HD_NUM]\\$[\\n[#ARG_NUM]]
.                rr #LB_4_PARAHEAD
.                sp -1v
.             \}
.          \}
.       \}
.       if \\n[#HEAD_\\n[#LEVEL]_UNDERSCORE] \{\
.          nr #SAVED_UL_WEIGHT \\n[#UNDERSCORE_WEIGHT]
.          UNDERSCORE_WEIGHT \\*[$HEAD_\\n[#LEVEL]_UL_WEIGHT]
.          ie \\n[#HD_NUM_INDENT] \{\
.             if !'\\*[$HEAD_\\n[#LEVEL]_QUAD]'CENTER' \
.                ti \\n[#HD_NUM_INDENT]u 
.             UNDERSCORE \\*[$HEAD_\\n[#LEVEL]_UL_GAP] \
                "\v'-\\*[$HEAD_\\n[#LEVEL]_BASELINE_ADJ]'\\$[\\n[#ARG_NUM]]
.             br
.          \}
.          el \{\
.             ie !\\n[#PARAHEAD] \{\
.                UNDERSCORE \\*[$HEAD_\\n[#LEVEL]_UL_GAP] \
"\v'-\\*[$HEAD_\\n[#LEVEL]_BASELINE_ADJ]'\\*[$HD_NUM]\\$[\\n[#ARG_NUM]]
.                br
.             \}
.             el \{\
.                if (\\n[#PP]>0):(\\n[#INDENT_FIRST_PARAS]) \{\
.                   if !\\n[#LB_4_HD] \{\
.                      if !\\n[#START] \{\
.                         if \\n[#PP_ACTIVE] \{\
.                   nr #PP_TEXT_OFFSET +\\n[#PP_INDENT]
.                   if (\\n[#PRINT_STYLE]=1)&(\\n[#SINGLE_SPACE]=1) .sp -1v
.                   ti \\n[#PP_INDENT]u
.                         \}
.                      \}
.                   \}
.                \}
.                UNDERSCORE \\*[$HEAD_\\n[#LEVEL]_UL_GAP] \
                   "\\*[$HD_NUM]\\$[\\n[#ARG_NUM]]
.                sp -1v
.             \}
.          \}
.          nr #UNDERSCORE_WEIGHT \\n[#SAVED_UL_WEIGHT]
.       \}
.       if \\n[#HEAD_\\n[#LEVEL]_UNDERSCORE2] \{\
.          nr #SAVED_UL2_WEIGHT \\n[#UNDERSCORE_WEIGHT]
.          UNDERSCORE_WEIGHT \\*[$HEAD_\\n[#LEVEL]_UL2_WEIGHT]
.          ie \\n[#HD_NUM_INDENT] \{\
.             if !'\\*[$HEAD_\\n[#LEVEL]_QUAD]'CENTER' \
.                ti \\n[#HD_NUM_INDENT]u 
.             UNDERSCORE2 \\*[$HEAD_\\n[#LEVEL]_UL2_GAP_1] \
                \\*[$HEAD_\\n[#LEVEL]_UL2_GAP_2] \
                "\v'-\\*[$HEAD_\\n[#LEVEL]_BASELINE_ADJ]'\\$[\\n[#ARG_NUM]]
.             br
.          \}
.          el \{\
.             ie !\\n[#PARAHEAD] \{\
.                UNDERSCORE2 \\*[$HEAD_\\n[#LEVEL]_UL2_GAP_1] \
                   \\*[$HEAD_\\n[#LEVEL]_UL2_GAP_2] \
"\v'-\\*[$HEAD_\\n[#LEVEL]_BASELINE_ADJ]'\\*[$HD_NUM]\\$[\\n[#ARG_NUM]]
.                br
.             \}
.             el \{\
.                if (\\n[#PP]>0):(\\n[#INDENT_FIRST_PARAS]) \{\
.                   if !\\n[#LB_4_HD] \{\
.                      if !\\n[#START] \{\
.                         if \\n[#PP_ACTIVE] \{\
.                            nr #PP_TEXT_OFFSET +\\n[#PP_INDENT]
.                            if (\\n[#PRINT_STYLE]=1)&(\\n[#SINGLE_SPACE]=1) \
.                               sp -1v
.                            ti \\n[#PP_INDENT]u
.                         \}
.                      \}
.                   \}
.                \}
.                UNDERSCORE2 \\*[$HEAD_\\n[#LEVEL]_UL2_GAP_1] \
\\*[$HEAD_\\n[#LEVEL]_UL2_GAP_2] "\\*[$HD_NUM]\\$[\\n[#ARG_NUM]]
.                sp -1v
.             \}
.          \}
.          nr #UNDERSCORE_WEIGHT \\n[#SAVED_UL2_WEIGHT]
.       \}
.       if !\\n[#HD_NUM_INDENT] .nr #HD_NUM_INDENT \w'\\*[$HD_NUM]'
.    \}
.    if !\\n[#PARAHEAD] \
.       if \\n[#HEAD_\\n[#LEVEL]_SPACE_AFTER] .sp
.    if \\n[#CAPS_OFF] \{\
.       CAPS OFF
.       rr #CAPS_OFF
.    \}
.    if \\n[#CAPS_RESTORE] \{\
.       CAPS
.       rr #CAPS_RESTORE
.    \}
.    if \\n[#SMALLCAPS_OFF] \{\
.       SMALLCAPS OFF
.       rr #SMALLCAPS_OFF
.    \}
.    if \\n[#SMALLCAPS_RESTORE] \{\
.       SMALLCAPS
.       rr #SMALLCAPS_RESTORE
.    \}
.    ev
.    rm $HD_NUM
.    rr #HD_NUM_INDENT
.    if \\n[#PARAHEAD]   .ti \\n[#PP_TEXT_OFFSET]u
.    if !\\n[#PARAHEAD]  .nr #PP 0
.    rr #PARAHEAD
.    if \\n[#LB_4_HD]    .rr #LB_4_HD
.    if \\n[#QUOTE_4_HD] .rr #QUOTE_4_HD
.    if \\n[@TOP] \{\
.       ch RR_@TOP
.       rr @TOP
.       rs
.       nop \&
.       sp -1
.    \}
.    vpt
.    rr nl-from-heading
.END
\#
\# HEADING_STYLE
\# -------------
\# *Arguments:
\#   <level>
\#   FAMILY <family>
\#   FONT   <font>
\#   SIZE   <+|-n>
\#   COLOR  <color>
\#   CAPS | NO_CAPS
\#---when called as HEADING_STYLE, these are also available---
\#   QUAD   <direction>
\#   NUMBER | NO_NUMBER
\#   SPACE_AFTER | NO_SPACE_AFTER
\#   UNDERSCORE <weight> <gap> | UNDERSCORE2 <weight> <gap1> <gap2> 
\#   NO_UNDERSCORE | NO_UNDERSCORE2
\#   BASELINE_ADJUST
\#---when called as TOC_ENTRY_STYLE this is also available---
\#   INDENT
\# *Function:
\#   Sets up complete style parameters for HEADING <level>.  If
\#   invoked as TOC_ENTRY_STYLE, sets up parameters for the
\#   corresponding TOC entry at <level>.
\# *Notes:
\#   Arguments may be given in any order.  Any not given retain
\#   their current values.  Defaults for an initial 9 levels of
\#   heading are set up in PRINTSTYLE.
\#
\#   NUMBER indicates that hierarchic numbering of <level> should be
\#   prepended to heading text.  If invoked as TOC_ENTRY_STYLE,
\#   prepend numbering to TOC entries at <level> (only works if
\#   NUMBER is given to the corresponding HEADING <level>).
\#
\#   INDENT refers to the indent for <level> in the TOC.  It is
\#   measured from the left offset of the entry level above it
\#   (including numbering, if present).  TOC entry levels beneath
\#   <level> will have their indents adjusted accordingly.
\#
.MAC HEADING_STYLE END
.    if !\B'\\$1' \{\
.       tm1 "[mom]: The first argument to \\$0 must be a numeric heading level.
.       ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.    \}
.    nr #LEVEL \\$1
.    if \\n[#FROM_OLDSTYLE] .nr #LEVEL_\\n[#LEVEL]_SET 1
.    shift
.\" Prepend TOC_ to style strings if called as TOC_ENTRY_STYLE
.    if '\\$0'TOC_ENTRY_STYLE' .ds $TOC TOC_
.    nr #ARG_NUM 0 1
.    nr #ATTRIB \\n[#NUM_ARGS]
.    while \\n+[#ARG_NUM]<=\\n[#ATTRIB] \{\
.       if '\\$1'UNDERSCORE' \{\
.          nr #HEAD_\\n[#LEVEL]_UNDERSCORE 1
.          shift
.          if '\\$1'' \{\
.             tm1 "[mom]: The UNDERSCORE argument to \\$0 requires a rule weight.
.             ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.          \}
.          ds $HEAD_\\n[#LEVEL]_UL_WEIGHT \\$1
.          shift
.          if '\\$1'' \{\
.             tm1 "[mom]: The UNDERSCORE argument to \\$0 requires a rule gap.
.             ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.          \}
.          ds $HEAD_\\n[#LEVEL]_UL_GAP \\$1
.          shift
.       \}
.       if '\\$1'NO_UNDERSCORE' \{\
.          rr #HEAD_\\n[#LEVEL]_UNDERSCORE
.          shift
.       \}
.       if '\\$1'UNDERSCORE2' \{\
.          nr #HEAD_\\n[#LEVEL]_UNDERSCORE2 1
.          shift
.          if '\\$1'' \{\
.             tm1 "[mom]: The UNDERSCORE2 argument to \\$0 requires a rule weight.
.             ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.          \}
.          ds $HEAD_\\n[#LEVEL]_UL2_WEIGHT \\$1
.          shift
.          if '\\$1'' \{\
.             tm1 "[mom]: The UNDERSCORE2 argument to \\$0 requires a rule gap.
.             ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.          \}
.          ds $HEAD_\\n[#LEVEL]_UL2_GAP_1 \\$1
.          shift
.          if '\\$1'' \{\
.             tm1 "[mom]: The UNDERSCORE2 argument to \\$0 requires an inter-rule gap.
.             ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.          \}
.          ds $HEAD_\\n[#LEVEL]_UL2_GAP_2  \\$1
.          shift
.       \}
.       if '\\$1'NO_UNDERSCORE2' \{\
.          rr #HEAD_\\n[#LEVEL]_UNDERSCORE2
.          shift
.       \}
.       if '\\$1'SPACE_AFTER' \{\
.          nr #HEAD_\\n[#LEVEL]_SPACE_AFTER 1
.          shift
.       \}
.       if '\\$1'NO_SPACE_AFTER' \{\
.          rr #HEAD_\\n[#LEVEL]_SPACE_AFTER
.          shift
.       \}
.       if '\\$1'FAMILY' \{\
.          shift
.          ds $\\*[$TOC]HEAD_\\n[#LEVEL]_FAM  \\$1
.          shift
.       \}
.       if '\\$1'FONT' \{\
.          shift
.          ds $\\*[$TOC]HEAD_\\n[#LEVEL]_FT   \\$1
.          shift
.       \}
.       if '\\$1'SIZE' \{\
.          shift
.          ds $\\*[$TOC]HEAD_\\n[#LEVEL]_SIZE \\$1
.          shift
.       \}
.       if '\\$1'QUAD' \{\
.          shift
.          ds $QUAD_TYPE \\$1
.          substring $QUAD_TYPE 0 0
.          if '\\*[$QUAD_TYPE]'L' .ds $HEAD_\\n[#LEVEL]_QUAD LEFT
.          if '\\*[$QUAD_TYPE]'C' .ds $HEAD_\\n[#LEVEL]_QUAD CENTER
.          if '\\*[$QUAD_TYPE]'R' .ds $HEAD_\\n[#LEVEL]_QUAD RIGHT
.          shift
.       \}
.       if '\\$1'COLOR' \{\
.          shift
.          ds $\\*[$TOC]HEAD_\\n[#LEVEL]_COLOR \\$1
.          shift
.       \}
.       if '\\$1'BASELINE_ADJUST' \{\
.          shift
.          ds $HEAD_\\n[#LEVEL]_BASELINE_ADJ \\$1
.          shift
.       \}
.       if '\\$1'CAPS' \{\
.          nr #\\*[$TOC]HEAD_\\n[#LEVEL]_CAPS 1
.          shift
.       \}
.       if '\\$1'NO_CAPS' \{\
.          rr #HEAD_\\n[#LEVEL]_CAPS
.          shift
.       \}
.       if '\\$1'SMALLCAPS' \{\
.          nr #\\*[$TOC]HEAD_\\n[#LEVEL]_SMALLCAPS 1
.          shift
.       \}
.       if '\\$1'NO_SMALLCAPS' \{\
.          rr #HEAD_\\n[#LEVEL]_SMALLCAPS
.          shift
.       \}
.       if '\\$1'NUMBER' \{\
.          nr #NUMBER_HEAD_\\n[#LEVEL] 1
.          nr #HEAD_\\n[#LEVEL]_NUM 0 1
.          shift
.       \}
.       if '\\$1'NO_NUMBER' \{\
.          rr #NUMBER_HEAD_\\n[#LEVEL]
.          shift
.       \}
.       if '\\$1'INDENT' \{\
.          shift
.          nr #TOC_HEAD_\\n[#LEVEL]_INDENT \\$1
.          nr #FROM_STYLE_\\n[#LEVEL] 1
.          shift
.       \}
.       if '\\$1'NEEDS' \{\
.          shift
.          ds $HEAD_\\n[#LEVEL]_NEEDS \\$1
.          shift
.       \}
.       if '\\$1'SHIM' \{\
.          rr #HEAD_\\n[#LEVEL]_NO_SHIM
.          shift
.       \}
.       if '\\$1'NO_SHIM' \{\
.          nr #HEAD_\\n[#LEVEL]_NO_SHIM 1
.          shift
.       \}
.       if '\\$1'FLEX' \{\
.          rr #HEAD_\\n[#LEVEL]_NO_FLEX
.          shift
.       \}
.       if '\\$1'NO_FLEX' \{\
.          nr #HEAD_\\n[#LEVEL]_NO_FLEX 1
.          shift
.       \}
.    \}
.    rr #LEVEL
.    if d$TOC .rm $TOC
.END
.
.ALIAS TOC_ENTRY_STYLE HEADING_STYLE
\#
\# OLDSTYLE HEADINGS
\# -----------------
\# *Arguments:
\#   None.
\# *Function:
\#   Called from HEAD, SUBHEAD, and SUBSUBHEAD, sets style
\#   parameters for HEADINGs 1-3 to former mom defaults for those macros.
\#   Any styles already assigned to those levels are retained.
\#
\#   Called by user with no argument, allows use of old style HEAD,
\#   SUBHEAD, and SUBSUBHEAD without generating the deprecated msg.
\# *Notes:
\#   For backward compatibility, and to ease the transition to
\#   the HEADING scheme for heads.
\#
\#   Paraheads must be set with .HEADING <level> PARAHEAD; attempts
\#   to call PARAHEAD abort with an instructive message.
\#
.MAC OLDSTYLE_HEADINGS END
.    if '\\$1'' .nr #SKIP_MSG 1
.    nr #FROM_OLDSTYLE 1 \" Used in HEADING
.    if \\n[#PRINT_STYLE]=1 \{\
.       if !\\n[#LEVEL_1_SET] \{\
.          HEADING_STYLE 1 \
             FONT R \
             SIZE +0 \
             QUAD C \
             CAPS \
             UNDERSCORE .5 2p \
             BASELINE_ADJUST 0 \
             SPACE_AFTER
.            nr #OLDSTYLE_HD 1
.            return
.       \}
.       if !\\n[#LEVEL_2_SET] \{\
.          HEADING_STYLE 2 \
             FONT R \
             SIZE +0 \
             UNDERSCORE .5 2p \
             BASELINE_ADJUST \\n[.v]/8
.            nr #OLDSTYLE_SH 1
.            return
.       \}
.       if !\\n[#LEVEL_3_SET] \{\
.          HEADING_STYLE 3 \
             FONT R \
             SIZE +0 \
             BASELINE_ADJUST \\n[.v]/8
.            nr #OLDSTYLE_SSH 1
.            return
.       \}
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       if !\\n[#LEVEL_1_SET] \{\
.          HEADING_STYLE 1 \
             FAMILY \E*[$DOC_FAM] \
             FONT B \
             SIZE +1 \
             QUAD C \
             CAPS \
             UNDERSCORE .5 2p \
             BASELINE_ADJUST 0 \
             SPACE_AFTER
.            nr #OLDSTYLE_HD 1
.            return
.       \}
.       if !\\n[#LEVEL_2_SET] \{\
.          HEADING_STYLE 2 \
             FAMILY \E*[$DOC_FAM] \
             FONT B \
             SIZE +.5 \
             BASELINE_ADJUST \\n[.v]/8
.            nr #OLDSTYLE_SH 1
.            return
.       \}
.       if !\\n[#LEVEL_3_SET] \{\
.          HEADING_STYLE 3 \
             FAMILY \E*[$DOC_FAM] \
             FONT I \
             SIZE +.5 \
             BASELINE_ADJUST \\n[.v]/8
.            nr #OLDSTYLE_SSH 1
.            return
.       \}
.    \}
.    rr #FROM_OLDSTYLE
.END
\#
\# "Deprecated" message
\#
.MAC DEPRECATED END
.    if !\\n[#SKIP_MSG] \{\
.       tm1 "[mom]: Macro '\\$1' at line \\n[.c] is deprecated.
.       tm1 "       Invoking HEADING \\$2 instead and assigning style defaults
.       tm1 "          from former \\$1 as described in the documentation.
.       tm1 "       If another style is desired, use HEADING_STYLE \\$2 to
.       tm1 "          create it (see docs).
.       tm1 "       Further warnings will not be emitted for \\$1.
.       tm1 "       To avoid this message when using the deprecated HEAD,
.       tm1 "          SUBHEAD, and SUBSUBHEAD macros, add '.OLDSTYLE_HEADINGS'
.       tm1 "          after PRINTSTYLE before START.
.       rm $MACRO
.    \}
.END
\#
\# Wrappers around old-style headings.
\#
.MAC HEAD END
.    if !\\n[#OLDSTYLE_HD] \{\
.       DEPRECATED HEAD 1
.       OLDSTYLE_HEADINGS HEAD
.    \}
.    HEADING 1 \\$@
.END
\#
.MAC SUBHEAD END
.    if !\\n[#OLDSTYLE_SH] \{\
.       DEPRECATED SUBHEAD 2
.       OLDSTYLE_HEADINGS SUBHEAD
.    \}
.     HEADING 2 \\$@
.END
\#
.MAC SUBSUBHEAD END
.    if !\\n[#OLDSTYLE_SSH] \{\
.       DEPRECATED SUBSUBHEAD 3
.       OLDSTYLE_HEADINGS SUBSUBHEAD
.    \}
.    HEADING 3 \\$@
.END
\#
.MAC PARAHEAD END
.    tm1 "[mom]: \\$0 is no longer a valid macro.
.    tm1 "       Use 'HEADING <level> PARAHEAD <text>' instead.
.    tm1 "       You will probably want to invoke HEADING_STYLE to set
.    tm1 "       the type parameters for the parahead.  See docs.
.    ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.END
\#
\# Wrapper macro for oldstyle NUMBER_HEADS, NUMBER_SUBHEADS...
\#
.MAC HEADING_NUMBERS END
.    if '\\$0'NUMBER_PARAHEADS' \{\
.       tm1 "[mom]: \\$0 is no longer a valid macro.
.       tm1 "       Use 'HEADING_STYLE <level> NUMBER' instead.  See docs.
.       ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.       return
.    \}
.    if '\\$0'NUMBER_HEADS'       .nr level 1
.    if '\\$0'NUMBER_SUBHEADS'    .nr level 2
.    if '\\$0'NUMBER_SUBSUBHEADS' .nr level 3
.    ds mom "[mom]:\"
.    ie '\\$1'' .ds $PARAM NUMBER
.    el \{\
.       ds $PARAM NO_NUMBER
.       ds $SWITCH " \\$1
.    \}
.    HEADING_STYLE \\n[level] \\*[$PARAM]
.    if (\\n[#OLDSTYLE_HD]=1):(\\n[#OLDSTYLE_SH]=1):(\\n[#OLDSTYLE_SSH]=1) \{\
.       tm1 "\\*[mom] OLDSTYLE_HEADINGS detected.
.       ds mom "      \"
.    \}
.    tm1 "\\*[mom] Setting HEADING_STYLE \\n[level] to '\\*[$PARAM]' at '\\$0\\*[$SWITCH]', line \\n[.c].
.    rm $PARAM
.    rm $SWITCH
.END
.
.ALIAS NUMBER_HEADS       HEADING_NUMBERS
.ALIAS NUMBER_SUBHEADS    HEADING_NUMBERS
.ALIAS NUMBER_SUBSUBHEADS HEADING_NUMBERS
.ALIAS NUMBER_PARAHEADS   HEADING_NUMBERS
\#
\# PREFIX CHAPTER NUMBERS TO HEADINGS/TOC ENTRIES
\# ----------------------------------------------
\# *Arguments:
\#   <none> | <chapter number> | <anything>
\# *Function:
\#   Toggles register #PREFIX_CH_NUM. Sets register #CH_NUM from
\#   string $CHAPTER if $CHAPTER is a digit; if <chapter number> arg
\#   given, sets #CH_NUM to arg.
\# *Notes:
\#   Default is OFF.
\#
.MAC PREFIX_CHAPTER_NUMBER END
.    ie '\\$1'' .nr #PREFIX_CH_NUM 1
.    el .rr #PREFIX_CH_NUM
.END
\#
\# ====================================================================
\#
\# +++LINE BREAKS+++
\#
\# LINEBREAK CHARACTER
\# -------------------
\# *Arguments:
\#   [character] [iterations] [vertical adjustment]
\# *Function:
\#   Allows user to specify a line break character and the number
\#   of times to repeat it horizontally.
\# *Notes:
\#   Without an argument, LINEBREAK_CHAR will deposit a blank line.
\#
\#   Vertical adjustment requires a unit of measure (most likely
\#   "p"), and has to be preceded by +|-
\#
.MAC LINEBREAK_CHAR END
.    nr #REPEAT 1
.    ds $LINEBREAK_CHAR \\$1
.    if !'\\$2'' .nr #LB_CHAR_ITERATIONS \\$2
.    if !'\\$3'' .ds $LINEBREAK_CHAR_V_ADJ \\$3
.    if '\\*[$LINEBREAK_CHAR_V_ADJ]'' .ds $LINEBREAK_CHAR_V_ADJ +0
.    if \\n[#LB_CHAR_ITERATIONS] \{\
.       while (\\n[#LB_CHAR_ITERATIONS]>\\n[#REPEAT]) \{\
.          as $LINEBREAK_CHAR "\\ \\$1
.          nr #REPEAT \\n[#REPEAT]+1
.       \}
.    \}
.    rr #REPEAT
.    rr #LB_CHAR_ITERATIONS
.END
\#
\# LINE BREAK
\# ----------
\# *Arguments:
\#   <none>
\# *Function:
\#   Deposits line break character.
\# *Notes:
\#   If $LINEBREAK_CHAR is blank, simply advances 2 line spaces.
\#
.MAC LINEBREAK END
.    if r #Q_AT_TOP .rr #Q_AT_TOP
.    ie  '\\*[$LINEBREAK_CHAR]'' .sp 2
.    el \{\
.       ie \\n[#END_QUOTE] .
.       el .sp
.       ev LINEBREAK
.       evc 0
.       CENTER
.       PRINT \
\m[\\*[$LINEBREAK_COLOR]]\v'\\*[$LINEBREAK_CHAR_V_ADJ]'\
\\*[$LINEBREAK_CHAR]\m[]
.       sp
.       ev
.       QUAD \\*[$DOC_QUAD]
.    \}
.    nr #LINEBREAK 1
.    if r #QUOTE .rr #QUOTE
.    if r #END_QUOTE .rr #END_QUOTE
.    nr #PP 0
.    nr #LB_4_HD       1
.    nr #LB_4_PARAHEAD 1
.END
\#
\# ====================================================================
\#
\# +++PARAGRAPHS+++
\#
\# PARAGRAPH FONT
\# --------------
\# *Argument:
\#   <font of running text>
\# *Function:
\#   Creates or modifies string $PP_FT.
\# *Notes:
\#   Affects all paragraphs.
\#
.MAC PP_FONT END
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie \\n[#ITALIC_MEANS_ITALIC] .nop
.       el .return
.    \}
.    if \\n[#COLLATE]=1 \
.       if !'\\*[$SAVED_PP_FT]'' .rm $SAVED_PP_FT
.    ds $PP_FT \\$1
.    FT \\*[$PP_FT]
.END
\#
\# PARAGRAPH INDENT
\# ----------------
\# *Argument:
\#   <amount to indent paragraphs in running text (ipPcm)>
\# *Function:
\#   Allows user to change the default para indent.  The change will
\#   affect the indent of QUOTEs and BLOCKQUOTEs as well.
\# *Notes:
\#   Default for printstyle TYPEWRITE is 1/2-inch.  Default for
\#   printstyle TYPESET is 2 ems.  The defaults are set in
\#   PRINTSTYLE, not DEFAULTS.
\#
.MAC PARA_INDENT END
.    ie \B'\\$1' \{\
.       nr #PP_INDENT (\\$1)
.       nr #SAVED_PP_INDENT \\n[#PP_INDENT]
.    \}
.    el \{\
.       ie '\\$1'' \{\
.          nr #PP_INDENT \\n[#SAVED_PP_INDENT]
.          rr #SAVED_PP_INDENT
.       \}
.       el \{\
.          nr #SAVED_PP_INDENT \\n[#PP_INDENT]
.          rr #PP_INDENT
.       \}
.    \}
.END
\#
\# INDENT FIRST PARAGRAPHS
\# -----------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   By default, the first para of a document, as well as the first
\#   paras of blockquotes and block-style epigraphs are not indented.
\#   When invoked, this macro will indent all paras.
\# *Notes:
\#   Default is OFF.
\#
.MAC INDENT_FIRST_PARAS END
.    ie '\\$1'' .nr #INDENT_FIRST_PARAS 1
.    el .rr #INDENT_FIRST_PARAS
.END
\#
\# INTER-PARAGRAPH SPACING
\# -----------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Adds a line space between paragraphs in body text.  Block quotes
\#   are unaffected.
\# *Notes:
\#   Default is OFF.  PARA_SPACE is not recommended for use with
\#   PRINTSTYLE TYPEWRITE without SINGLESPACE.
\#
.MAC PARA_SPACE END
.    ie '\\$1'' \
.       nr #PP_SPACE 1
.    el \{\
.       ie \B'\\$1' \{\
.          nr #PP_SPACE 1
.          ds $PP_SPACE_AMOUNT \\$1
.       \}
.       el .rr #PP_SPACE
.    \}
.END
\#
\# PARAGRAPH
\# ---------
\# *Arguments:
\#   <none>
\# *Function:
\#   Figures out what to do with paragraphs under differing conditions.
\# *Notes:
\#   Note the use of transparent line break (\!.br) to get
\#   PP to work within blockquotes and epigraphs.
\#
\#   PP_STYLE 1 = regular paras; 2 = blockquotes, epigraphs
\#
.MAC PP END
.    if \\n[#COVERTEXT_PP] \{\
.       ie \\n[#INDENT_ACTIVE] .ti \\n[#INDENT]u+\\n[#PP_INDENT]u
.       el .ti \\n[#PP_INDENT]u
.       return
.    \}
.    if \\n[#DOC_TYPE]=4 \{\
.       if !'\\n[.z]'' .di
.       nr #TOTAL_FIELDS \\n[#FIELD]
.       nr #FIELD        0 1
.       nr #NUM_FIELDS   0 1
.       if \\n[#TOTAL_FIELDS]>0 \{\
.          while \\n+[#NUM_FIELDS]<=\\n[#TOTAL_FIELDS] \{\
.             nf
.             LETTERHEAD\\n+[#FIELD]
.             QUAD \\*[$DOC_QUAD]
.             ALD \\n[#DOC_LEAD]u
.             if \\n[#DATE_FIRST]=1 .ALD \\n[#DOC_LEAD]u
.             rr #DATE_FIRST
.             rm LETTERHEAD\\n[#FIELD]
.          \}
.          rr #FIELD
.          rr #NUM_FIELDS
.          rr #TOTAL_FIELDS
.       \}
.    \}
.    rr #PP_ACTIVE
.    if r #Q_AT_TOP .rr #Q_AT_TOP
.    if \\n[#PP_STYLE]=1 \{\
.       if \\n[#ENDNOTE] \{\
.          nr #RESET_PARA_SPACE \\n[#PP_SPACE]
.          ie \\n[#EN_PP_SPACE] .PARA_SPACE
.          el .PARA_SPACE OFF
.       \}
.       if !\\n[#ENDNOTE] .po \\n[#L_MARGIN]u
.       if \\n[#COLUMNS] \{\
.          if !\\n[#ENDNOTE] \{\
.             po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.             nr #L_MARGIN \\n[.o]
.          \}
.       \}
.       if \\n[#TAB_ACTIVE] .TAB \\n[#CURRENT_TAB]
.       ie \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          ie \\n[#ENDNOTE] .vs \\n[#EN_LEAD]u
.          el .vs \\n[#DOC_LEAD]u
.          QUAD \\*[$DOC_QUAD]
.          if \\n[#SLANT_ON] \
.             if \\n[#UNDERLINE_SLANT] .UNDERLINE
.          if '\\*[$PP_FT]'I' \
.             if \\n[#ITALIC_MEANS_ITALIC] .FT I
.       \}
.       el \{\
.          ie \\n[#ENDNOTE] \{\
.             FAMILY  \\*[$EN_FAM]
.             FT      \\*[$EN_FT]
.             ps \\n[#EN_PS]u
.             vs \\n[#EN_LEAD]u
.             QUAD    \\*[$EN_QUAD]
.          \}
.          el \{\
.             FAMILY  \\*[$DOC_FAM]
.             if !'\\*[$SAVED_PP_FT]'' \{\
.                ds $PP_FT \\*[$SAVED_PP_FT]
.                rm $SAVED_PP_FT
.             \}
.             FT \\*[$PP_FT]
.             ps \\n[#DOC_PT_SIZE]u
.             vs      \\n[#DOC_LEAD]u
.             QUAD    \\*[$DOC_QUAD]
.          \}
.       \}
.       ie \\n[#PP]=0 \{\
.          if \\n[#INDENT_FIRST_PARAS] \{\
.             ie \\n[#INDENT_ACTIVE] .ti \\n[#INDENT]u+\\n[#PP_INDENT]u
.             el .ti \\n[#PP_INDENT]u
.             if '\\n[.z]'END_NOTES' \
.                ti \\n[#EN_PP_INDENT]u+\\n[#EN_TEXT_INDENT]u
.          \}
.          if r #END_QUOTE \{\
.             if \\n[#END_QUOTE] \{\
.                if !\\n[#LINEBREAK] \{\
.                   ie \\n[#INDENT_ACTIVE] .ti \\n[#INDENT]u+\\n[#PP_INDENT]u
.                   el .ti \\n[#PP_INDENT]u
.                   if '\\n[.z]'END_NOTES' \
.                      ti \\n[#EN_PP_INDENT]u+\\n[#EN_TEXT_INDENT]u
.                \}
.             \}
.          \}
.       \}
.       el \{\
.          if \\n[#PP_SPACE] \{\
.             ie \\n[#END_QUOTE] \{\
.                ie !'\\*[$PP_SPACE_AMOUNT]'' .sp \\*[$PP_SPACE_AMOUNT]
.                el .sp
.                rr #END_QUOTE
.                nr #NO_SPACE 1
.                nr #BASELINE_MARK \\n[nl]
.             \}
.             el \{\
.                if \\n[#NO_SPACE]=1 .rr #NO_SPACE
.                if \\n[post-float] \{\
.                   if (\\n[.t]-1)<\\*[$PP_SPACE_AMOUNT] \{\
.                      ie \\n[#COLS] .COL_NEXT
.                      el .NEWPAGE
.                   \}
.                   rr post-float
.                \}
.                if !\\n[nl]=\\n[#BASELINE_MARK] \{\
.                   ie !'\\*[$PP_SPACE_AMOUNT]'' .sp \\*[$PP_SPACE_AMOUNT]
.                   el .sp
.                   rr #BASELINE_MARK
.                \}
.             \}
.          \}
.          ie \\n[#INDENT_ACTIVE] .ti \\n[#INDENT]u+\\n[#PP_INDENT]u
.          el .ti \\n[#PP_INDENT]u
.          if '\\n[.z]'END_NOTES' \
.             ti \\n[#EN_PP_INDENT]u+\\n[#EN_TEXT_INDENT]u
.       \}
.       if r #START     .rr #START
.       if r #QUOTE     .rr #QUOTE
.       if r #END_QUOTE .rr #END_QUOTE
.       if r #HEAD      .rr #HEAD
.       if r #SUBHEAD   .rr #SUBHEAD
.       if r #EPIGRAPH  .rr #EPIGRAPH
.       if r #Q_FITS    .rr #Q_FITS
.       if r #LINEBREAK .rr #LINEBREAK
.       if \\n[#ENDNOTE] \{\
.          ie \\n[#RESET_PARA_SPACE] .PARA_SPACE
.          el .PARA_SPACE OFF
.       \}
.       if \\n[#CONDENSE] \{\
\E*[COND]\c
.       \}
.       if \\n[#EXTEND]=1 \{\
\E*[EXT]\c
.       \}
.       nr #PP +1
.    \}
.    if \\n[#PP_STYLE]=2 \{\
\!.     br
.       ie \\n[#Q_PP]=0 \{\
.          if \\n[#INDENT_FIRST_PARAS] \
.             ti \\n[#PP_INDENT]u/2u
.          if \\n[#ENDNOTE] \{\
.             ie \\n[#INDENT_FIRSTS] .ti \\n[#PP_INDENT]u/2u
.             el .ti 0
.          \}
.       \}
.       el \{\
.          ti \\n[#PP_INDENT]u/2u
.          if \\n[#PP_SPACE]=1 \{\
.             ie !'\\*[$PP_SPACE_AMOUNT]'' .ALD \\*[$PP_SPACE_AMOUNT]
.             el .sp
.          \}
.       \}
.       if \\n[#CONDENSE] \{\
\E*[COND]\c
.       \}
.       if \\n[#EXTEND]=1 \{\
\E*[EXT]\c
.       \}
.    nr #Q_PP +1
.    \}
.\" This takes care of multi-paragraph dialogue, where each para
.\" is introduced by an open quote whereas the previous para has
.\" no close quote.
.    if \\n[#OPEN_CLOSE]=1 .nr #OPEN_CLOSE 0
.    nr #PP_ACTIVE 1
.    UNDERLINE OFF
.    if r #QUOTE_4_HD .rr #QUOTE_4_HD
.    if r #LB_4_HD .rr #LB_4_HD
.END
\# ====================================================================
\#
\# +++QUOTES+++
\#
\# ---Line for line quotes, i.e. poetry or code snippets---
\#
\# UNDERLINE QUOTES
\# ----------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or modifies register #UNDERLINE_QUOTES (toggle).
\#   If on, line for line quotes are underlined when printstyle
\#   is TYPEWRITE.
\# *Notes:
\#   Default is ON for printstyle TYPEWRITE.
\#
.MAC UNDERLINE_QUOTES END
.    ie '\\$1'' .nr #UNDERLINE_QUOTES 1
.    el .rr #UNDERLINE_QUOTES
.END
\#
\# QUOTE INDENT
\# ------------
\# *Argument:
\#   <integer> | <integer with unit of measure appended>
\# *Function:
\#   Creates or modifies register #Q_OFFSET_VALUE or string
\#   $Q_OFFSET_VALUE.
\# *Notes:
\#   If just an integer given, value by which to multiply PARA_INDENT
\#   to get quote indent.  If integer with a unit of measure appended,
\#   absolute value of quote indent.
\#
\#  Default is 3 for typeset; 2 for typewrite.
\#
.MAC QUOTE_INDENT END
.    if '\\$0'BLOCKQUOTE_INDENT' .ds BQ BQ
.    if '\\$0'QUOTE_INDENT'      .ds BQ Q
.    rr #\\*[BQ]_OFFSET_VALUE
.    rm $\\*[BQ]_OFFSET_VALUE
.    ds $EVAL_QI_ARG \\$1
.    substring $EVAL_QI_ARG -1
.    ie \B'\\*[$EVAL_QI_ARG]' .nr #\\*[BQ]_OFFSET_VALUE \\$1
.    el .ds $\\*[BQ]_OFFSET_VALUE \\$1
.    rm BQ
.END
.
.ALIAS BLOCKQUOTE_INDENT QUOTE_INDENT
\#
\# QUOTE_AUTOLEAD
\# --------------
\# *Arguments:
\#   <autolead value>
\# *Function:
\#   Sets autolead for quotes and/or blockquotes.
\#
.MAC QUOTE_AUTOLEAD END
.    rr #\\$0_DEFAULT
.    if '\\$0'QUOTE_AUTOLEAD'              .nr #Q_AUTOLEAD (p;\\$1)
.    if '\\$0'BLOCKQUOTE_AUTOLEAD'         .nr #BQ_AUTOLEAD (p;\\$1)
.    if '\\$0'ENDNOTE_QUOTE_AUTOLEAD'      .nr #EN_Q_AUTOLEAD (p;\\$1)
.    if '\\$0'ENDNOTE_BLOCKQUOTE_AUTOLEAD' .nr #EN_BQ_AUTOLEAD (p;\\$1)
.END
.
.ALIAS BLOCKQUOTE_AUTOLEAD         QUOTE_AUTOLEAD
.ALIAS ENDNOTE_QUOTE_AUTOLEAD      QUOTE_AUTOLEAD
.ALIAS ENDNOTE_BLOCKQUOTE_AUTOLEAD QUOTE_AUTOLEAD
\#
\# ALWAYS FULLSPACE QUOTES
\# -----------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles register #FULLSPACE_QUOTES.
\# *Notes:
\#   If user doesn't like the default 1/2 line space above and below
\#   quotes, s/he can turn it off here.  Has no effect in TYPEWRITE.
\#
.MAC ALWAYS_FULLSPACE_QUOTES END
.    if '\\$1'' .nr #FULLSPACE_QUOTES 1
.    el .rr #FULLSPACE_QUOTES
.END
\#
\# QUOTE
\# -----
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Indents quoted text on a line for line basis, or turns QUOTE off.
\# *Notes:
\#   Owing to the need to bottom align TYPESET pages, quoted text gets
\#   diverted so its depth can be measured (in DO_QUOTE) for determining
\#   how much space to put before and after.
\#
.MAC QUOTE END
.    ie \\n[@TOP] \
.       br
.    el 'br
.    if \\n[#PP]>0 .rr #START
.    if \\n[#LINENUMBERS]=1 \{\
.       nr #LINENUMBERS 2
.       nr #NEXT_LN \\n[ln]
.       nm
.    \}
.    if '\\$1'ADJUST' \{\
.       ds $Q_SPACE_ADJUST \\$2
.       shift 2
.    \}
.    ie '\\$1'' \{\
.       ev QUOTE
.       evc 0
.       if \\n[.i] .in 0
.       if \\n[#LINENUMBERS]=2 \
.          if \\n[#SILENT_QUOTE_LN]=1 .nm \\n[#NEXT_LN] 1000 -4
.       nr #IN_DIVER 1
.       nr #QUOTE 1
.       di P_QUOTE
.       if '\\*[$Q_QUAD]'LEFT' \{\
.          ie !'\\*[$Q_OFFSET_VALUE]'' .ll \\n[#L_LENGTH]u-\\*[$Q_OFFSET_VALUE]
.          el .ll \\n[#L_LENGTH]u-(\\n[#PP_INDENT]u*\\n[#Q_OFFSET_VALUE]u)
.       \}
.       ta \\n[.l]u
.       if \\n[#COLUMNS] \{\
.          ie \\n[#Q_OFFSET_VALUE] \
.             ll \\n[#COL_L_LENGTH]u-(\\n[#PP_INDENT]u*\\n[#Q_OFFSET_VALUE]u)
.          el .ll \\n[#COL_L_LENGTH]u-\\*[$Q_OFFSET_VALUE]
.          ta \\n[.l]u
.       \}
.       if \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          vs \\n[#DOC_LEAD]u
.          LEFT
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          FAMILY  \\*[$QUOTE_FAM]
.          FT      \\*[$QUOTE_FT]
.          ps \\n[#DOC_PT_SIZE]u\\*[$QUOTE_SIZE_CHANGE]
.          ie !r #Q_AUTOLEAD .vs \\n[#DOC_LEAD]u
.          el \{\
.             vs \\n[.ps]u+\\n[#Q_AUTOLEAD]u
.             nr #Q_LEAD \\n[.v]
.          \}
.          if \\n[#ENDNOTE] \{\
.             ps \\n[#EN_PS]u\\*[$QUOTE_SIZE_CHANGE]
.             ie !r #EN_Q_AUTOLEAD .vs \\n[#EN_Q_LEAD]u
.             el \{\
.                vs \\n[.ps]u+\\n[#EN_Q_AUTOLEAD]u
.                nr #EN_Q_LEAD \\n[.v]
.             \}
.          \}
.          nr #Q_LEAD_REAL \\n[.v]
.          if \\n[#QUOTE_COLOR]=1 \{\
.             nf
.             COLOR \\*[$QUOTE_COLOR]
.          \}
.          \\*[$Q_QUAD]
.       \}
.       if \\n[#LINENUMBERS]=2 \{\
.          ie \\n[#QUOTE_LN]=1 \{\
.             if '\\n[#Q_LN_GUTTER]'' .nr #Q_LN_GUTTER \\n[#LN_GUTTER]
.             LN_PARAMS
.             nm \\n[ln] "" \\n[#Q_LN_GUTTER] -3-\\n[#Q_LN_GUTTER]
.             RESTORE_PARAMS
.          \}
.          el \
.             if !\\n[#SILENT_QUOTE_LN] .NUMBER_LINES OFF
.       \}
.       nr #Q_TOP \\n[nl]
.       if \\n[#PRINT_STYLE]=1 \
.          if \\n[#UNDERLINE_QUOTES] .FT I
.    \}
.    el .DO_QUOTE
.END
\#
\# CODE
\# ----
\# *Arguments:
\#   <none> [ BR | BREAK | SPREAD ]
\#    or
\#   <anything> [ BR | BREAK | SPREAD ]
\# *Function:
\#   Takes care of administrivia associated with setting code snippets.
\#
.MAC CODE END
\c
.    if '\\$1'BR' \{\
.       ie '\\n[.z]'FLOAT*DIV' 'br
.       el .br
.       shift
.    \}
.    if '\\$1'BREAK' \{\
.       ie '\\n[.z]'FLOAT*DIV' 'br
.       el .br
.       shift
.    \}
.    if '\\$1'SPREAD' \{\
.       ie '\\n[.z]'FLOAT*DIV' 'brp
.       el .brp
.       shift
.    \}
.    ie '\\$1'' \{\
.       ds $RESTORE_FAM \\n[.fam]
.       ds $RESTORE_FT  \\n[.sty]
.       ie \\n[#PRINT_STYLE]=1 \{\
.          CODE_FAMILY C
.          ie \\n[#CODE_FT]=1 .ft \\*[$CODE_FT]
.          el \{\
.             CODE_FONT R
.             ft R
.             char ' \[aq]
.          \}
.          if \\n[#UNDERLINE_QUOTES]=1 \{\
.             nr #RESTORE_UNDERLINE 1
.             UNDERLINE_QUOTES OFF
.             FT \\*[$CODE_FT]
.             char ' \[aq]
.          \}
.       \}
.       el \{\
.          ie \\n[#CODE_FAM]=1 .fam \\*[$CODE_FAM]
.          el \{\
.             CODE_FAMILY C
.             fam \\*[$CODE_FAM]
.          \}
.          ie \\n[#CODE_FT]=1 .ft \\*[$CODE_FT]
.          el \{\
.             CODE_FONT R
.             ft \\*[$CODE_FT]
.          \}
.          if \\n[#CODE_COLOR]=1 .COLOR \\*[$CODE_COLOR]
.          char ' \[aq]
.          if !\\n[#CODE_SIZE_ADJ]=0 \{\
.             nr #RESTORE_SIZE \\n[.s]
.             ps \\n[#PT_SIZE]u*\\n[#CODE_SIZE_ADJ]u/100u
.          \}
.          if \\n[#SQ_ON] \{\
.             nr #SQ_WAS_ON 1
.             SMARTQUOTES OFF
.          \}
.       \}
.    \}
.    el \{\
.       fam \\*[#RESTORE_FAM]
.       ft  \\*[#RESTORE_FT]
.       if !\\n[#CODE_SIZE_ADJ]=0 .ps \\n[#RESTORE_SIZE]
.       rm $RESTORE_FAM
.       rm $RESTORE_FT
.       rm $RESTORE_SIZE
.       if \\n[#PRINT_STYLE]=2 .char ' \[cq]
.       if !'\\n[.z]'' \
.          if \\n[#LINENUMBERS] .nn
.       if \\n[#CODE_COLOR]=1 .gcolor
.       if \\n[#RESTORE_UNDERLINE]=1 \{\
.          rr #RESTORE_UNDERLINE
.          UNDERLINE_QUOTES
.       \}
.       if \\n[#SQ_WAS_ON]=1 \{\
.          rr #SQ_WAS_ON
.          SMARTQUOTES
.       \}
.       if \\n[#QUOTE] .sp -1
.    \}
.END
\#
\# ---Blockquotes---
\#
\# BLOCKQUOTE
\# ----------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Indents quoted text in fill mode and shortens line length
\#   equivalently, or turns BLOCKQUOTE off.
\# *Notes:
\#   Owing to the need to bottom align TYPESET pages, quoted text gets
\#   diverted so its depth can be measured (in DO_QUOTE) for determining
\#   how much space to put before and after.
\#
\#   .PP after blockquote is optional if there's only one para,
\#   but required if there's more than one.
\#
.MAC BLOCKQUOTE END
.    br
.    if \\n[#PP]>0 .rr #START
.    if \\n[#LINENUMBERS]=1 \{\
.       nr #LINENUMBERS 2
.       nr #NEXT_LN \\n[ln]
.       nm
.    \}
.    if '\\$1'ADJUST' \{\
.       ds $BQ_SPACE_ADJUST \\$2
.       shift 2
.    \}
.    if \\n[in-cutaround] .nr #PP_INDENT \\n[restore-pp-ind]/2
.    ie '\\$1'' \{\
.       ev BLOCKQUOTE
.       evc 0
.       if \\n[.i] .in 0
.       if \\n[#LINENUMBERS]=2 \
.          if \\n[#SILENT_BQUOTE_LN]=1 .nm \\n[#NEXT_LN] 1000 -4
.       nr #IN_DIVER 1
.       nr #QUOTE    2
.       nr #PP_STYLE 2
.       nr #Q_PP     0
.       if \\n[in-cutaround] \{\
.          if '\\*[cutaround-type]'RIGHT' \{\
.             nr reset-ll 1
.             nr #L_LENGTH \\n[#DOC_L_LENGTH]-\\n[cutaround-width]-1v\\*[width-adj]
.          \}
.       \}
.       di B_QUOTE
.       ie !'\\*[$BQ_OFFSET_VALUE]'' .ll \\n[#L_LENGTH]u-(\\*[$BQ_OFFSET_VALUE]*2u)
.       el .ll \\n[#L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#BQ_OFFSET_VALUE]u*2u))
.       if \\n[in-cutaround] .nr #PP_INDENT \\n[.i]+\\n[pp-ind-tmp]
.       if \\n[#ENDNOTE] \{\
.          if \\n[#EN_NUMBERS_ALIGN_RIGHT] \{\
.             ie r#BQ_OFFSET_VALUE \
.                ll \
\\n[#RESET_L_LENGTH]u-\\n[#EN_TEXT_INDENT]u-(\\n[#EN_PP_INDENT]u*(\\n[#BQ_OFFSET_VALUE]u*2u))
.             el \
.                ll \
\\n[#RESET_L_LENGTH]u-\\n[#EN_TEXT_INDENT]u-(\\*[$BQ_OFFSET_VALUE]*2u)
.          \}
.          if \\n[#EN_NUMBERS_ALIGN_LEFT] \{\
.             ie r#BQ_OFFSET_VALUE \
.                ll \\n[#L_LENGTH]u-(\\n[#EN_PP_INDENT]u*(\\n[#BQ_OFFSET_VALUE]u*2u))
.             el \
.                ll \\n[#L_LENGTH]u-(\\*[$BQ_OFFSET_VALUE]u*2u)
.          \}
.       \}
.       ta \\n[.l]u
.       CHECK_INDENT
.       if \\n[#COLUMNS] \{\
.          ie r#BQ_OFFSET_VALUE \
.             ll \
\\n[#COL_L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#BQ_OFFSET_VALUE]u*2u))
.          el \
.             ll \\n[#COL_L_LENGTH]u-(\\*[$BQ_OFFSET_VALUE]*2u)
.          if \\n[#ENDNOTE] \{\
.             if \\n[#EN_NUMBERS_ALIGN_RIGHT] \{\
.                ie r#BQ_OFFSET_VALUE \
.                   ll \
\\n[#RESET_L_LENGTH]u-\\n[#EN_TEXT_INDENT]u-(\\n[#EN_PP_INDENT]u*(\\n[#BQ_OFFSET_VALUE]u*2u))
.                el \
.                   ll \
\\n[#RESET_L_LENGTH]u-\\n[#EN_TEXT_INDENT]u-(\\*[$BQ_OFFSET_VALUE]*2u)
.             \}
.             if \\n[#EN_NUMBERS_ALIGN_LEFT] \{\
.                ie r#BQ_OFFSET_VALUE \
.                   ll \
\\n[#COL_L_LENGTH]u-(\\n[#EN_PP_INDENT]u*(\\n[#BQ_OFFSET_VALUE]u*2u))
.                el \
.                   ll \\n[#COL_L_LENGTH]u-(\\*[$BQ_OFFSET_VALUE]*2u)
.             \}
.          \}
.          ta \\n[.l]u
.       \}
.       if \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          vs \\n[#DOC_LEAD]u
.          QUAD LEFT
.          HY OFF
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          FAMILY  \\*[$BQUOTE_FAM]
.          FT      \\*[$BQUOTE_FT]
.          ps \\n[#DOC_PT_SIZE]u\\*[$BQUOTE_SIZE_CHANGE]
.          ie !r #BQ_AUTOLEAD .vs \\n[#DOC_LEAD]u
.          el \{\
.             vs \\n[.ps]u+\\n[#BQ_AUTOLEAD]u
.             nr #BQ_LEAD \\n[.v]
.          \}
.          if \\n[#ENDNOTE] \{\
.             ps \\n[#EN_PS]u\\*[$BQUOTE_SIZE_CHANGE]
.             ie !r#EN_BQ_AUTOLEAD .vs \\n[#EN_BQ_LEAD]u
.             el \{\
.                vs \\n[.ps]u+\\n[#EN_BQ_AUTOLEAD]u
.                nr #EN_BQ_LEAD \\n[.v]
.             \}
.          \}
.          nr #BQ_LEAD_REAL \\n[.v]
.          if \\n[#BQUOTE_COLOR]=1 \{\
.             nf
.             COLOR \\*[$BQUOTE_COLOR]
.          \}
.          QUAD \\*[$BQUOTE_QUAD]
.          nr #DIVERSIONS_HY_MARGIN (p;\\n[.ps]u*2.75)/1000
.          HY_SET 1 \\n[#DIVERSIONS_HY_MARGIN]u (\\n[#PT_SIZE]u/1000u/8u)p
.          hy 14
.       \}
.       if \\n[#LINENUMBERS]=2 \{\
.          ie \\n[#BQUOTE_LN]=1 \{\
.             if '\\n[#BQ_LN_GUTTER]'' .nr #BQ_LN_GUTTER \\n[#LN_GUTTER]
.             LN_PARAMS
.             nm \\n[ln] "" \\n[#BQ_LN_GUTTER] -3-\\n[#BQ_LN_GUTTER]
.             RESTORE_PARAMS
.          \}
.          el \
.             if !\\n[#SILENT_BQUOTE_LN] .NUMBER_LINES OFF
.       \}
.       nr #Q_TOP \\n[nl]
.       if \\n[#INDENT_FIRST_PARAS] \{\
.          ie !\\n[#ENDNOTE] \{\
.             if \\n[#PRINT_STYLE]=1 .ti \\n[#PP_INDENT]u/2u
.             if \\n[#PRINT_STYLE]=2 .ti \\n[#PP_INDENT]u/2u
.          \}
.          el \{\
.             if \\n[#INDENT_FIRSTS]=1 \{\
.                if \\n[#PRINT_STYLE]=1 .ti \\n[#EN_PP_INDENT]u/2u
.                if \\n[#PRINT_STYLE]=2 .ti \\n[#EN_PP_INDENT]u/2u
.             \}
.          \}
.       \}
.    \}
.    el .DO_BLOCKQUOTE
.END
\#
\# DO QUOTE
\# --------
\# *Arguments:
\#   <none>
\# *Function:
\#   Ends the diversion P_QUOTE or B_QUOTE.  Spaces them according to
\#   PRINTSTYLE, whether there's inter-paragraph spacing, and page
\#   position.  TYPEWRITE treats spacing the same way in all circumstance
\#   (viz. an extra line space).  TYPESET puts in only half
\#   line spaces if the entire quote plus 1 line of body under the quote
\#   fits on the page; otherwise it puts in a full extra blank
\#   line.  (This is to ensure the page remains bottom aligned).
\#
.MAC DO_QUOTE END
.    br
.    if \\n[#DIVER_LN_OFF] \{\
\!.     NUMBER_LINES OFF
.       rr #DIVER_LN_OFF
.    \}
.    nr #Q_DEPTH \\n[.d]
.    di
.    if '\\$0'DO_BLOCKQUOTE' .ds BQ BQ
.    if '\\$0'DO_QUOTE'      .ds BQ Q
.    if \\n[in-cutaround] \{\
.       if \\n[dn]>\\n[.t] \{\
.          tm1 "[mom]: Blockquote depth exceeds cutaround depth."
.          ab   [mom]: Aborting at line \\n[.c].
.       \}
.    \}
.    rr #IN_DIVER
.    if \\n[#RESET_FN_COUNTERS]=2 \{\
.       if !\\n[#FN_COUNT]=1 \{\
.          if ((\\n[#PAGE_LENGTH]+\\n[#VARIABLE_FOOTER_POS])+\\n[#DIVER_DEPTH])>(\\n[#PAGE_LENGTH]+\\n[#VARIABLE_FOOTER_POS]) \{\
.             DIVER_FN_2_POST
.             rr #RESET_FN_COUNTERS
.          \}
.       \}
.    \}
.    nr #SAVED_FN_NUMBER \\n[#FN_NUMBER]
.    nr #DONE_ONCE 0 1
.    REMOVE_INDENT
.    ev
.    nr #Q_LEAD_DIFF \\n[#LEAD]-\\n[#\\*[BQ]_LEAD_REAL]
.    if !'\\n[.z]'FLOAT*DIV' \{\
.       br
.       nr #CALCULATE_ONLY 1
.       nr #CURRENT_V_POS \\n[nl]+\\n[#Q_DEPTH]
.       SHIM
.       rr #CALCULATE_ONLY
.       nr #Q_SPACE_EQ (\\n[#SHIM]/2)
.       nr #TRAP \\n[.t]-1
.    \}
.    if \\n[#ENDNOTE] \{\
.       nr #RESET_QUOTE_SPACING \\n[#FULLSPACE_QUOTES]
.       ALWAYS_FULLSPACE_QUOTES
.    \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#START]=1 .
.       if \\n[#START]=0 \
.          if !\\n[#LINEBREAK] .ALD \\n[#DOC_LEAD]u
.       if \\n[#HEAD] \
.          if \\n[#HEAD]=1 .RLD \\n[#DOC_LEAD]u
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#PP_SPACE] \{\
.          ie \\n[#HEAD] .
.          el \{\
.             ie \\n[#START] .
.             el \{\
.                ie \\n[#FULLSPACE_QUOTES] .ALD \\n[#DOC_LEAD]u
.                el .ALD \\n[#DOC_LEAD]u/2u
.             \}
.          \}
.       \}
.       el \{\
.          if !\\n[nl]=\\n[#PAGE_TOP] \{\
.             ie \\n[#Q_DEPTH]<(\\n[#TRAP_DISTANCE]-1) \{\
.                ie ((\\n[#TRAP_DISTANCE]-1)-\\n[#Q_DEPTH])<\\n[#DOC_LEAD] \{\
.                   ie !\\n[in-cutaround] .Q_NOFIT
.                   el .Q_FITS
.                \}
.                el \{\
.                   ie (\\n[#TRAP_DISTANCE]-\\n[#DOC_LEAD])<\\n[#DOC_LEAD] .Q_NOFIT
.                   el \{\
.                      ie (\\n[#Q_DEPTH]+\\n[.v])=(\\n[#TRAP_DISTANCE]-1) .Q_NOFIT
.                      el .Q_FITS
.                   \}
.                \}
.             \}
.             el .Q_NOFIT
.          \}
.       \}
.       if \\n[#LINEBREAK] \{\
.          vpt 0
.          ie !\\n[@TOP] .sp -\\n[#DOC_LEAD]u
.          el \{\
.             nop
.             sp |\\n[#T_MARGIN]u-\\n[#BQ_LEAD]u
.          \}
.         vpt
.       \}
.    \}
.    ie !'\\*[$\\*[BQ]_OFFSET_VALUE]'' \
.       nr #\\*[BQ]_OFFSET \\n[#L_MARGIN]+(\\*[$\\*[BQ]_OFFSET_VALUE])
.    el \
.       nr #\\*[BQ]_OFFSET \
\\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#\\*[BQ]_OFFSET_VALUE])
.    if \\n[#COLUMNS] \{\
.       ie r#\\*[BQ]_OFFSET_VALUE \
.          nr #\\*[BQ]_OFFSET \
\\n[#COL_\\n[#COL_NUM]_L_MARGIN]+(\\n[#PP_INDENT]*\\n[#\\*[BQ]_OFFSET_VALUE])
.       el .nr #\\*[BQ]_OFFSET \
\\n[#COL_\\n[#COL_NUM]_L_MARGIN]+\\*[$\\*[BQ]_OFFSET_VALUE]
.    \}
.    if !\\n[#ENDNOTE] \{\
.       ie '\\*[BQ]'Q' \{\
.          if '\\*[$Q_QUAD]'LEFT' \{\
.             po \\n[#Q_OFFSET]u
.             if '\\n[.z]'FLOAT*DIV' \!.po \\n[#Q_OFFSET]u
.          \}
.       \}
.       el \{\
.          po \\n[#\\*[BQ]_OFFSET]u
.          if '\\n[.z]'FLOAT*DIV' \!.po \\n[#\\*[BQ]_OFFSET]u
.       \}
.    \}
.    if \\n[#ENDNOTE] \{\
.       ie \\n[#\\*[BQ]_OFFSET_VALUE] \
.          in +\\n[#EN_PP_INDENT]u*\\n[#\\*[BQ]_OFFSET_VALUE]u
.       el .in +\\*[$\\*[BQ]_OFFSET_VALUE]
.    \}
.    ie \\n[#START]=1 \{\
.       ie !\\n[#Q_LEAD_DIFF]<0 \
.          if !\\n[#NO_SHIM] .sp \\n[#Q_SPACE_EQ]u
.       el .RLD 0-\\n[#Q_LEAD_DIFF]u
.    \}
.    el \{\
.       if \\n[#PRINT_STYLE]=2 \
.          ie !\\n[#NO_SHIM] \
.             sp \\n[#Q_SPACE_EQ]u+(\\n[#Q_LEAD_DIFF]u/2u)
.          el .if !\\n[#NO_FLEX] .FLEX
.    \}
.    if \\n[#QUOTE]=1 \{\
.       if !'\\*[$Q_SPACE_ADJUST]'' .sp +\\*[$Q_SPACE_ADJUST]
.       nf
.       P_QUOTE
.       if !'\\*[$Q_SPACE_ADJUST]'' \{\
.          sp -\\*[$Q_SPACE_ADJUST]
.          rm $Q_SPACE_ADJUST
.       \}
.    \}
.    if \\n[#QUOTE]=2 \{\
.       if !'\\*[$BQ_SPACE_ADJUST]'' .sp +\\*[$BQ_SPACE_ADJUST]
.       nf
.       B_QUOTE
.       if !'\\*[$BQ_SPACE_ADJUST]'' \{\
.          sp -\\*[$BQ_SPACE_ADJUST]
.          rm $BQ_SPACE_ADJUST
.       \}
.    \}
.    if !\\n[#START] .rr #QUOTE
.    if \\n[in-cutaround] .nr #PP_INDENT \\n[pp-ind-tmp]
\#.    if !\\n[ev-popped] .ev \" Needed once cutarounds are implemented
.    rr delay-ev-pop
.    if \\n[reset-ll] \{\
.       if '\\*[cutaround-type]'RIGHT' \{\
.          ll \\n[#DOC_L_LENGTH]u
.          rr reset-ll
.       \}
.    \}
.    if !'\\n[.z]'FLOAT*DIV' \{\
.       if \\n[#PRINT_STYLE]=1 \
.          if !\\n[.v]=\\n[#DOC_LEAD] \{\
.             ie !\\n[#NO_SHIM] .SHIM
.             el \
.                if !\\n[#NO_FLEX] .FLEX
.          \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          ie \\n[#START] \{\
.             ie \\n[#PP_SPACE] .
.             el \{\
.                sp \\n[#DOC_LEAD]u
.                ie !\\n[#NO_SHIM] .SHIM
.                el \
.                   if !\\n[#NO_FLEX] .FLEX
.             \}
.          \}
.          el \{\
.             ie \\n[#HEAD]=1 \{\
.                sp \\n[#DOC_LEAD]u
.                ie !\\n[#NO_SHIM] .SHIM
.                el \
.                   if !\\n[#NO_FLEX] .FLEX
.             \}
.             el \{\
.                ie \\n[#FULLSPACE_QUOTES] \{\
.                   ie \\n[#ENDNOTE] .ALD \\n[#EN_LEAD]u
.                   el !'\\n[.z]'FLOAT*DIV' .ALD \\n[#DOC_LEAD]u
.                \}
.                el \
.                   if !'\\n[.z]'FLOAT*DIV' .ALD \\n[#DOC_LEAD]u/2u
.                ie \\n[#Q_FITS] \{\
.                   ie (\\n[#Q_TOP]=\\n[#PAGE_TOP]):(\\n[@TOP]=1) \{\
.                      if \\n[has-label] .sp \\n[#DOC_LEAD]u/2u
.                      if !'\\n[.z]'FLOAT*DIV' \{\
.                         nr #Q_AT_TOP 1
.                         nr #DELAY_SHIM 1
.                      \}
.                   \}
.                   el \{\
.                      ie !\\n[#NO_SHIM] .SHIM
.                      el \
.                         if !\\n[#NO_FLEX] .FLEX
.                   \}
.                \}
.                el \{\
.                   ie !\\n[#NO_SHIM] .SHIM
.                   el \
.                      if !\\n[#NO_FLEX] .FLEX
.\" Make sure that Q_LEAD_DIFF is not added to the first line of
.\" normal text at the top of any page following output of a quote
.\" whose last line falls on B_MARGIN of the previous page.
.                   if \\n[#Q_LEAD_DIFF] \{\
.                      if \\n[nl]=(\\n[#T_MARGIN]-\\n[#DOC_LEAD]+\\n[#Q_LEAD_DIFF]) \{\
.                         PRINT \&
.                         br
.                         sp -1v-\\n[#Q_LEAD_DIFF]u
.                         nr #Q_LEAD_DIFF_CHECK 1
.                      \}
.                   \}
.                \}
.             \}
.          \}
.       \}
.    \}
.    if \\n[#RESTORE_NO_SHIM] .nr #NO_SHIM 1
.    rr #Q_SPACE_EQ
.    if \\n[#LINENUMBERS]=2 \{\
.       nr #LINENUMBERS 1
.       if !\\n[#ENDNOTE] \{\
.          ie \\n[#RESTORE_LN_NUM]=1 \{\
.             LN_PARAMS
.             nm \\n[#NEXT_LN]
.             RESTORE_PARAMS
.          \}
.          el \{\
.             LN_PARAMS
.             nm +0
.             RESTORE_PARAMS
.          \}
.       \}
.    \}
.    if \\n[#ENDNOTE] \
.       nr #FULLSPACE_QUOTES \\n[#RESET_QUOTE_SPACING]
.    if r #HEAD .rr #HEAD
.    if r #EPIGRAPH .rr #EPIGRAPH
.    rr #Q_PP
.    rr #LINEBREAK
.    nr #PP_STYLE  1
.    nr #END_QUOTE 1
.    if !\\n[#ENDNOTE] \
.       po \\n[#L_MARGIN]u
.    if \\n[#ENDNOTE]  .in \\n[#EN_TEXT_INDENT]u
.    if \\n[#COLUMNS] \{\
.       if !\\n[#ENDNOTE] \{\
.          po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.          nr #L_MARGIN \\n[.o]
.       \}
.       if \\n[#ENDNOTE] .in \\n[#EN_TEXT_INDENT]u
.    \}
.    ie !\\n[#ENDNOTE] .QUAD \\*[$DOC_QUAD]
.    el .QUAD \\*[EN_QUAD]
.    if r #DELAY_SHIM \{\
.       ie !\\n[#NO_SHIM] .SHIM
.       el \
.          if !\\n[#NO_FLEX] .FLEX
.       rr #DELAY_SHIM
.    \}
.    if \\n[#PRINT_STYLE]=1 \
.       if \\n[#UNDERLINE_QUOTES] .FT R
.    nr #QUOTE_4_HD 1
.    rr #\\*[BQ]_LEAD_REAL
.    rm BQ
.    if \\n[#DOC_TYPE]=5 .NO_SHIM
.    if '\\n[.z]'FLOAT*DIV' \!.po \\n[#L_MARGIN]u
.END
.
.ALIAS DO_BLOCKQUOTE DO_QUOTE
\#
\# Utility macros for DO_QUOTE
\# ---------------------------
\#
.MAC Q_FITS END
.    nr #Q_FITS 1
.    ie \\n[#HEAD]=1 .ALD \\n[#Q_LEAD_DIFF]u
.    el \{\
.       ie \\n[#START] .
.       el \{\
.          ie \\n[#FULLSPACE_QUOTES] \{\
.             ie \\n[#ENDNOTE] .ALD \\n[#EN_LEAD]u+\\n[#Q_LEAD_DIFF]u
.             el .ALD \\n[#DOC_LEAD]u+\\n[#Q_LEAD_DIFF]u
.          \}
.          el \{\
.\" This seems to be the only way to get the baseline of quotes that
.\" start at the top of the page to fall on the first line of the
.\" grid (ie. on the first valid baseline of the page).
.             ie \\n[#Q_TOP]=\\n[#PAGE_TOP] \{\
.                if \\n[#QUOTE]=1 .ds $QUOTE_TYPE Q
.                if \\n[#QUOTE]=2 .ds $QUOTE_TYPE B 
.                rn \\*[$QUOTE_TYPE]_QUOTE Q_TEMP
.                di \\*[$QUOTE_TYPE]_QUOTE
.                nf
.                if \\n[#QUOTE]=1 .vs \\n[#Q_LEAD]u
.                if \\n[#QUOTE]=2 .vs \\n[#BQ_LEAD]u
.                PRINT \&
.                sp -1v+\\n[#Q_LEAD_DIFF]u
.                Q_TEMP
.                di
.                rm Q_TEMP
.                sp \\n[#DOC_LEAD]u/2u
.             \}
.             el \
.                sp \\n[#DOC_LEAD]u/2u
.          \}
.       \}
.       if \\n[#DIVER_FN]=2 .rr #DIVER_FN
.       if !\\n[#NO_FLEX] .FLEX
.    \}
.    rm $QUOTE_TYPE
.END
\#
.MAC Q_NOFIT END
.    rr #Q_FITS
.    if \\n[#QUOTE]=1 \{\
.       ds $QUOTE_TYPE Q
.       ds quote-type quote
.    \}
.    if \\n[#QUOTE]=2 \{\
.       ds $QUOTE_TYPE B 
.       ds quote-type blockquote
.    \}
.    if \\n[has-caption] \{\
.       if !\\n[@TOP] \
.          if !\\n[nl]=\\n[#PAGE_TOP] \
.             if (\\n[.t]-1)<\
\\n[#DOC_LEAD]+(\\n[#DOC_LEAD]/4)\
+\\n[#\\*[QUOTE_TYPE]_LEAD] \{\
.          tm1 "[mom]: Insufficient room for caption and at least one line of \\*[quote-type]
.          tm1 "       on page \\n[%] (line \\n[.c]).  Moving quote to next page or column.
.          ie \\n[#COLUMNS] .COL_NEXT
.          el .NEWPAGE
.       \}
.    \}
.    ie r#HEAD \
.       if \\n[#HEAD]=1 .
.    el \{\
.       if \\n[#Q_DEPTH]=0 \
.          if \\n[.ns] .rs
.       ie \\n[#FULLSPACE_QUOTES] \{\
.          ie \\n[#ENDNOTE] .sp \\n[#EN_LEAD]u+\\n[#Q_LEAD_DIFF]u
.          el .sp \\n[#DOC_LEAD]u+\\n[#Q_LEAD_DIFF]u
.       \}
.       el \{\
.          if '\\*[$QUOTE_TYPE]'Q' .sp \\n[#DOC_LEAD]u
.          if \\n[@TOP] .rs
.       \}
.       ie \\n[#Q_LEAD_REAL] \
.          nr #Q_PARTIAL_DEPTH 0 \\n[#Q_LEAD_REAL]
.       el .nr #Q_PARTIAL_DEPTH 0 \\n[#BQ_LEAD_REAL]
.       while \\n+[#Q_PARTIAL_DEPTH]<(\\n[#TRAP_DISTANCE]-1) \{\
.
.       \}
.       if !\\n[#Q_LEAD_REAL]=\\n[#DOC_LEAD] \{\
.          ie \\n[#Q_LEAD_REAL] \
.             nr #Q_PARTIAL_DEPTH -\\n[#Q_LEAD_REAL]
.          el .nr #Q_PARTIAL_DEPTH -\\n[#BQ_LEAD_REAL]
.       \}
.       nr #Q_SPACE_EQ \
(\\n[#TRAP_DISTANCE]-1)-\\n[#Q_PARTIAL_DEPTH]+(\\n[#Q_LEAD_DIFF]u/2u)
.       if \\n[#FN_COUNT]>0 .nr #Q_SPACE_EQ (\\n[#Q_SPACE_EQ] / 2u)
.\" Hack to deal with the fact that even though the above routine
.\" makes the bottom line of the quote fall exactly on the bottom
.\" margin when traps are disabled, it refuses to do so when traps
.\" are on.  The difference by which it's off is #Q_LEAD_DIFF
.\" (the +\\n[#Q_LEAD_DIFF] at the end of the line, above).  Hack
.\" solution: temporarily lower the FOOTER trap position.
.       if !\\n[#Q_DEPTH]=0 \{\
.          nr #SAVED_FOOTER_POS \\n[#VARIABLE_FOOTER_POS]
.          ch FOOTER \\n[#VARIABLE_FOOTER_POS]u+.25v
.       \}
.    \}
.END
\#
\# ====================================================================
\#
\# +++PAGINATION+++
\#
\# PAGINATE
\# --------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns page numbering off or on during document processing.
\# *Notes:
\#   Default is on.
\#
.MAC PAGINATE END
.    ie '\\$1'' .nr #PAGINATE 1
.    el \{\
.      nr #PAGINATE 0
.      rr #PAGE_NUM_V_POS
.    \}
.    if \\n[#HF_OFF]=1 \{\
.       rr #PAGINATION_STATE
.       rr #HF_OFF
.    \}
.END
\#
\# SUSPEND PAGINATION (before ENDNOTES)
\# ------------------
\# *Argument:
\#   <none>
\# *Function:
\#   Creates register #SUSPEND_PAGINATION
\# *Notes:
\#   Useful only to suspend pagination before outputting endnotes.
\#
.MAC SUSPEND_PAGINATION END
.    nr #SUSPEND_PAGINATION 1
.END
\#
\# RESTORE PAGINATION (after ENDNOTES)
\# ------------------
\# *Argument:
\#   <none>
\# *Function:
\#   Removes register #SUSPEND_PAGINATION.  Creates register
\#   #DEFER_PAGINATION
\# *Notes:
\#   Useful only to restore pagination after outputting endnotes.
\#
.MAC RESTORE_PAGINATION END
.    rr #SUSPEND_PAGINATION
.    if \\n[#PAGE_NUM_V_POS]=1 .PAGINATE
.    if \\n[#PAGE_NUM_V_POS]=2 .nr #DEFER_PAGINATION 1
.END
\#
\# PAGE NUMBER FORMAT
\# ------------------
\# *Arguments:
\#   DIGIT | ROMAN | roman | ALPHA | alpha
\# *Function:
\#   Assigns user entered format to #PAGENUMBER.
\#
.MAC PAGENUM_STYLE END
.    nr #PAGENUM_STYLE_SET 1
.    if '\\$1'DIGIT' \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER 1
.    \}
.    if '\\$1'ROMAN' \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER I
.    \}
.    if '\\$1'roman' \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER i
.    \}
.    if '\\$1'ALPHA' \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER A
.    \}
.    if '\\$1'alpha' \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER a
.    \}
.END
\#
\# HYPHENS AROUND PAGE NUMBERS
\# ---------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or modifies register #PAGE_NUM_HYPHENS.
\#   Used to dis/enable hyphens on either side of page numbers.
\# *Notes:
\#   Default is on.
\#
.MAC PAGENUM_HYPHENS END
.    nr #PAGE_NUM_HYPHENS_SET 1
.    ie '\\$1'' .nr #PAGE_NUM_HYPHENS 1
.    el .rr #PAGE_NUM_HYPHENS
.END
\#
\# PAGENUMBER POSITION
\# -------------------
\# *Arguments:
\#   TOP | BOTTOM  LEFT | CENTER | RIGHT
\# *Function:
\#   Creates or modifies various PAGE_NUM_H | V_POS registers.
\#   Used to position page numbers.
\# *Notes:
\#   Default is center/bottom.
\#
.MAC PAGENUM_POS END
.    nr #PAGE_NUM_POS_SET 1
.    if '\\$1'TOP'    .nr #PAGE_NUM_V_POS 1
.    if '\\$1'BOTTOM' .nr #PAGE_NUM_V_POS 2
.    if '\\$2'LEFT'   .nr #PAGE_NUM_H_POS 1
.    if '\\$2'CENTER' .nr #PAGE_NUM_H_POS 2
.    if '\\$2'CENTRE' .nr #PAGE_NUM_H_POS 2
.    if '\\$2'RIGHT'  .nr #PAGE_NUM_H_POS 3
.END
\#
.MAC PN_WITH_HYPHENS END
.    nr #HYPHEN_ADJ \\n[#CAP_HEIGHT]/12
.    ds $HYPHEN \v'-\En[#HYPHEN_ADJ]u'-\v'\En[#HYPHEN_ADJ]u'
.    ds $PN_FOR_KN \\n[#PAGENUMBER]
.\"  Check for initial or terminal 1's or 7's, and apply a little kerning
.    substring $PN_FOR_KN 0 0 \" 1st digit
.    if '\\*[$PN_FOR_KN]'1' .ds $PRE_HY_KN \*[BU3]
.    if '\\*[$PN_FOR_KN]'7' .ds $PRE_HY_KN \*[BU3]
.    ds $PN_FOR_KN \\n[#PAGENUMBER]
.    substring $PN_FOR_KN -1 -1 \" last digit
.    if '\\*[$PN_FOR_KN]'1' .ds $POST_HY_KN \*[BU3]
.    if '\\*[$PN_FOR_KN]'7' .ds $POST_HY_KN \*[BU3]
.    PRINT \
\m[\\*[$PAGE_NUM_COLOR]]\
\\*[$HYPHEN]\|\\*[$PRE_HY_KN]\\n[#PAGENUMBER]\\*[$POST_HY_KN]\|\\*[$HYPHEN]
.    br
.    rm $PRE_HY_KERN
.    rm $POST_HY_KERN
.END
\#
\# PRINT PAGE NUMBER
\# -----------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Prints page number if PAGINATE=1.
\#
.MAC PRINT_PAGE_NUMBER END
.    ev PAGENUMBER
.    nf
.    po  \\n[#DOC_L_MARGIN]u
.    ll  \\n[#DOC_L_LENGTH]u
.    ta  \\n[.l]u
.    fam \\*[$PAGE_NUM_FAM]
.    ft  \\*[$PAGE_NUM_FT]
.    ps  \\n[#DOC_PT_SIZE]u\\*[$PAGE_NUM_SIZE_CHANGE]
.    if  \\n[#PRINT_STYLE]=1 .TYPEWRITER
.    if  \\n[#PAGE_NUM_V_POS]=1 .vs 0
.    if o \{\
.       ie \\n[#PAGE_NUM_H_POS]=1 .LEFT
.       el .RIGHT
.    \}
.    if e \{\
.       ie \\n[#PAGE_NUM_H_POS]=1 .RIGHT
.       el .LEFT
.    \}
.    if \\n[#PAGE_NUM_H_POS]=2 .CENTER
.    if \\n[#RECTO_VERSO]=0 \{\
.       if \\n[#PAGE_NUM_H_POS]=1 .LEFT
.       if \\n[#PAGE_NUM_H_POS]=2 .CENTER
.       if \\n[#PAGE_NUM_H_POS]=3 .RIGHT
.    \}
.    nr #PAGENUMBER \\n%+\\n[#PAGE_NUM_ADJ]
.    if \\n[#EN_FIRST_PAGE] \{\
.       if \\n[#EN_FIRST_PN] .PAGENUMBER \\n[#EN_FIRST_PN]
.       rr #EN_FIRST_PAGE
.    \}
.    if \\n[#BIB_FIRST_PAGE] \{\
.       if \\n[#BIB_FIRST_PN] .PAGENUMBER \\n[#BIB_FIRST_PN]
.       rr #BIB_FIRST_PAGE
.    \}
.    ie \\n[#DRAFT_WITH_PAGENUM] \{\
.       ie '\\*[$REVISION]'' \
.          PRINT "\\*[$DRAFT_STRING]\\*[$DRAFT] / \\n[#PAGENUMBER]"
.       el \{\
.          ie '\\*[$DRAFT]'' \
.             PRINT "\\*[$REVISION_STRING] \\*[$REVISION] / \\n[#PAGENUMBER]"
.          el \
.             PRINT \
"\\*[$DRAFT_STRING]\\*[$DRAFT], \\*[$REVISION_STRING] \\*[$REVISION] / \
\\n[#PAGENUMBER]"
.       \}
.    \}
.    el \{\
.       ie \\n[#PAGE_NUM_HYPHENS] \{\
.          if '\\*[$PAGENUM_STYLE]'DIGIT' \{\
.             di NULL
1\\R'#CAP_HEIGHT \\n[.cht]'
.             di
.             PN_WITH_HYPHENS
.          \}
.          if '\\*[$PAGENUM_STYLE]'ROMAN' \{\
.             di NULL
I\\R'#CAP_HEIGHT \\n[.cht]'
.             di
.             PN_WITH_HYPHENS
.          \}
.          if '\\*[$PAGENUM_STYLE]'ALPHA' \{\
.             di NULL
E\\R'#CAP_HEIGHT \\n[.cht]'
.             di
.             PN_WITH_HYPHENS
.          \}
.          if '\\*[$PAGENUM_STYLE]'roman' \
.             PRINT \m[\\*[$PAGE_NUM_COLOR]]-\|\\n[#PAGENUMBER]\|-
.          if '\\*[$PAGENUM_STYLE]'alpha' \
.             PRINT \m[\\*[$PAGE_NUM_COLOR]]-\|\\n[#PAGENUMBER]\|-
.       \}
.       el \{\
.          ie !d$PAGENUM_STRING .PRINT \m[\\*[$PAGE_NUM_COLOR]]\\n[#PAGENUMBER]
.          el .PRINT \m[\\*[$PAGE_NUM_COLOR]]\\*[$PAGENUM_STRING]
.       \}
.    \}
.    ev
.    nr #DIVER_DEPTH 0
.END
\#
\# ====================================================================
\#
\# +++FOOTNOTES+++
\#
\# Mom's footnote handling is baroque, to say the least.  There are
\# redundancies in a number of the macros involved, as well as some
\# registers that probably don't get used anymore.  The baggage is left
\# in in case some new footnote oddity/challenge gets thrown at her.
\#
\# The macros are heavily commented.
\#
\# FOOTNOTE AUTOLEAD
\# -----------------
\# *Arguments:
\#   <autolead value for footnotes>
\# *Function:
\#   Creates or modifies register #FN_AUTOLEAD.
\# *Notes:
\#   Default is #DOC_LEAD/2 for TYPEWRITE; 2 for TYPESET
\#
.MAC FOOTNOTE_AUTOLEAD END
.    nr #FN_AUTOLEAD (p;\\$1)
.END
\#
\# FOOTNOTE MARKERS
\# ----------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns generation of footnote markers on or off.
\# *Notes:
\#   Default is on.
\#
.MAC FOOTNOTE_MARKERS END
.    ie '\\$1'' .nr #FN_MARKERS 1
.    el .nr #FN_MARKERS 0
.END
\#
\# FOOTNOTE MARKER STYLE
\# ---------------------
\# *Arguments:
\#   STAR | NUMBER | LINE
\# *Function:
\#   Sets register #FN_MARKER_STYLE, used in FOOTNOTE to determine
\#   the style of footnote markers.
\# *Notes:
\#   1=STAR; 2=NUMBER; 3=LINE.  LINE means "use output line numbers".
\#   Default is STAR.
\#
.MAC FOOTNOTE_MARKER_STYLE END
.    if '\\$1'STAR' \{\
.       if \\n[#FN_MARKER_STYLE]=3 \{\
.          if !\\n[#NEWPAGE]=1 \{\
.             tm1 "[mom]: Your current FOOTNOTE_MARKER STYLE is LINE.
.             tm1 "       You cannot change footnote marker style without
.             tm1 "       first breaking to a new page with NEWPAGE.
.             tm1 "       Ignoring request FOOTNOTE_MARKER_STYLE STAR at line \\n[.c].
.             return
.          \}
.       \}
.       if \\n[#RUN_ON]=1 \{\
.          tm1 "[mom]: FOOTNOTE_MARKER_STYLE STAR at line \\n[.c] is incompatible
.          tm1 "       with RUN_ON footnotes.  Ignoring request.
.          return
.       \}
.       nr #FN_MARKER_STYLE 1
.       if \\n[#NEWPAGE]=1 .rr #NEWPAGE
.       FOOTNOTE_MARKERS
.    \}
.    if '\\$1'NUMBER' \{\
.       if \\n[#FN_MARKER_STYLE]=3 \{\
.          if !\\n[#NEWPAGE]=1 \{\
.             tm1 "[mom]: Your current FOOTNOTE_MARKER STYLE is NUMBER.
.             tm1 "       You cannot change footnote marker style without
.             tm1 "       first breaking to a new page with NEWPAGE.
.             tm1 "       Ignoring request FOOTNOTE_MARKER_STYLE NUMBER at line \\n[.c].
.             return
.          \}
.       \}
.       if \\n[#RUN_ON]=1 \{\
.          tm1 "[mom]: FOOTNOTE_MARKER_STYLE NUMBER at line \\n[.c] is incompatible
.          tm1 "       with RUN_ON footnotes.  Ignoring request.
.          return
.       \}
.       nr #FN_MARKER_STYLE 2
.       shift
.       if '\\$1'NO_SUPERSCRIPT' .nr #NO_SUPERSCRIPT 1
.       if \\n[#NEWPAGE]=1 .rr #NEWPAGE
.       FOOTNOTE_MARKERS
.    \}
.    if '\\$1'LINE' \{\
.       nr #FN_MARKER_STYLE 3
.       FOOTNOTE_MARKERS OFF
.       if !\\n[#FN_LN_SEP] \
.          if !\\n[#FN_LN_BRACKETS] .FOOTNOTE_LINENUMBER_BRACKETS SQUARE
.    \}
.END
\#
\# FOOTNOTE NUMBER PLACEHOLDERS
\# ----------------------------
\# *Argument:
\#   <number of placeholders>
\# *Function:
\#   Sets register #FN_NUMBER_PLACEHOLDERS, used to establish whether to
\#   right pad a footnote number (in the footnote itself, not body copy).
\# *Notes:
\#   No default is set for this; user must determine if, and where, it's
\#   required
\#
.MAC FOOTNOTE_NUMBER_PLACEHOLDERS END
.    nr #FN_NUMBER_PLACEHOLDERS \\$1
.END
\#
\# FOOTNOTE LINENUMBER MARK
\# ------------------------
\# *Function:
\#   This string, when called inline, stores the current output line
\#   number in register #FN_MARK for use with FOOTNOTE.
\#
.ds FN_MARK \R'#FN_MARK \En[ln]'
\#
\# FOOTNOTE LINENUMBER SEPARATOR
\# -----------------------------
\# *Argument:
\#   <user-defined separator>
\# *Function:
\#   Stores user-defined separator (for use then
\#   FOOTNOTE_MARKER_STYLE is LINE) in string $FN_LN_SEP.  The
\#   separator is intended to be used when the user wishes a
\#   separator, rather than the choice of brackets offered by
\#   FOOTNOTE_LINENUMBER_BRACKETS.
\#
.MAC FOOTNOTE_LINENUMBER_SEPARATOR END
.    rr #FN_LN_BRACKETS
.    nr #FN_LN_SEP 1
.    ds $FN_LN_SEP "\\$1
.END
\#
\# FOOTNOTE LINENUMBER BRACKETS
\# ----------------------------
\# *Argument:
\#   PARENS | SQUARE | BRACES or ( | [ | {
\# *Function:
\#   Sets register #FN_LN_BRACKETS to 1, and creates strings
\#   $FN_OPEN_BRACKET and $FN_CLOSE_BRACKET according to the given
\#   argument.
\#
.MAC FOOTNOTE_LINENUMBER_BRACKETS END
.    rr #FN_LN_SEP
.    nr #FN_LN_BRACKETS 1
.    if '\\$1'PARENS' \{\
.       ds $FN_OPEN_BRACKET (
.       ds $FN_CLOSE_BRACKET )
.    \}
.    if '\\$1'(' \{\
.       ds $FN_OPEN_BRACKET (
.       ds $FN_CLOSE_BRACKET )
.    \}
.    if '\\$1'SQUARE' \{\
.       ds $FN_OPEN_BRACKET [
.       ds $FN_CLOSE_BRACKET ]
.    \}
.    if '\\$1'[' \{\
.       ds $FN_OPEN_BRACKET [
.       ds $FN_CLOSE_BRACKET ]
.    \}
.    if '\\$1'BRACES' \{\
.       ds $FN_OPEN_BRACKET {
.       ds $FN_CLOSE_BRACKET }
.    \}
.    if '\\$1'{' \{\
.       ds $FN_OPEN_BRACKET {
.       ds $FN_CLOSE_BRACKET }
.    \}
.END
\#
\# RESET FOOTNOTE NUMBER
\# ---------------------
\# *Arguments:
\#   <none> | PAGE
\# *Function:
\#   Resets register #FN_NUMBER to 1.  If argument is PAGE, creates
\#   toggle #RESET_FN_NUMBER which is checked in HEADER.  If 1,
\#   numbered footnotes on every page start at 1.
\#
.MAC RESET_FOOTNOTE_NUMBER END
.    ie '\\$1'' .nr #FN_NUMBER 0 1
.    el .nr #RESET_FN_NUMBER 1
.END
\#
\# FOOTNOTE RULE LENGTH
\# --------------------
\# *Arguments:
\#   <length of rule used to separate footnotes from running text>
\# *Function:
\#   Creates or modifies registers #FN_RULE_LENGTH.
\# *Notes:
\#   Requires unit of measure (iPpcm).
\#   Default is 4P for both PRINTSTYLEs.
\#
.MAC FOOTNOTE_RULE_LENGTH END
.    nr #FN_RULE_LENGTH (\\$1)
.END
\#
\# FOOTNOTE_RULE_ADJ
\# -----------------
\# *Arguments:
\#   <number of points to raise footnote rule from it's baseline position>
\# *Function:
\#   Creates or modifies register #FN_RULE_ADJ.
\# *Notes:
\#   Default is 3p for both TYPESTYLES.
\#
\#   Requires unit of measure.
\#
.MAC FOOTNOTE_RULE_ADJ END
.    nr #FN_RULE_ADJ (\\$1)
.END
\#
\# FOOTNOTE RULE
\# -------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns printing of footnote separator rule on or off.  If invoked as
\#   PRINT_FOOTNOTE_RULE, prints footnote separator rule.
\# *Notes:
\#   Default is on.
\#
\#   Invoked in FOOTNOTE (as PRINT_FOOTNOTE_RULE) as 1st line of a footnote
\#   if the footnote number (#FN_COUNT) is 1.
\#
.MAC FOOTNOTE_RULE END
.    ie '\\$0'PRINT_FOOTNOTE_RULE' \{\
.       if \\n[#FN_RULE]=0 .RLD 1v
.       RLD 1v
.       LEFT
\v'-\\n[#FN_RULE_ADJ]u-\\n[#FN_RULE_WEIGHT_ADJ]u'\
\D't \\n[#FN_RULE_WEIGHT]'\
\h'-\\n[#FN_RULE_WEIGHT]u'\
\D'l \\n[#FN_RULE_LENGTH]u 0'\
\v'+\\n[#FN_RULE_ADJ]u+\\n[#FN_RULE_WEIGHT_ADJ]u'
\!.     ps \\n[#DOC_PT_SIZE]u\\*$[FN_SIZE_CHANGE]
.       QUAD \\*[$FN_QUAD]
.    \}
.    el \{\
.       ie '\\$1'' .nr #FN_RULE 1
.       el .nr #FN_RULE 0
.    \}
.END
\#
\# FOOTNOTE SPACING
\# ----------------
\# *Arguments:
\#   <per item post footnote spacing> | <anything>
\# *Function:
\#   Enables printing of post footnote spacing.
\# *Notes:
\#   Default is no space.
\#
.MAC FOOTNOTE_SPACING END
.    ie \B'\\$1' .ds $FN_SPACE \\$1
.    el .rm $FN_SPACE
.END
\#
\# FOOTNOTE FIRST LINE INDENT
\# --------------------------
\# *Arguments:
\#   <indent>
\# *Function:
\#   Indents first line of footnotes.
\# *Notes:
\#   Default is no indent.
\#
.MAC FOOTNOTE_INDENT END
. nr #FN_INDENT \\$1
.END
\#
\# RUN ON FOOTNOTES
\# ----------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles run-on footnotes on or off.
\#
.MAC FOOTNOTES_RUN_ON END
.    ie '\\$1'' \{\
.       if \\n[#FN_COUNT]>0 \{\
.          tm1 "[mom]: Switching to run-on footnotes at line \\n[.c] will cause
.          tm1 "       you to loose footnotes already formatted for this page.
.          tm1 "       Ignoring request FOOTNOTES_RUN_ON.
.          rr #RUN_ON
.          return
.       \}
.       nr #RUN_ON 1
.       if \\n[#FN_MARKER_STYLE]=1 .RUNON_WARNING
.       if \\n[#FN_MARKER_STYLE]=2 .RUNON_WARNING
.    \}
.    el \{\
.       if \\n[#FN_COUNT]>0 \{\
.          if \\n[#RUN_ON]=1 \{\
.             tm1 "[mom]: Switching off run-on footnotes at line \\n[.c] will cause
.             tm1 "       you to loose footnotes already formatted for this page.
.             tm1 "       Ignoring request FOOTNOTES_RUN_ON \\$1.
.             return
.          \}
.       \}
.       rr #RUN_ON
.    \}
.END
\#
.MAC RUNON_WARNING END
.    if \\n[#FN_MARKER_STYLE]=1 \{\
.       tm1 "[mom]: The footnote marker style active at line \\n[.c] is STAR,
.       tm1 "       which is incompatible with run-on footnotes.  Please change
.       tm1 "       the footnote marker style to LINE.  Continuing to process,
.       tm1 "       but ignoring request FOOTNOTES_RUN_ON.
.       rr #RUN_ON
.    \}
.    if \\n[#FN_MARKER_STYLE]=2 \{\
.       tm1 "[mom]: The footnote marker style active at line \\n[.c] is NUMBER,
.       tm1 "       which is incompatible with run-on footnotes.  Please change
.       tm1 "       the footnote marker style to LINE.  Continuing to process,
.       tm1 "       but ignoring request FOOTNOTES_RUN_ON.
.       rr #RUN_ON
.    \}
.END
\#
\# FOOTNOTE
\# --------
\# *Arguments:
\#   <none> | INDENT  L|LEFT|R|RIGHT|B|BOTH  <indent value> | <anything>
\# *Function:
\#   Begins collecting and diverting footnote text if no argument
\#   given.  Otherwise, ends diversion FOOTNOTES, measures footnote
\#   depth, and sets footnote trap.
\# *Notes:
\#   The input line preceding a footnote call MUST terminate with \c
\#   or the footnote marker will be spaced away from the word it
\#   should be joined to.
\#
\#   If FOOTNOTE is invoked with INDENT, the footnote will
\#   be indented.  An indent style and an indent value must be given.
\#   Subsequent footnotes will NOT be indented; INDENT must be given
\#   for each footnote the user wants indented.
\#
.MAC FOOTNOTE END
.    ie '\\$1'' \{\
.       if \\n[#UNDERLINE_ON] \{\
.          UNDERLINE OFF
.          nr #UNDERLINE_WAS_ON_FN 1
.       \}
.       if \\n[#FN_MARKER_STYLE]=3 \{\
.          if !\\n[#LINENUMBERS] \{\
.             tm1 "[mom]: Line numbering must be enabled with NUMBER_LINES when
.             tm1 "       FOOTNOTE_MARKER_STYLE is LINE.
.             ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.          \}
.          if \\n[#FN_MARK]=0 .nr #FN_MARK \\n[ln]
.          nr #FN_MARK_2 \\n[ln]
.          if '\\n[.z]'P_QUOTE' \{\
.             nr #FN_MARK -1
.             nr #FN_MARK_2 -1
.          \}
.          if \\n[#IN_DIVER]=1 \{\
.             if '\\n[.z]'P_QUOTE' \{\
.                if !\\n[#QUOTE_LN]=1 \{\
.                   if !\\n[#SILENT_QUOTE_LN]=1 \{\
.                      tm1 "[mom]: You have requested a line-numbered footnote inside a
.                      tm1 "       QUOTE at line \\n[.c], but line-numbering has not been enabled
.                      tm1 "       for QUOTES.  Printing footnote with label "0".
.                      rr #FN_MARK
.                      rr #FN_MARK_2
.                   \}
.                \}
.             \}
.             if '\\n[.z]'B_QUOTE' \{\
.                if !\\n[#BQUOTE_LN]=1 \{\
.                   if !\\n[#SILENT_BQUOTE_LN]=1 \{\
.                      tm1 "[mom]: You have requested a line-numbered footnote inside a
.                      tm1 "       BLOCKQUOTE at line \\n[.c], but line-numbering has not been enabled
.                      tm1 "       for BLOCKQUOTES.  Printing footnote with label "0".
.                      rr #FN_MARK
.                      rr #FN_MARK_2
.                   \}
.                \}
.             \}
.          \}
.       \}
.\" Begin processing footnotes that occur inside QUOTE, BLOCKQUOTE
.\" or EPIGRAPH.
.       if \\n[#IN_DIVER]=1 \{\
.          nr #PAGE_POS \\n[nl]+\\n[.d]+\\n[#DOC_LEAD]
.          nr #FOOTER_POS \\n[#PAGE_LENGTH]+(\\n[#VARIABLE_FOOTER_POS]-1)
.          nr #SPACE_TO_FOOTER \\n[#FOOTER_POS]-\\n[#PAGE_POS]
.\" Are we on a "defer" line?  If so, defer the text of the footnote.
.          ie \\n[#SPACE_TO_FOOTER]<=\\n[#DOC_LEAD] \
.             nr #DIVER_FN 2 \" treat like a normal deferred footnote
.          el \
.             nr #DIVER_FN 2 \" treat like a normal footnote
.          if \\n[#PAGE_POS]>\\n[#FOOTER_POS] \
.             nr #DIVER_FN 1 \" move this footnote
.\" Test for situation where, because a final line of QUOTE, BLOCKQUOTE
.\" or EPIGRAPH isn't yet adjusted at this point, the last word on the
.\" line may *seem* to belong to the final line of the page, but will,
.\" in fact, become the first word of the subsequent page.  In such
.\" circumstances, we want the footnote to be treated as a "moved"
.\" diversion footnote.
.          if \\n[.k]>\\n[.l] .nr #DIVER_FN 1
.          if r #DIVER_FN \{\
.             if !\\n[#DIVER_FN]=2 .\\n+[#DONE_ONCE]
.\" A footnote inside a diversion will become the 1st footnote on the
.\" following page/column.
.             if \\n[#DIVER_FN]=1 .DIVER_FN_1_PRE
.\" A footnote inside a diversion that should be treated like a
.\" normal footnote (including defers.)
.             if \\n[#DIVER_FN]=2 .DIVER_FN_2_PRE
.          \}
.          nr #SAVED_FN_COUNT \\n[#FN_COUNT]+1
.          nr #SAVED_FN_COUNT_FOR_COLS \\n[#FN_COUNT_FOR_COLS]+1
.       \}
.\" End processing footnotes that occur inside QUOTE, BLOCKQUOTE or
.\" EPIGRAPH.
.\"
.\" Test for situation where, because a final line of running text
.\" isn't yet adjusted at this point, the last word on the line may
.\" *seem* to belong to the final line of the page, but will, in
.\" fact, become the first word of the subsequent page.  In such
.\" circumstances, we want the footnote marker in running text to
.\" be the correct one for the 1st footnote on the page.
.       if \\n[.k]>\\n[.l] \{\
.          if (\\n[nl]+\\n[#DOC_LEAD])>(\\n[#PAGE_LENGTH]+\\n[#VARIABLE_FOOTER_POS]) \{\
.             ie \\n[#COLUMNS]=1 \{\
.                if \\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.                   if \\n[#FN_MARKER_STYLE]=1 .nr #FN_COUNT_FOR_COLS 0 1
.                   if \\n[#FN_MARKER_STYLE]=2 \{\
.                      if \\n[#RESET_FN_NUMBER] \{\
.                         nr #FN_NUMBER 0 1
.                         nr #NOT_YET_ADJUSTED 1
.                      \}
.                   \}
.                \}
.             \}
.             el \{\
.                if \\n[#FN_MARKER_STYLE]=1 .nr #FN_COUNT 0 1
.                if \\n[#FN_MARKER_STYLE]=2 \{\
.                   if \\n[#RESET_FN_NUMBER] \{\
.                      nr #FN_NUMBER 0 1
.                      nr #NOT_YET_ADJUSTED 1
.                   \}
.                \}
.             \}
.          \}
.       \}
.       if \\n[#FN_MARKERS] \{\
.\" Housekeeping
.          if \\n[#CONDENSE] \*[CONDX]\c
.          if \\n[#EXTEND] \*[EXTX]\c
.\" Add footnote markers to running text...
.          if !\\n[#NO_FN_MARKER] \{\
.\" ...but not if TERMINATE has not been called
.             if !r#TERMINATE \{\
.\" Marker style star/dagger/double-dagger
.                if \\n[#FN_MARKER_STYLE]=1 \{\
.\" Columnar docs either move col to col, or last col to next page.
.\" They require their own special FN_COUNT because regular FN_COUNT
.\" is used to figure out things like whether or not to put a rule
.\" above footnotes (in addition to keeping track of the footnote
.\" count in non-columnar docs).
.                   ie \\n[#COLUMNS]=1 \{\
.                      if \\n[#FN_COUNT_FOR_COLS]=0 .PRINT \*[BU2]*\c
.                      if \\n[#FN_COUNT_FOR_COLS]=1 .PRINT \*[BU1]\[dg]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=2 .PRINT \[dd]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=3 .PRINT \*[BU2]**\c
.                      if \\n[#FN_COUNT_FOR_COLS]=4 .PRINT \*[BU1]\[dg]\[dg]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=5 .PRINT \[dd]\[dd]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=6 .PRINT \*[BU2]***\c
.                      if \\n[#FN_COUNT_FOR_COLS]=7 .PRINT \*[BU1]\[dg]\[dg]\[dg]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=8 .PRINT \[dd]\[dd]\[dd]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=9 .PRINT \*[BU2]****\c
.                   \}
.                   el \{\
.                      if \\n[#FN_COUNT]=0 .PRINT \*[BU2]*\c
.                      if \\n[#FN_COUNT]=1 .PRINT \*[BU1]\[dg]\c
.                      if \\n[#FN_COUNT]=2 .PRINT \[dd]\c
.                      if \\n[#FN_COUNT]=3 .PRINT \*[BU2]**\c
.                      if \\n[#FN_COUNT]=4 .PRINT \*[BU1]\[dg]\[dg]\c
.                      if \\n[#FN_COUNT]=5 .PRINT \[dd]\[dd]\c
.                      if \\n[#FN_COUNT]=6 .PRINT \*[BU2]***\c
.                      if \\n[#FN_COUNT]=7 .PRINT \*[BU1]\[dg]\[dg]\[dg]\c
.                      if \\n[#FN_COUNT]=8 .PRINT \[dd]\[dd]\[dd]\c
.                      if \\n[#FN_COUNT]=9 .PRINT \*[BU2]****\c
.                   \}
.                \}
.\" Marker style superscript numbers
.                if \\n[#FN_MARKER_STYLE]=2 \{\
.                   if \\n[#PRINT_STYLE]=1 \
.                      PRINT \
"\s-2\v'-\\n[#DOC_LEAD]u/5u'\\n+[#FN_NUMBER]\v'+\\n[#DOC_LEAD]u/5u'\s+2\c"
.                   if \\n[#PRINT_STYLE]=2 \
.                      PRINT \
"\*[SUP]\\n+[#FN_NUMBER]\*[SUPX]\c"
.                \}
.             \}
.          \}
.       \}
.\" More housekeeping
.\"
.\" #SPACE_REMAINING is the space left between where we are
.\" on the page and the bottom margin.  It's used to determine whether
.\" or not the footnote will overflow, and how many lines of
.\" footnotes will fit on the page if some have to overflow.
.       ie \\n[#DIVER_FN]=2 \
.          nr #SPACE_REMAINING (\\n[#PAGE_LENGTH]-\\n[#B_MARGIN])-(\\n[#PAGE_POS])
.       el \
.          nr #SPACE_REMAINING (\\n[#PAGE_LENGTH]-\\n[#B_MARGIN])-\\n[nl]
.       if \\n[#FROM_DIVERT_FN]=1 \{\
.          nr #SPACE_REMAINING \\n[#PAGE_LENGTH]-\\n[#B_MARGIN]
.          rr #FROM_DIVERT_FN
.       \}
.       nr #PP_STYLE_PREV \\n[#PP_STYLE]
.       nr #PP_STYLE 2
.       if \\n[#INDENT_FIRST_PARAS] .nr #INDENT_FIRSTS 1
.       INDENT_FIRST_PARAS
.\" Prepare FOOTNOTE to receive footnote text.
.       ev FOOTNOTES
.       ll \\n[#DOC_L_LENGTH]u
.       ta \\n[.l]u
.       if \\n[#COLUMNS]=1 \{\
.          ll \\n[#COL_L_LENGTH]u
.          ta \\n[.l]u
.       \}
.       if \\n[#FN_R_INDENT] \{\
.          ll -\\n[#FN_R_INDENT]u
.          ta \\n[.l]u
.       \}
.       if \\n[#FN_BR_INDENT] \{\
.          ll -\\n[#FN_BR_INDENT]u
.          ta \\n[.l]u
.       \}
.       FAMILY   \\*[$FN_FAM]
.       FT       \\*[$FN_FT]
.       ps  \\n[#DOC_PT_SIZE]u\\*[$FN_SIZE_CHANGE]
.       vs \\n[.ps]u+\\n[#FN_AUTOLEAD]u
.       QUAD     \\*[$FN_QUAD]
.       if \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          ie \\n[#SINGLE_SPACE] .vs \\n[#ORIGINAL_DOC_LEAD]u
.          el .vs \\n[#ORIGINAL_DOC_LEAD]u/2u
.          QUAD LEFT
.          HY OFF
.       \}
.       nr #FN_LEAD \\n[#LEAD]
.\" Begin diversion FOOTNOTES or FN_IN_DIVER
.       ie r#COUNTERS_RESET \{\
.          ie \\n[#DONE_ONCE]=1 \{\
.             ie \\n[#RUN_ON] \{\
.                di RUNON_FN_IN_DIVER
.                nr #RUNON_FN_IN_DIVER 1
.             \}
.             el .di FN_IN_DIVER
.          \}
.          el \{\
.             ie \\n[#RUN_ON] \{\
.                da RUNON_FN_IN_DIVER
.                nr #RUNON_FN_IN_DIVER 1
.             \}
.             el .da FN_IN_DIVER
.          \}
.       \\n+[#DONE_ONCE]
.       \}
.       el \{\
.          ie \\n[#RUN_ON] \{\
.             da RUNON_FOOTNOTES
.             nr #RUNON_FOOTNOTES 1
.          \}
.          el .da FOOTNOTES
.       \}
.       if \\n[#FOOTNOTE_COLOR]=1 \{\
.          TRAP OFF
.          nf
\m[\\*[$FOOTNOTE_COLOR]]
.          EOL
.          fi
.          TRAP
.       \}
.       if \\n[#EPIGRAPH] .nr #FN_FOR_EPI 1
.\" When a deferred footnote is also the 1st footnote on the page,
.\" and when the page it's output on also has footnotes, some
.\" whitespace is needed between the deferred footnote and the
.\" first footnote belonging to the output page so that there's
.\" no confusion when two stars (or two number 1s) appear in
.\" footnotes...
.       if \\n[#FN_DEFER_SPACE] \{\
.\" ...but only add the extra space if TERMINATE has not been called
.          if !r#TERMINATE \{\
.\" ...and not if defer space has already been added
.             if !\\n[#DEFER_SPACE_ADDED] \{\
.\" ...and not if the footnote count the last time we checked for
.\" a defer situation inside a diversion is greater than 1.
.                if !\\n[#SAVED_DIVER_FN_COUNT]>1 \{\
.                   if \\n[#FN_MARKER_STYLE]=1 .ALD 1v
.                   if \\n[#RESET_FN_NUMBER] .ALD 1v
.                   nr #DEFER_SPACE_ADDED 1
.                \}
.             \}
.          \}
.          rr #FN_DEFER_SPACE
.          rr #SAVED_DIVER_FN_COUNT
.       \}
.       if \\n[#DIVERTED]=3 \{\
.          if \\n[#FN_COUNT]>0 \{\
\!.           RLD 1v
.          \}
.       \}
.\" Add footnote rule (or, if no rule, some whitespace).
.\" N.B.- this line increments #FN_COUNT each and every time FOOTNOTE
.\" is run.
.       if \\n+[#FN_COUNT]=1 \{\
.\" If a footnote is called in a diversion, and the footnote has to
.\" be moved, don't put in the rule now (it's taken care of when
.\" FN_IN_DIVER is output into FOOTNOTE in PROCESS_FN_IN_DIVER).
.          if !\\n[#DONT_RULE_ME]=1 \{\
.             if !\\n[#FN_DEPTH] \{\
.                if \\n[#PRINT_STYLE]=1 \
.                   if !\\n[#RUN_ON] .sp \\n[#DOC_LEAD]u
.                ie \\n[#FN_RULE]=1 \{\
.                   if !\\n[#RUN_ON] \{\
.                      if \\n[#SINGLE_SPACE] .sp \\n[#DOC_LEAD]u
.                      PRINT_FOOTNOTE_RULE
.                      if !'\\*[$FN_SPACE]'' .sp -\\*[$FN_SPACE]
.                   \}
.                \}
.                el .sp
.                nr #RULED 1
.             \}
.          \}
.       \}
.       rr #DONT_RULE_ME
.       ds $RESTORE_SS_VAR \\*[$SS_VAR]
.       SS 0
.\" Add footnote markers to footnote text...
.       ie \\n[#FN_MARKERS] \{\
.          if !'\\*[$FN_SPACE]'' \
.             if \\n[#FN_COUNT]>0 .ALD \\*[$FN_SPACE]
.          if !\\n[#NO_FN_MARKER] \{\
.\" ...but not if TERMINATE has been called.
.             if !r#TERMINATE \{\
.                if \\n[#REF]=1 \{\
.                   nr #REF_FN_INDENT (u;\\*[$REF_FN_INDENT])
.                   ti \\n[#REF_FN_INDENT]u
.                \}
.                if \\n[#FN_MARKER_STYLE]=1 \{\
.                   ie \\n[#COLUMNS]=1 \{\
.                      \\n+[#FN_COUNT_FOR_COLS]
.                      if \\n[#FN_COUNT_FOR_COLS]=1 .PRINT \h'0+\\n[#FN_INDENT]u'*\c
.                      if \\n[#FN_COUNT_FOR_COLS]=2 .PRINT \h'0+\\n[#FN_INDENT]u'\[dg]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=3 .PRINT \h'0+\\n[#FN_INDENT]u'\[dd]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=4 .PRINT \h'0+\\n[#FN_INDENT]u'**\c
.                      if \\n[#FN_COUNT_FOR_COLS]=5 .PRINT \h'0+\\n[#FN_INDENT]u'\[dg]\[dg]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=6 .PRINT \h'0+\\n[#FN_INDENT]u'\[dd]\[dd]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=7 .PRINT \h'0+\\n[#FN_INDENT]u'***\c
.                      if \\n[#FN_COUNT_FOR_COLS]=8 .PRINT \h'0+\\n[#FN_INDENT]u'\[dg]\[dg]\[dg]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=9 .PRINT \h'0+\\n[#FN_INDENT]u'\[dd]\[dd]\[dd]\c
.                      if \\n[#FN_COUNT_FOR_COLS]=10 .PRINT \h'0+\\n[#FN_INDENT]u'****\c
.                   \}
.                   el \{\
.                      if \\n[#FN_COUNT]=1 .PRINT \h'0+\\n[#FN_INDENT]u'*\c
.                      if \\n[#FN_COUNT]=2 .PRINT \h'0+\\n[#FN_INDENT]u'\[dg]\c
.                      if \\n[#FN_COUNT]=3 .PRINT \h'0+\\n[#FN_INDENT]u'\[dd]\c
.                      if \\n[#FN_COUNT]=4 .PRINT \h'0+\\n[#FN_INDENT]u'**\c
.                      if \\n[#FN_COUNT]=5 .PRINT \h'0+\\n[#FN_INDENT]u'\[dg]\[dg]\c
.                      if \\n[#FN_COUNT]=6 .PRINT \h'0+\\n[#FN_INDENT]u'\[dd]\[dd]\c
.                      if \\n[#FN_COUNT]=7 .PRINT \h'0+\\n[#FN_INDENT]u'***\c
.                      if \\n[#FN_COUNT]=8 .PRINT \h'0+\\n[#FN_INDENT]u'\[dg]\[dg]\[dg]\c
.                      if \\n[#FN_COUNT]=9 .PRINT \h'0+\\n[#FN_INDENT]u'\[dd]\[dd]\[dd]\c
.                      if \\n[#FN_COUNT]=10 .PRINT \h'0+\\n[#FN_INDENT]u'****\c
.                   \}
.                \}
.                if \\n[#FN_MARKER_STYLE]=2 \{\
.                   ds $FN_NUMBER \\n[#FN_NUMBER]
.                   length #FN_NUMBER_LENGTH \\*[$FN_NUMBER]
.                   if \\n[#COLUMNS]=1 \
.                      \\n+[#FN_COUNT_FOR_COLS]
.                   if \\n[#NOT_YET_ADJUSTED]=1 \{\
.                      nr #FN_NUMBER 1 1
.                      rr #NOT_YET_ADJUSTED
.                   \}
.                   if \\n[#PRINT_STYLE]=1 \{\
.                      ie \\n[#NO_SUPERSCRIPT] \{\
.                         ie \\n[#FN_NUMBER_LENGTH]<\\n[#FN_NUMBER_PLACEHOLDERS] \
.                            PRINT "\h'0+\\n[#FN_INDENT]u'\0(\\n[#FN_NUMBER])\|\c"
.                         el \
.                            PRINT "\h'0+\\n[#FN_INDENT]u'(\\n[#FN_NUMBER])\|\c"
.                      \}
.                      el \{\
.                         ie \\n[#FN_NUMBER_LENGTH]<\\n[#FN_NUMBER_PLACEHOLDERS] \
.                            PRINT \
"\h'0+\\n[#FN_INDENT]u'\s-2\v'-\\n[.v]u/5u'\0\\n[#FN_NUMBER]\|\v'+\\n[.v]u/5u'\s+2\|\c"
.                         el \
.                            PRINT \
"\h'0+\\n[#FN_INDENT]u'\s-2\v'-\\n[.v]u/5u'\\n[#FN_NUMBER]\|\v'+\\n[.v]u/5u'\s+2\|\c"
.                      \}
.                   \}
.                   if \\n[#PRINT_STYLE]=2 \{\
.                      ie \\n[#FN_NUMBER_LENGTH]<\\n[#FN_NUMBER_PLACEHOLDERS] \
.                         PRINT "\h'0+\\n[#FN_INDENT]u'\*[SUP]\0\\n[#FN_NUMBER]\*[SUPX]\*[FU 3]\c"
.                      el \
.                         PRINT "\h'0+\\n[#FN_INDENT]u'\*[SUP]\\n[#FN_NUMBER]\*[SUPX]\*[FU 3]\c"
.                   \}
.                \}
.             \}
.          \}
.       \}
.       el \{\
.\" Line-numbered footnotes handling
.          if \\n[#FN_MARKER_STYLE]=3 \{\
.             if \\n[#FN_SPACE]>0 \{\
.                if !\\n[#RUN_ON]=1 \
.                   if \\n[#FN_COUNT]>0 .ALD \\n[#FN_SPACE]u
.             \}
.             if \\n[#REF]=1 \{\
.                if !\\n[#RUN_ON]=1 \{\
\!.                 ti +\\n[#REF_FN_INDENT]uu
.                \}
.             \}
.             ie \\n[#FN_LN_BRACKETS]=1 \{\
.                ds $FN_LINENUMBER \h'0+\\n[#FN_INDENT]u'\v'-.085m'\\*[$FN_OPEN_BRACKET]\v'.085m'
.                ie \\n[#FN_MARK_2]=\\n[#FN_MARK] \
.                   as $FN_LINENUMBER \
\\n[#FN_MARK]\v'-.085m'\\*[$FN_CLOSE_BRACKET]\v'.085m'\h'.25m'
.                el \
.                   as $FN_LINENUMBER \
\\n[#FN_MARK]\v'-.1m'-\v'.1m'\\n[#FN_MARK_2]\v'-.085m'\
\\*[$FN_CLOSE_BRACKET]\v'.085m'\h'.25m'
.             \}
.             el \{\
.                ie \\n[#FN_MARK_2]=\\n[#FN_MARK] \
.                   ds $FN_LINENUMBER \\n[#FN_MARK]\\*[$FN_LN_SEP]
.                el \
.                   ds $FN_LINENUMBER \
\h'0+\\n[#FN_INDENT]u'\\n[#FN_MARK]\v'-.1m'-\v'.1m'\\n[#FN_MARK_2]\\*[$FN_LN_SEP]
.                \}
.             \}
.          if !\\n[#NO_FN_MARKER] \
.             PRINT \\*[$FN_LINENUMBER]\c
.          rm $FN_LINENUMBER
.          nr #FN_MARK 0
.       \}
.    \}
.    el \{\
.\" If INDENT arg is passed to FOOTNOTE, calculate the indent...
.       ie '\\$1'INDENT' \{\
.          ev FOOTNOTES
.          if '\\$2'L' .in (\\$3)
.          if '\\$2'LEFT' .in (\\$3)
.          if '\\$2'R' .nr #FN_R_INDENT (\\$3)
.          if '\\$2'RIGHT' .nr #FN_R_INDENT (\\$3)
.          if '\\$2'B' \{\
.             nr #FN_BL_INDENT (\\$3)
.             ie '\\$4'' .nr #FN_BR_INDENT \\n[#FN_BL_INDENT]
.             el .nr #FN_BR_INDENT (\\$4)
.             in \\n[#FN_BL_INDENT]u
.          \}
.          if '\\$2'BOTH' \{\
.             nr #FN_BL_INDENT (\\$3)
.             ie '\\$4'' .nr #FN_BR_INDENT \\n[#FN_BL_INDENT]
.             el .nr #FN_BR_INDENT (\\$4)
.             in \\n[#FN_BL_INDENT]u
.          \}
.          ev
.\" ...then re-run FOOTNOTE without an argument.
.          FOOTNOTE
.       \}
.       el \{\
.          br
.\" Add "defer space" if the previously diverted footnote was the
.\" 1st footnote proper to its page (i.e. it looks like a deferred
.\" footnote but it's really an overflow).
.          if \\n[#DIVERTED] \{\
.             if \\n[#PREV_FN_DEFERRED]=1 \{\
.                if \\n[#FN_MARKER_STYLE]=1 .ALD \\n[#FN_LEAD]u
.                if \\n[#RESET_FN_NUMBER] .ALD \\n[#FN_LEAD]u
.                nr #PREV_FN_DEFERRED 2
.             \}
.          \}
.          if \\n[#REF]=1 \{\
\!.           in
.          \}
.\" Terminate FOOTNOTES or FN_IN_DIVER diversion
.          di
.          HY_SET 1 \\n[#DIVERSIONS_HY_MARGIN]u (\\n[#PT_SIZE]u/1000u/8u)p
.          hy 14
.\" More housekeeping
.\" Turn off indent possibly set by FOOTNOTE INDENT
.          in 0
.          ev
.          if \\n[#UNDERLINE_WAS_ON_FN] \{\
.             UNDERLINE
.             rr #UNDERLINE_WAS_ON_FN
.          \}
.\" Restore sentence spacing
.          if \\n[#PRINT_STYLE]=2 \{\
.             if d $RESTORE_SS_VAR .SS \\*[$RESTORE_SS_VAR]
.             rm $RESTORE_SS_VAR
.          \}
.          rr #FN_R_INDENT
.          rr #FN_BR_INDENT
.          nr #PP_STYLE \\n[#PP_STYLE_PREV]
.          if !\\n[#INDENT_FIRSTS] .INDENT_FIRST_PARAS OFF
.          rr #INDENT_FIRSTS
.\" Calculate footnote depth, but not if #COUNTERS_RESET (created in
.\" DIVER_FN_1_PRE) to instruct FOOTNOTES to skip this step for now
.\" (it's taken care of when FN_IN_DIVER is output into FOOTNOTES in
.\" PROCESS_FN_IN_DIVER).
.          ie r#COUNTERS_RESET .rr #COUNTERS_RESET
.          el \{\
.             nr #GET_DEPTH 1
.\" If the footnote is the 1st on the page and it falls too close
.\" to the bottom margin, defer the footnote text to the next page...
.             if (\\n[#SPACE_REMAINING]-1)<=(\\n[.v]) \{\
.\" ...but not if PROCESS_FN_LEFTOVER has set #PREV_FN_DEFERRED to 1
.                if !\\n[#PREV_FN_DEFERRED]=1 \{\
.                   nr #FN_DEFER 1
.                   nr #FN_DEPTH +\\n[#DIVER_DEPTH]
.                   rr #GET_DEPTH
.\" This is required so that the defer space clause can distinguish
.\" a real #FN_COUNT=1 from one generated if FOOTNOTE is run inside
.\" QUOTE, BLOCKQUOTE or EPIGRAPH
.                   if \\n[#DIVER_FN]=2 \{\
.                      nr #SAVED_DIVER_FN_COUNT \\n[#FN_COUNT]
.                      rr #DIVER_FN
.                   \}
.                \}
.             \}
.\" Calculate the footnote depth.
.             if \\n[#GET_DEPTH]=1 \{\
.\" Save the previous footnote depth (for use when there will be
.\" some overflowed footnote text).
.                nr #SAVED_FN_DEPTH_1 \\n[#FN_DEPTH]
.\" Add the depth of the current footnote to any already existent
.\" footnotes.
.                nr #FN_DEPTH +\\n[#DIVER_DEPTH]
.\" Special handling for run-on footnotes
.                if \\n[#RUN_ON]=1 \{\
.                   if \\n[#RUNON_FOOTNOTES]   .unformat RUNON_FOOTNOTES
.                   if \\n[#RUNON_FN_IN_DIVER] .unformat RUNON_FN_IN_DIVER
.                   ev FOOTNOTES
.\" Recreate FOOTNOTES with rule followed by text of unformatted
.\" run-on footnotes.
.                   di FOOTNOTES
.                   ie \\n[#FN_RULE]=0 .RLD 1v
.                   el \{\
\v'-\\n[#FN_RULE_ADJ]u-\\n[#FN_RULE_WEIGHT_ADJ]u'\
\D't \\n[#FN_RULE_WEIGHT]'\
\h'-\\n[#FN_RULE_WEIGHT]u'\
\D'l \\n[#FN_RULE_LENGTH]u 0'\
\v'+\\n[#FN_RULE_ADJ]u+\\n[#FN_RULE_WEIGHT_ADJ]u'
.                   \}
.                   br
.                   if \\n[#RUNON_FOOTNOTES] \{\
.                      RUNON_FOOTNOTES
.                      rr #RUNON_FOOTNOTES
.                   \}
.                   if \\n[#RUNON_FN_IN_DIVER] \{\
.                      RUNON_FN_IN_DIVER
.                      rr #RUNON_FN_IN_DIVER
.                   \}
.                   br
.                   di
.                   ev
.                   nr #FN_DEPTH \\n[#DIVER_DEPTH]
.                   nr #SAVED_VFP 0+\\n[#VARIABLE_FOOTER_POS]
.                   nr #VARIABLE_FOOTER_POS 0-\\n[#B_MARGIN]u
.                \}
.\" Save the new depth
.                nr #SAVED_FN_DEPTH_2 \\n[#FN_DEPTH]
.\" Signal that defer space should be added when PROCESS_FN_LEFTOVER
.\" processes deferred footnotes.
.                if \\n[#FN_DEFER] \{\
.                   if \\n[#FN_COUNT]=2 \{\
.                      ie \\n[#COLUMNS] \{\
.                         if !\\n[#FROM_FOOTER] \{\
.                            if \\n[#FN_DEFER]=1 .nr #FN_DEFER_SPACE 1
.                            if \\n[#FN_COUNT_FOR_COLS]>=1 .rr #FN_DEFER_SPACE
.                            if \\n[#FROM_HEADER] .nr #FN_DEFER_SPACE 1
.                         \}
.                      \}
.                      el .nr #FN_DEFER_SPACE 1
.                   \}
.                   rr #FN_DEFER
.                \}
.\" If the depth of the whole footnote won't fit in the space
.\" between where we are on the page and the bottom margin, calculate
.\" how much of it will fit.
.                if \\n[#FN_DEPTH]>\\n[#SPACE_REMAINING] \{\
.                   nr #FN_LINES 0 1
.                   while (\\n+[#FN_LINES]*\\n[#FN_LEAD])<\\n[#SPACE_REMAINING] \{\
.                      nr #FN_DEPTH (\\n[#FN_LINES]*\\n[#FN_LEAD])
.                   \}
.                   nr #VFP_DIFF \\n[#FN_DEPTH]-\\n[#SAVED_FN_DEPTH_1]
.                   nr #OVERFLOW 1
.\" Very occasionally, #VFP_DIFF, on a 1st footnote that isn't to
.\" be deferred, comes up with a depth equal to exactly 1 line
.\" of footnotes, i.e. enough room to print the rule and nothing
.\" else.  The following tests for such a condition, and rather than
.\" attempting to treat the footnote as an overflow, it tells mom to
.\" treat it as a special kind of deferred footnote (#FN_DEFER 2).
.                   if \\n[#SAVED_FN_DEPTH_1]=0 \{\
.                      if \\n[#FN_DEPTH]=\\n[#FN_LEAD] \{\
.                         nr #FN_DEFER 2
.                         nr #FN_DEPTH \\n[#SAVED_FN_DEPTH_2]
.                         rr #OVERFLOW
.                      \}
.                   \}
.                \}
.\" Calculate VFP based on whether the footnote overflows, or is to
.\" be treated normally.
.                ie \\n[#OVERFLOW]=1 \{\
.                   if \\n[#RUN_ON] \{\
.                      rr #VARIABLE_FOOTER_POS
.                      nr #VARIABLE_FOOTER_POS \\n[#SAVED_VFP]
.                   \}
.                   ie \\n[#FN_COUNT]=1 \{\
.                      ie \\n[#RULED]=1 \{\
.                         ie \\n[#COLUMNS]=1 \{\
.                            ie \\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.                               ie \\n[#FROM_FOOTER] \{\
.                                  ie \\n[#FN_COUNT_FOR_COLS]>1 \{\
.                                     nr #FN_DEPTH -\\n[#FN_DEPTH]
.                                     if \\n[#DIVERTED]=1 .nr #DIVERTED 3
.                                     if !\\n[#PREV_FN_DEFERRED]=1 \
.                                        nr #FN_DEPTH -\\n[#VFP_DIFF]
.                                  \}
.                                  el \{\
.                                     nr #VARIABLE_FOOTER_POS -\\n[#FN_DEPTH]
.                                     if \\n[#DIVERTED]=1 .nr #DIVERTED 3
.                                  \}
.                               \}
.                               el .nr #VARIABLE_FOOTER_POS -(\\n[#FN_DEPTH])
.                            \}
.                            el .nr #VARIABLE_FOOTER_POS -(\\n[#FN_DEPTH])
.                         \}
.                         el .nr #VARIABLE_FOOTER_POS -(\\n[#FN_DEPTH])
.                      \}
.                      el \{\
.                         nr #VARIABLE_FOOTER_POS -\\n[#VFP_DIFF]
.                         if \\n[#DIVERTED]=1 .nr #DIVERTED 3
.                         if !\\n[#PREV_FN_DEFERRED]=1 \{\
.                            ie \\n[#COLUMNS]=1 \
.                               if !\\n[#FROM_FOOTER] .
.                            el .nr #FN_DEPTH -\\n[#VFP_DIFF]
.                         \}
.                         if \\n[#DIVERTED]=3 \{\
.                            if !\\n[#PREV_FN_DEFERRED] \{\
.                               if !\\n[#FROM_FOOTER] \{\
.                                  if \\n[#FN_COUNT]=1 \{\
.                                     if !\\n[#VFP_DIFF] \{\
.                                        if \\n[#FN_MARKER_STYLE]=1 \{\
.                                           da FOOTNOTES
\!.                                            ALD \\n[#FN_LEAD]u
.                                           di
.                                        \}
.                                        if \\n[#RESET_FN_NUMBER] \{\
.                                           da FOOTNOTES
\!.                                            ALD \\n[#FN_LEAD]u
.                                           di
.                                        \}
.                                     \}
.                                  \}
.                               \}
.                            \}
.                         \}
.                      \}
.                      nr #FN_DEPTH \\n[#SAVED_FN_DEPTH_1]+\\n[#VFP_DIFF]
.                   \}
.                   el \{\
.                      nr #VARIABLE_FOOTER_POS -\\n[#VFP_DIFF]
.                      nr #FN_DEPTH \\n[#SAVED_FN_DEPTH_1]+\\n[#VFP_DIFF]
.                   \}
.                   rr #OVERFLOW
.                   rr #RULED
.                \}
.                el \{\
.                   nr #VARIABLE_FOOTER_POS -\\n[#DIVER_DEPTH]
.                   if \\n[#PREV_FN_DEFERRED]=1 \{\
.                      if \\n[#DIVERTED] \{\
.                         if !\\n[#FN_DEPTH]=\\n[#SAVED_FN_DEPTH_1] \{\
.                            nr #FN_DEPTH +\\n[#FN_LEAD]
.                            nr #VARIABLE_FOOTER_POS -\\n[#FN_LEAD]
.                            rr #PREV_FN_DEFERRED
.                         \}
.                      \}
.                   \}
.                   if \\n[#FN_COUNT]>1 \{\
.                      nr #NO_BACK_UP 1
.                      rr #DIVERTED
.                      rr #RULED
.                   \}
.                \}
.             \}
.          \}
.          ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.\" If we have a footnote whose text has to be deferred to the next
.\" page, reset the FOOTER trap to its original location.
.          if \\n[#FN_DEFER] \{\
.             nr #VARIABLE_FOOTER_POS 0-\\n[#B_MARGIN]u
.             ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.          \}
.       \}
.       nr #NO_FN_MARKER 0
.    \}
.    if \\n[#NUM_ARGS]=2 \{\
.       if '\\$2'BREAK' .BR
.       if '\\$2'BR' .BR
.    \}
.END
\#
\# Utility macros to manage footnotes that occur inside diversions
\# ---------------------------------------------------------------
\#
\# There are some redundancies here; they're left in in case unforeseen
\# footnote situations crop up in the future that might require
\# manipulation of them.
\#
\# 1. Pre-footnote processing for footnotes in diversions
\#
\# a) A footnote inside a diversion will be moved entirely (marker
\# in running text and text of footnote) to the next page/column.
\#
.MAC DIVER_FN_1_PRE END
.    nr #RESET_FN_COUNTERS 1
.    nr #COUNTERS_RESET 1
.    if \\n[#DONE_ONCE]=1 \{\
.       if \\n[#FN_DEFER] \{\
.          if \\n[#SAVED_DIVER_FN_COUNT]=1 \{\
.             ie \\n[#COLUMNS]=1 \
.                if \\n[#COL_NUM]=\\n[#NUM_COLS] .nr #FN_DEFER_SPACE 1
.             el .nr #FN_DEFER_SPACE 1
.          \}
.       \}
.       if \\n[#FN_MARKER_STYLE]=1 \{\
.          if \\n[#FN_COUNT]>0 .nr #FN_COUNT 0 1
.          if \\n[#COLUMNS]=1 \
.             if \\n[#COL_NUM]=\\n[#NUM_COLS] .nr #FN_COUNT_FOR_COLS 0 1
.       \}
.       if \\n[#FN_MARKER_STYLE]=2 \{\
.          if \\n[#RESET_FN_NUMBER]=1 \{\
.             ie \\n[#COLUMNS]=1 \
.                if \\n[#COL_NUM]=\\n[#NUM_COLS] .nr #FN_NUMBER 0 1
.             el .nr #FN_NUMBER 0 1
.          \}
.       \}
.    \}
.END
\#
\# b) Treat as a normal footnote, including defers.
\#
.MAC DIVER_FN_2_PRE END
.    nr #RESET_FN_COUNTERS 2
.END
\#
\# 2. Post-footnote processing for footnotes in diversions
\#
\# Even when a footnote inside a diversion is treated as
\# "normal," some manipulation of registers is required.  The
\# macro is called in DO_QUOTE (i.e. at the termination of
\# quotes and blockquotes) and in DO_EPIGRAPH.
\#
.MAC DIVER_FN_2_POST END
.    if \\n[#DONE_ONCE]=1 \{\
.       if \\n[#FN_MARKER_STYLE]=1 \{\
.          if \\n[#FN_COUNT]=0 .nr #DONT_RULE_ME 1
.          if \\n[#FN_COUNT]>0 .nr #FN_COUNT 0 1
.          if \\n[#COLUMNS]=1 \{\
.             if \\n[#COL_NUM]=\\n[#NUM_COLS] .nr #FN_COUNT_FOR_COLS 0 1
.             if !\\n[#COL_NUM]=\\n[#NUM_COLS] .
.          \}
.       \}
.       if \\n[#FN_MARKER_STYLE]=2 \{\
.          if \\n[#FN_COUNT]=0 .nr #DONT_RULE_ME 1
.          if \\n[#FN_COUNT]>0 .nr #FN_COUNT 0 1
.          if \\n[#RESET_FN_NUMBER]=1 \{\
.             ie \\n[#COLUMNS]=1 \
.                if \\n[#COL_NUM]=\\n[#NUM_COLS] .nr #FN_NUMBER 0 1
.             el .nr #FN_NUMBER 0 1
.          \}
.       \}
.    \}
.END
\#
\# The main macros that handle footnote processing.
\# -----------------------------------------------
\#
\# FN_OVERFLOW_TRAP starts off "underneath" FOOTER, but is revealed
\# as #VARIABLE_FOOTER_POSITION changes the position of FOOTER.
\# FN_OVERFLOW_TRAP simply starts diversion FN_OVERFLOW to "catch"
\# the overflow.  The diversion is ended in FOOTER, immediately after
\# FOOTER outputs the diversion, FOOTNOTES, before PROCESS_FN_LEFTOVER
\# is run (either in HEADER, or in FOOTER if moving col to col).
\#
.MAC FN_OVERFLOW_TRAP END
.    if \\n[#FN_COUNT] \{\
.       di FN_OVERFLOW
.       ie !\\n[#NO_BACK_UP]=1 \{\
.          if \\n[#PREV_FN_DEFERRED] \{\
.             ie \\n[#COLUMNS]=1 \{\
.                if \\n[#FROM_FOOTER] \{\
.                   if \\n[#PREV_FN_DEFERRED] \{\
.                      if !\\n[#COL_NUM]=\\n[#NUM_COLS] \
.                      rr #PREV_FN_DEFERRED
.                   \}
.                \}
.                if !\\n[#FROM_FOOTER] \{\
.                   if !\\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.                      if !\\n[#LAST_FN_COUNT_FOR_COLS]>1 \{\
\!.                       RLD \\n[#FN_LEAD]u
.                      \}
.                   \}
.                \}
.             \}
.             el \{\
\!.              RLD \\n[#FN_LEAD]u
.             \}
.          \}
.       \}
.       el \{\
.          rr #NO_BACK_UP
.          rr #PREV_FN_DEFERRED
.       \}
.    \}
.\" When #FROM_DIVERT_FN is 1, it signals to FOOTNOTE, when run from
.\" within DIVERT_FN_LEFTOVER, to set #SPACE_REMAINING to the total
.\" area allowable for running text.
.    nr #FROM_DIVERT_FN 1
.END
\#
\# PROCESS_FN_LEFTOVER is called at the top of HEADER, and in
\# FOOTER if we're moving from one column to the next (i.e. after
\# outputting FOOTNOTES).  It checks for whether we have a "deferred
\# footnote" situation, and resets counters and number registers
\# accordingly.  Lastly, if we have some footnote overflow, it calls
\# DIVERT_FN_OVERFLOW.
\#
.MAC PROCESS_FN_LEFTOVER END
.    if \\n[#PREV_FN_DEFERRED]=2 \
.       if \\n[#FN_COUNT_AT_FOOTER]>1 .rr #PREV_FN_DEFERRED
.    ie !\\n[#FN_DEFER] \{\
.       nr #FN_COUNT 0 1
.       nr #FN_DEPTH 0
.       nr #VARIABLE_FOOTER_POS 0-\\n[#B_MARGIN]
.    \}
.    el \{\
.       if \\n[#FN_DEFER]=1 .nr #VARIABLE_FOOTER_POS 0-\\n[#B_MARGIN]
.       if \\n[#FN_DEFER]=2 \{\
.          nr #FN_DEPTH 0
.          nr #VARIABLE_FOOTER_POS 0-\\n[#B_MARGIN]
.       \}
.    \}
.    nr #SPACE_REMAINING 0
.    ch FOOTER -\\n[#B_MARGIN]u
.    if \\n[#FN_DEFER] \{\
.       nr #NO_FN_MARKER 1
.       rn FOOTNOTES DEFERRED-FOOTNOTE
.       nr #FN_DEPTH 0
.       FOOTNOTE
.       nf
.       DEFERRED-FOOTNOTE
.       FOOTNOTE OFF
.       ie \\n[#COLUMNS]=1 \{\
.          if \\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.             if !\\n[#FROM_FOOTER] \
.                if \\n[#FN_COUNT_FOR_COLS]=1 .nr #PREV_FN_DEFERRED 1
.          \}
.       \}
.       el .nr #PREV_FN_DEFERRED 1
.    \}
.    if !\\n[#FN_DEFER] \
.       if \\n[#FN_OVERFLOW_DEPTH] .DIVERT_FN_LEFTOVER
.    ie \\n[#COLUMNS]=1 \{\
.       if \\n[#COL_NUM]>1 \
.          if \\n[#COL_NUM]=\\n[#NUM_COLS] .nr #FN_COUNT 0 1
.    \}
.    el .nr #FN_COUNT 0 1
.    if \\n[#DIVER_FN]=2 .rr #DIVER_FN
.    rr #FROM_DIVERT_FN
.END
\#
\# DIVERT_FN_LEFTOVER is called in PROCESS_FN_LEFTOVER (at
\# the top of HEADER, and in FOOTER if we're moving from one column
\# to the next).
\#
.MAC DIVERT_FN_LEFTOVER END
.    nr #NO_FN_MARKER 1
.    nr #DIVERTED 1
.    FOOTNOTE
.    nf
.    FN_OVERFLOW
.    FOOTNOTE OFF
.    if \\n[#PREV_FN_DEFERRED] \{\
.       nr #FN_DEPTH -\\n[#FN_LEAD]
.       nr #VARIABLE_FOOTER_POS +\\n[#FN_LEAD]
.       ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.       if \\n[#PREV_FN_DEFERRED]=2 \{\
.          nr #PREV_FN_DEFERRED 1
.          rr #DIVERTED
.       \}
.    \}
.    rr #FN_OVERFLOW_DEPTH
.END
\#
\# This is a special macro to deal with footnotes that are set inside
\# diversions (QUOTE, BLOCKQUOTE and EPIGRAPH).  It's called in HEADER
\# (and in FOOTER, if we're moving from column to column), and comes
\# after PROCESS_FOOTNOTE_LEFTOVER in those two macros.
\#
.MAC PROCESS_FN_IN_DIVER END
.    nr #SPACE_REMAINING 0
.    ch FOOTER -\\n[#B_MARGIN]u
.    nr #NO_FN_MARKER 1
.    if !\\n[#RESET_FN_COUNTERS]=2 .rr #RESET_FN_COUNTERS
.    FOOTNOTE
.    if \\n[#FN_OVERFLOW_DEPTH] .nf
.    ie dRUNON_FN_IN_DIVER \{\
.       RUNON_FN_IN_DIVER
.       rm RUNON_FN_IN_DIVER
.    \}
.    el \{\
.       nf
.       FN_IN_DIVER
.    \}
.    FOOTNOTE OFF
.    rr #DIVER_FN
.END
\#
\# ====================================================================
\#
\# +++ENDNOTES+++
\#
\# When endnotes are output, the spacing between the notes is always
\# 1 extra linespace.  This can have bottom margin consequences.  If
\# this doesn't bother you, don't worry about it.  If it does bother
\# you, and you want to adjust the spacing between any two endnotes (as
\# they're output), make the spacing adjustments (.ALD/.RLD) at the
\# *end* of endnotes (i.e. just before .ENDNOTE OFF), not at the top.
\#
\# Endnotes must be output manually with .ENDNOTES. This allows user
\# the flexibility to output endnotes at the end of each collated
\# document, or to output them at the end of the entire document.
\#
\# Control macros
\# --------------
\#
\# ENDNOTE POINT SIZE
\# ------------------
\# *Argument:
\#   <base point size for endnotes>
\# *Function:
\#   Creates or modifies register #EN_PS.
\# *Notes:
\#   Default is same as running text in body of document.
\#
\#   This size control macro differs from other size control macros
\#   in that it sets an absolute point size, not a relative one.  This
\#   is because a) endnotes always appear separate from the body of
\#   a document and therefore don't need to be relative to the body
\#   of the document, and b) there are quite a few elements of the
\#   endnotes page(s) that need to be relative to the base point size
\#   of that page.  If the base endnote point size were relative to
\#   the body of the document (i.e. a _SIZE macro taking a +|- value)
\#   getting the rest of the endnote elements sized properly could
\#   become very confusing.
\#
.MAC ENDNOTE_PT_SIZE END
.    nr #EN_PS (p;\\$1)
.END
\#
\# ENDNOTE SPACING
\# ----------------
\# *Arguments:
\#   <per item endnote spacing> | <anything>
\# *Function:
\#   Enables space between endnotes items.
\# *Notes:
\#   Default is no space.
\#
.MAC ENDNOTE_SPACING END
.    ie \B'\\$1' .ds $EN_SPACE \\$1
.    el .rm $EN_SPACE
.END
\#
\# ENDNOTES_HDRFTR_CENTER
\# ----------------------
\# *Argument:
\#   toggle
\# *Function:
\#   Creates or removes toggle register #EN_HDRFTR_CENTER, used to
\#   determine whether mom should print a/the hdrftr center string
\#   on the endnotes page.  Primarily to enable/disable printing of the
\#   chapter name in hdrftrs when DOCTYPE CHAPTER.
\# *Notes:
\#   Default is OFF
\#
.MAC ENDNOTES_HDRFTR_CENTER END
.    ie '\\$1'' .nr #EN_HDRFTR_CENTER 1
.    el .rr #EN_HDRFTR_CENTER
.END
\#
\# ENDNOTE STRING
\# --------------
\# *Argument:
\#   <title for endnotes page>
\# *Function:
\#   Creates or modifies string $EN_STRING.
\# *Notes:
\#   Default is "Endnotes"
\#
.MAC ENDNOTES_HEADER_STRING END
.    ds $EN_STRING \\$1
.END
.
.ALIAS ENDNOTE_STRING ENDNOTES_HEADER_STRING
\#
\# ENDNOTE STRING START POSITION
\# ----------------------------
\# *Argument:
\#   <distance from page top>
\# *Function:
\#   Creates or modifies register #EN_STRING_V_POS
\#
.MAC ENDNOTES_HEADER_V_POS END
.    nr #EN_STRING_V_POS (\\$1)
.END
.
.ALIAS ENDNOTE_STRING_ADVANCE  ENDNOTES_HEADER_V_POS
.ALIAS ENDNOTE_STRING_V_POS    ENDNOTES_HEADER_V_POS
.ALIAS ENDNOTES_HEADER_V_POS   ENDNOTES_HEADER_V_POS
\#
\# ENDNOTE HEADER CAPS and SMALLCAPS
\# ---------------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns capitalization or smallcaps style of the endnotes pages
\#   title string "Endnotes" on or off.
\# *Notes:
\#   Users may want the endnotes pages title string to be in
\#   caps, but the toc entry for endnotes in lower case.  If the
\#   argument to ENDNOTES_HEADER_STRING is in lower case and
\#   ENDNOTES_HEADER_CAPS is turned on, this is exactly what will
\#   happen.  Ditto for smallcaps.
\#
\#   Default for CAPS is on.
\#
.MAC ENDNOTES_HEADER_CAPS END
.   ie '\\$1'' .nr #EN_STRING_CAPS 1
.   el .nr #EN_STRING_CAPS 0
.END
.
.ALIAS ENDNOTE_STRING_CAPS ENDNOTES_HEADER_CAPS
.
.MAC ENDNOTES_HEADER_SMALLCAPS END
.   ie '\\$1'' .nr #EN_STRING_SMALLCAPS 1
.   el .nr #EN_STRING_SMALLCAPS 0
.END
.
.ALIAS ENDNOTE_STRING_SMALLCAPS ENDNOTES_HEADER_SMALLCAPS
\#
\# ENDNOTE TITLE
\# -------------
\# *Argument:
\#   <string that appears before the first endnote pertaining to any document>
\# *Function:
\#   Creates string $EN_TITLE.
\# *Notes:
\#   Default is the document title, or, if doc is a chapter, "Chapter #"
\#
.MAC ENDNOTE_TITLE END
.    ds $EN_TITLE \\$1
.END
\#
\# ENDNOTE MARKER STYLE
\# --------------------
\# *Arguments:
\#   NUMBER | LINE | SUPERSCRIPT
\# *Function:
\#   Sets register #EN_MARKER_STYLE, used in ENDNOTE to determine
\#   the style of endnote markers (labels).
\# *Notes:
\#   1=NUMBER; 2=LINE.  LINE means "use output line numbers".
\#   Default is NUMBER.
\#
.MAC ENDNOTE_MARKER_STYLE END
.    if '\\$1'NUMBER' .nr #EN_MARKER_STYLE 1
.    if '\\$1'LINE' \{\
.       nr #EN_MARKER_STYLE 2
.       if !\\n[#EN_LN_SEP] \
.          if !\\n[#EN_LN_BRACKETS] .ENDNOTE_LINENUMBER_BRACKETS SQUARE
.    \}
.    if '\\$1'SUPERSCRIPT' .nr #EN_MARKER_STYLE 3
.END
\#
\# ENDNOTE LINENUMBER MARK
\# -----------------------
\# *Function:
\#   This string, when called inline, stores the current output line
\#   number in register #EN_MARK for use with ENDNOTE.
\#
.ds EN_MARK \R'#EN_MARK \En[ln]'
\#
\# ENDNOTE LINENUMBER SEPARATOR
\# ----------------------------
\# *Argument:
\#   <user-defined separator>
\# *Function:
\#   Stores user-defined separator (for use then
\#   ENDNOTE_MARKER_STYLE is LINE) in string $EN_LN_SEP.  The
\#   separator is intended to be used when the user wishes a
\#   separator, rather than the choice of brackets offered by
\#   ENDNOTE_LINENUMBER_BRACKETS.
\#
.MAC ENDNOTE_LINENUMBER_SEPARATOR END
.    rr #EN_LN_BRACKETS
.    nr #EN_LN_SEP 1
.    ds $EN_LN_SEP "\\$1
.END
\#
\# ENDNOTE LINENUMBER BRACKETS
\# ---------------------------
\# *Argument:
\#   PARENS | SQUARE | BRACES or ( | [ | {
\# *Function:
\#   Sets register #EN_LN_BRACKETS to 1, and creates strings
\#   $EN_OPEN_BRACKET and $EN_CLOSE_BRACKET according to the given argument.
\#
.MAC ENDNOTE_LINENUMBER_BRACKETS END
.    rr #EN_LN_SEP
.    nr #EN_LN_BRACKETS 1
.    if '\\$1'PARENS' \{\
.       ds $EN_OPEN_BRACKET (
.       ds $EN_CLOSE_BRACKET )
.    \}
.    if '\\$1'(' \{\
.       ds $EN_OPEN_BRACKET (
.       ds $EN_CLOSE_BRACKET )
.    \}
.    if '\\$1'SQUARE' \{\
.       ds $EN_OPEN_BRACKET [
.       ds $EN_CLOSE_BRACKET ]
.    \}
.    if '\\$1'[' \{\
.       ds $EN_OPEN_BRACKET [
.       ds $EN_CLOSE_BRACKET ]
.    \}
.    if '\\$1'BRACES' \{\
.       ds $EN_OPEN_BRACKET {
.       ds $EN_CLOSE_BRACKET }
.    \}
.    if '\\$1'{' \{\
.       ds $EN_OPEN_BRACKET {
.       ds $EN_CLOSE_BRACKET }
.    \}
.END
\#
\# ENDNOTE LINENUMBER GAP
\# ----------------------
\# *Argument:
\#   <space between line-number labels and endnotes text>
\# *Function:
\#   Defines string $EN_LN_GAP, used during printing of line-number
\#   labels in ENDNOTE.
\#
.MAC ENDNOTE_LINENUMBER_GAP END
.    nr #EN_LN_GAP (u;\\$1)
.END
\#
\# ENDNOTE NUMBERS ALIGNMENT
\# -------------------------
\# *Argument:
\#   LEFT | RIGHT <max. number of digit placeholders that will appear in endnotes>
\# *Function:
\#   Creates registers for _LEFT or _RIGHT; creates register
\#   #EN_NUMBER_PLACEHOLDERS.
\# *Notes:
\#   Default is for endnote numbers to be right aligned to 2 placeholders.
\#
.MAC ENDNOTE_NUMBERS_ALIGN END
.    if '\\$1'LEFT' \{\
.       rr #EN_NUMBERS_ALIGN_RIGHT
.       nr #EN_NUMBERS_ALIGN_LEFT 1
.    \}
.    if '\\$1'RIGHT' \{\
.       rr #EN_NUMBERS_ALIGN_LEFT
.       nr #EN_NUMBERS_ALIGN_RIGHT 1
.    \}
.    nr #EN_NUMBER_PLACEHOLDERS \\$2
.END
\#
\# ENDNOTE PARAGRAPH INDENT
\# ------------------------
\# *Argument:
\#   <first line indent of paras subsequent to 1st in endnotes>
\# *Function:
\#   Creates register #EN_PP_INDENT for use in .PP.
\# *Notes:
\#   Requires a unit of measure.
\#
\#   Default is 1.5m for TYPESET; same indent as PARA_INDENT for TYPEWRITE.
\#
.MAC ENDNOTE_PARA_INDENT END
.    nr #EN_PP_INDENT (\\$1)
.END
\#
\# TURN OFF COLUMN MODE FOR ENDNOTES
\# ---------------------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes register #EN_NO_COLS
\# *Notes:
\#   Allows user to tell mom not to set endnotes in columnar
\#   documents in columns.  Default is to set endnotes in columns.
\#
.MAC ENDNOTES_NO_COLUMNS END
.    ie '\\$1'' .nr #EN_NO_COLS 1
.    el .rr #EN_NO_COLS
.END
\#
\# NO FIRST PAGE NUMBER ON ENDNOTES FIRST PAGE
\# -------------------------------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes register #EN_NO_FIRST_PN
\# *Notes:
\#   For use if FOOTERS are on.  Tells ENDNOTES not to put a page
\#   number on the first endnotes page.  Some users may want this.
\#   Default is to print a page number at the top of the first
\#   endnotes page when footers are on.
\#
.MAC ENDNOTES_NO_FIRST_PAGENUM END
.    ie '\\$1'' .nr #EN_NO_FIRST_PN 1
.    el .rr #EN_NO_FIRST_PN
.END
\#
\# PAGE HEADERS ON ENDNOTES PAGES
\# ------------------------------
\# *Argument:
\#   <none> | ALL
\# *Function:
\#   Creates or removes register #EN_ALLOWS_HEADERS or
\#   #EN_ALLOWS_HEADERS_ALL
\# *Notes:
\#   Whether ENDNOTES puts a page header at the top of endnotes
\#   pages if page headers are used throughout the document.
\#   Default is to insert the page headers, but not on the first
\#   page.  If the optional argument ALL is given, ENDNOTES puts a
\#   page header on the first page as well.
\#
.MAC ENDNOTES_ALLOWS_HEADERS END
.    ie '\\$1'' .nr #EN_ALLOWS_HEADERS 1
.    el \{\
.       ie '\\$1'ALL' \{\
.          nr #EN_ALLOWS_HEADERS 1
.          nr #EN_ALLOWS_HEADERS_ALL 1
.       \}
.       el \{\
.          nr #EN_ALLOWS_HEADERS 0
.          nr #EN_ALLOWS_HEADERS_ALL 0
.       \}
.    \}
.END
\#
\# ENDNOTES PAGES PAGE NUMBERING STYLE
\# -----------------------------------
\# *Argument:
\#   DIGIT | ROMAN | roman | ALPHA | alpha
\# *Function:
\#   Creates or modifies $EN_PN_STYLE.
\# *Notes:
\#   Allows user to define what style should be used for endnotes
\#   pages page numbering.  Arguments are the same as for
\#   PAGENUM_STYLE.
\#
\#   Default is DIGIT.
\#
.MAC ENDNOTES_PAGENUM_STYLE END
.    ds $EN_PN_STYLE \\$1
.END
\#
\# FIRST PAGE NUMBER FOR ENDNOTES
\# ------------------------------
\# *Argument:
\#   <page number that appears on page 1 of endnotes pages>
\# *Function:
\#   Creates or modifies string $EN_FIRST_PN
\# *Notes:
\#   To be used with caution, only if all endnotes
\#   are to be output at once, i.e. not at the end of the separate
\#   docs of a collated doc
\#
.MAC ENDNOTES_FIRST_PAGENUMBER END
.    nr #EN_FIRST_PN \\$1
.END
\#
\# SINGLESPACE ENDNOTES
\# --------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Sets lead of endnotes pages in TYPEWRITE to 12 points,
\#   adjusted.
\# *Notes:
\#   Default is to double-space endnotes pages.
\#
.MAC SINGLESPACE_ENDNOTES END
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie \\n[#SINGLE_SPACE] \{\
.          nr #EN_SINGLESPACE 1
.          rr #IGNORE
.          if \\n[#OK_PROCESS_LEAD] \{\
.             ENDNOTE_LEAD 12 ADJUST
.             nr #IGNORE 1
.          \}
.       \}
.       el \{\
.          ie '\\$1'' \{\
.             nr #EN_SINGLESPACE 1
.             rr #IGNORE
.             if \\n[#OK_PROCESS_LEAD] \{\
.                ENDNOTE_LEAD 12 ADJUST
.                nr #IGNORE 1
.             \}
.          \}
.          el \{\
.             rr #EN_SINGLESPACE
.             rr #IGNORE
.             if \\n[#OK_PROCESS_LEAD] \{\
.                ENDNOTE_LEAD 24 ADJUST
.                nr #IGNORE 1
.             \}
.          \}
.       \}
.    \}
.END
\#
\# ENDNOTE PARAGRAPH SPACE
\# -----------------------
\# *Argument:
\#   toggle
\# *Function:
\#   Creates toggle register #EN_PP_SPACE for use in .PP.
\# *Notes:
\#   Like PARA_SPACE.  Default is not to space endnote paras.
\#
.MAC ENDNOTE_PARA_SPACE END
.    ie '\\$1'' .nr #EN_PP_SPACE 1
.    el .rr #EN_PP_SPACE
.END
\#
\# ENDNOTE
\# -------
\# *Argument:
\#   toggle
\# *Function:
\#   Places superscript endnote number in text, then collects and
\#   processes endnote in diversion END_NOTES.
\# *Notes:
\#   \c must be appended to the word immediately preceding .ENDNOTE
\#   when ENDNOTE_MARKER_STYLE is NUMBER.
\#
.MAC ENDNOTE END
.    ie '\\$1'' \{\
.       nr #ENDNOTE 1
.       ie !\\n[#EN_MARKER_STYLE]=2 \{\
.          if \\n[#CONDENSE] .nop \*[CONDX]\c
.          if \\n[#EXTEND] .nop \*[EXTX]\c
.             if \\n[#UNDERLINE_ON] \{\
.                nr #UNDERLINE_WAS_ON 1
.                UNDERLINE OFF
.             \}
.          if \\n[#PRINT_STYLE]=1 \{\
.             if \\n[#SLANT_ON] \{\
.                 nr #SLANT_WAS_ON 1
.                 nop \*[SLANTX]\c
.             \}
.\" Vertical raise amount here is more than when the same string is printed in
.\" the endnotes so bottom of number aligns with top of bowl.
.             PRINT \
"\s-2\v'-\\n[#DOC_LEAD]u/5u'\\n+[#EN_NUMBER]\v'+\\n[#DOC_LEAD]u/5u'\s+2\c"
.          \}
.          if \\n[#PRINT_STYLE]=2 .PRINT \*[SUP]\\n+[#EN_NUMBER]\*[SUPX]\c
.       \}
.       el \{\
.          ie r#EN_NUMBER .nr #EN_NUMBER \\n[#EN_NUMBER]+1
.          el .nr #EN_NUMBER 1 1
.          if !\\n[#LINENUMBERS] \{\
.             tm1 "[mom]: Line numbering must be enabled with NUMBER_LINES when
.             tm1 "       ENDNOTE_MARKER_STYLE is LINE.
.             ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.          \}
.          if \\n[#EN_MARK]=0 .nr #EN_MARK \\n[ln]
.          nr #EN_MARK_2 \\n[ln]
.          if '\\n[.z]'P_QUOTE' \{\
.             nr #EN_MARK -1
.             nr #EN_MARK_2 -1
.          \}
.       \}
.       nr #PP_STYLE_PREV \\n[#PP_STYLE]
.       nr #PP_STYLE 1
.       if \\n[#INDENT_FIRST_PARAS] .nr #INDENT_FIRSTS 1
.       INDENT_FIRST_PARAS
.       ev EN
.       da END_NOTES
.       LL \\n[#DOC_L_LENGTH]u
.       ta \\n[.l]u
.       if \\n[#COLUMNS] \{\
.          ie \\n[#EN_NO_COLS] .LL \\n[#DOC_L_LENGTH]u
.          el .LL \\n[#COL_L_LENGTH]u
.          ta \\n[.l]u
.       \}
\!.     if \\\\n[.vpt]=0 .vpt
\!.     ne 3
.       vs \\n[#EN_LEAD]u
.\" Print identifying doc title (e.g., Chapter n)
.       if \\n[#EN_NUMBER]=1 \{\
.          if \\n[#PRINT_STYLE]=1 .TYPEWRITER
.          if \\n[#PRINT_STYLE]=2 \{\
.             FAMILY  \\*[$EN_TITLE_FAM]
.             FT      \\*[$EN_TITLE_FT]
.             ps \\n[#EN_PS]u\\*[$EN_TITLE_SIZE_CHANGE]
.             if \\n[#EN_TITLE_COLOR] .COLOR \\*[$EN_TITLE_COLOR]
.             if \\n[#ENDNOTE_TITLE_SMALLCAPS] .SMALLCAPS
.             if \\n[#ENDNOTE_TITLE_CAPS] .CAPS
.          \}
.          ie \\n[#SINGLE_SPACE]=1 .sp 2
.          el .sp
.          if !'\\*[$EN_TITLE]'' \{\
.             substring $EN_TITLE_QUAD 0 0
.             if '\\*[$EN_TITLE_QUAD]'L' .LEFT
.             if '\\*[$EN_TITLE_QUAD]'C' .CENTER
.             if '\\*[$EN_TITLE_QUAD]'R' .RIGHT
\!.           vpt 0
.             sp -.25v
.             ie \\n[#EN_TITLE_UNDERLINE] \
.                UNDERSCORE "\\*[$EN_TITLE]"
.             el \{\
.                ie \\n[#PRINT_STYLE]=1 \
.                   UNDERSCORE "\\*[$EN_TITLE]"
.                el .PRINT "\\*[$EN_TITLE]"
.             \}
.             sp .25v
\!.           vpt
.          \}
.          if \\n[#EN_TITLE_COLOR] .gcolor
.          if \\n[#ENDNOTE_TITLE_SMALLCAPS] .SMALLCAPS OFF
.          if \\n[#ENDNOTE_TITLE_CAPS] .CAPS OFF
.       \}
.\" Get indent from endnotes point size; convert string to reg in
.\" case indent string is, e.g., m or n
.       ps \\n[#EN_PS]u
.       nr #REF_EN_INDENT (u;\\*[$REF_EN_INDENT])
.       if \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          if \\n[#EN_NUMBER]=1 \{\
.             ie \\n[#SINGLE_SPACE]=1 .sp
.             el .sp .25
.           \}
.          if \\n[#EN_MARKER_STYLE]=3 .ps -2
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          if \\n[#EN_MARKER_STYLE]=1 \{\
.             FAMILY  \\*[$EN_NUMBER_FAM]
.             FT      \\*[$EN_NUMBER_FT]
.             ps \\n[#EN_PS]u\\*[$EN_NUMBER_SIZE_CHANGE]
.          \}
.          if \\n[#EN_MARKER_STYLE]=2 \{\
.             FAMILY  \\*[$EN_LN_FAM]
.             FT      \\*[$EN_LN_FT]
.             ps \\n[#EN_PS]u\\*[$EN_LN_SIZE_CHANGE]
.          \}
.          if \\n[#EN_MARKER_STYLE]=3 \{\
.             FAMILY  \\*[$EN_NUMBER_FAM]
.             FT      \\*[$EN_NUMBER_FT]
.             ps \\n[#PT_SIZE_IN_UNITS]u*6u/10u
.          \}
.       \}
.\" Build string for line-numbered endnotes
.       if \\n[#EN_MARKER_STYLE]=2 \{\
.          ie \\n[#EN_LN_BRACKETS]=1 \{\
.             ds $EN_LINENUMBER \v'-.085m'\\*[$EN_OPEN_BRACKET]\v'.085m'
.             ie \\n[#EN_MARK_2]=\\n[#EN_MARK] .as $EN_LINENUMBER \
\\n[#EN_MARK]\v'-.085m'\\*[$EN_CLOSE_BRACKET]\v'.085m'\"
.             el .as $EN_LINENUMBER \
\\n[#EN_MARK]\v'-.1m'-\v'.1m'\\n[#EN_MARK_2]\v'-.085m'\
\\*[$EN_CLOSE_BRACKET]\v'.085m'\"
.          \}
.          el \{\
.             ie \\n[#EN_MARK_2]=\\n[#EN_MARK] \
.                ds $EN_LINENUMBER \
\\n[#EN_MARK]\\*[$EN_LN_SEP]
.             el \
.                ds $EN_LINENUMBER \
\\n[#EN_MARK]\v'-.1m'-\v'.1m'\\n[#EN_MARK_2]\\*[$EN_LN_SEP]
.          \}
.          nr #EN_MARK 0
.       \}
.       vpt 0
.       ie \\n[#EN_NUMBERS_ALIGN_RIGHT] .RIGHT
.       el .LEFT
.       if \\n[#EN_MARKER_STYLE]=1 \
.          nr #EN_NUMBER_L_LENGTH \w'\0'*\\n[#EN_NUMBER_PLACEHOLDERS]+\w'.'
.       if \\n[#EN_MARKER_STYLE]=2 \{\
.          ie \\n[#EN_LN_BRACKETS]=1 .nr #EN_NUMBER_L_LENGTH \
(\w'\0'*(\\n[#EN_NUMBER_PLACEHOLDERS]*2))+\w'-[]'
.          el .nr #EN_NUMBER_L_LENGTH \
(\w'\0'*(\\n[#EN_NUMBER_PLACEHOLDERS]*2))+\w'-\\*[$EN_LN_SEP]'
.          RIGHT
.       \}
.       if \\n[#EN_MARKER_STYLE]=3 \{\
.          nr #EN_NUMBER_L_LENGTH \
\w'\0'*\\n[#EN_NUMBER_PLACEHOLDERS]+.15m
.          RIGHT
.       \}
.       ie \\n[#REF]=1 \
.          ll \\n[#EN_NUMBER_L_LENGTH]u+\\n[#REF_EN_INDENT]u
.       el .ll \\n[#EN_NUMBER_L_LENGTH]u
.       if \\n[#EN_MARKER_STYLE]=1 \{\
.          if \\n[#REF]=1 .ti \\n[#REF_EN_INDENT]u
.          nop \En[#EN_NUMBER].
.       \}
.       if \\n[#EN_MARKER_STYLE]=2 \{\
.          nop \\*[$EN_LINENUMBER]
.          rm $EN_LINENUMBER
.       \}
.       if \\n[#EN_MARKER_STYLE]=3 \{\
\!.        vpt 0
.          ps \" Reset ps changed to get width of s-script numbers
.          ie \\n[#PRINT_STYLE]=1 \{\
.\" Vertical raise amount here is less than when the same string is printed in
.\" the body of the text because number precedes a cap.
.             nop \
\s-2\v'-\\n[#DOC_LEAD]u/7u'\\n[#EN_NUMBER]\|\v'+\\n[#DOC_LEAD]u/7u'\s+2
.          \}
.          el .nop \E*[SUP]\\n[#EN_NUMBER]\E*[SUPX]\h'.15m'
.       \}
.       EOL
.       ll
\!.     vpt
.       nr #EN_FIGURE_SPACE \w'\0'
.       if \\n[#EN_MARKER_STYLE]=1 \{\
.          ie \\n[#REF]=1 .ti \
\\n[#EN_NUMBER_L_LENGTH]u+\\n[#REF_EN_INDENT]u+\\n[#EN_FIGURE_SPACE]u
.          el .in \
\\n[#EN_NUMBER_L_LENGTH]u+\\n[#EN_FIGURE_SPACE]u
.       \}
.       if \\n[#EN_MARKER_STYLE]=2 \{\
.          ie \\n[#REF]=1 .ti \
\\n[#EN_NUMBER_L_LENGTH]u+\\n[#REF_EN_INDENT]u+\\n[#EN_LN_GAP]u
.          el .ti \
\\n[#EN_NUMBER_L_LENGTH]u+\\n[#EN_LN_GAP]u
.       \}
.       if \\n[#EN_MARKER_STYLE]=3 \{\
.          ie \\n[#REF]=1 .ti \
\\n[#EN_NUMBER_L_LENGTH]u+\\n[#REF_EN_INDENT]u+\w'\|'u
.          el .in \
\\n[#EN_NUMBER_L_LENGTH]u
.       \}
.       nr #EN_TEXT_INDENT \\n[.i]
.       QUAD \\*[$EN_QUAD]
.       vpt
.       if \\n[#PRINT_STYLE]=1 .TYPEWRITER
.       if \\n[#PRINT_STYLE]=2 \{\
.          FAMILY  \\*[$EN_FAM]
.          FT      \\*[$EN_FT]
.          ps \\n[#EN_PS]u
.       \}
.    \}
.    el \{\
\!.     ie \\n[#EN_NUMBER]=\\\\n[#LAST_EN] .vpt 0
\!.     el .br
.       if \\n[#PRINT_STYLE]=2 .sp \\*[$EN_SPACE]
.       in 0
.       if \\n[#EN_MARKER_STYLE]=2 \{\
\!.        in 0
.       \}
.       da
.\" Restore sentence spacing
.       if \\n[#PRINT_STYLE]=2 \{\
.          if d$RESTORE_SS_VAR .SS \\*[$RESTORE_SS_VAR]
.          rm $RESTORE_SS_VAR
.       \}
.       ev
.\" Restore lead -- need
.       nr #PP_STYLE \\n[#PP_STYLE_PREV]
.       if !\\n[#INDENT_FIRSTS] .INDENT_FIRST_PARAS OFF
.       rr #INDENT_FIRSTS
.       rr #ENDNOTE
.       if \\n[#UNDERLINE_WAS_ON] \{\
.          rr #UNDERLINE_WAS_ON
.          UNDERLINE
.       \}
.       if \\n[#SLANT_WAS_ON] \{\
.          rr #SLANT_WAS_ON
\*[SLANT]\c
.       \}
.    \}
.    if \\n[#NUM_ARGS]=2 \{\
.       if '\\$2'BREAK' .BR
.       if '\\$2'BR' .BR
.    \}
.END
\#
\# Endnotes (user space macro)
\# ---------------------------
\#
\# ENDNOTES
\# --------
\# *Arguments:
\#   none
\# *Function:
\#   Sets new document leading from #EN_LEAD, breaks to a new page,
\#   sets up an endnotes page based on registers and strings associated
\#   with endnotes, then outputs diversion END_NOTES.
\#
.MAC ENDNOTES END
.    if \\n[defer] .NEWPAGE
.    nr #LAST_EN \\n[#EN_NUMBER]
.    nr #ENDNOTES 1
.    nr #EN_FIRST_PAGE 1
.    SETUP_ENDNOTES
.    if !\\n[#PRINT_STYLE]=1 .chop END_NOTES
.    nf
.    END_NOTES
.    rm END_NOTES
.    ps \\n[#DOC_PT_SIZE]u
.    if \\n[#PRINT_STYLE]=1 .vs \\n[#DOC_LEAD]u
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#ADJ_EN_LEAD] \
.          nr #DOC_LEAD \\n[#RESTORE_DOC_LEAD]
.       el .DOC_LEAD \\n[#RESTORE_DOC_LEAD]u
.       rr #RESTORE_DOC_LEAD
.    \}
.    if \\n[#COLUMNS_WERE_ON] .nr #COLUMNS 1
.    if \\n[#HEADER_STATE]=1 .HEADERS
.    if \\n[#LINENUMBERS]=2 \{\
.       NUMBER_LINES RESUME
.       nr #LINENUMBERS 1
.    \}
.    rr #ENDNOTES
.END
\#
\# Macros common to endnotes, bibliography, and toc
\# ------------------------------------------------
\#
.MAC SETUP_BIB_EN END
.    if '\\$0'SETUP_BIBLIOGRAPHY' .ds EN-OR-BIB BIB
.    if '\\$0'SETUP_ENDNOTES'     .ds EN-OR-BIB EN
.    nr #HEADER_STATE \\n[#HEADERS_ON]
.    ds $RESTORE_PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.    if \\n[#LINENUMBERS]=1 \{\
.       NUMBER_LINES OFF
.       nr #LINENUMBERS 2
.    \}
.    if \\n[#HEADERS_ON]=1 \
.       if !\\n[#\\*[EN-OR-BIB]_ALLOWS_HEADERS_ALL] .HEADERS OFF
.    if \\n[#HEADER_STATE]=1 \{\
.       ie \\n[#\\*[EN-OR-BIB]_HDRFTR_CENTER]=1 .
.       el .rm $HDRFTR_CENTER
.    \}
.    ie !\\n[#SUSPEND_PAGINATION] \{\
.       if \\n[#PAGINATE]=1 \{\
.          if \\n[#PAGE_NUM_V_POS]=1 \{\
.             PAGENUM_STYLE \\*[$\\*[EN-OR-BIB]_PN_STYLE]
.             if \\n[#\\*[EN-OR-BIB]_FIRST_PN] .PAGENUMBER \\n[#\\*[EN-OR-BIB]_FIRST_PN]-1
.             if r #\\*[EN-OR-BIB]_NO_FIRST_PN .nr #PAGINATE 0
.          \}
.       \}
.    \}
.    el \{\
.       ie \\n[#PAGE_NUM_V_POS]=2 .nr #PAGINATE 1
.       el .nr #PAGINATE 0
.    \}
.    if \\n[#FOOTERS_ON]=1 \{\
.       if !'\\*[$HDRFTR_CENTER_OLD]'' \
.          ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_OLD]
.    \}
.    NEWPAGE
.    if \\n[#FOOTERS_ON]=1 \{\
.       ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_NEW]
.       rm $HDRFTR_CENTER_OLD
.       rm $HDRFTR_CENTER_NEW
.    \}
.    ie !\\n[#SUSPEND_PAGINATION] \{\
.       if \\n[#PAGE_NUM_V_POS]=1 \{\
.          if r #\\*[EN-OR-BIB]_NO_FIRST_PN \
.             if \\n[#PAGINATION_STATE]=1 .nr #PAGINATE 1
.       \}
.    \}
.    el \
.       if \\n[#PAGE_NUM_V_POS]=2 .nr #PAGINATE 0
.    rr #PAGINATION_STATE
.    PAGENUM_STYLE \\*[$\\*[EN-OR-BIB]_PN_STYLE]
.    if \\n[#\\*[EN-OR-BIB]_FIRST_PN] .PAGENUMBER \\n[#\\*[EN-OR-BIB]_FIRST_PN]
.    if \\n[#HEADER_STATE]=1 \
.       if \\n[#\\*[EN-OR-BIB]_ALLOWS_HEADERS] .HEADERS
.\" Collect endnotes title string for TOC
.    nr #TOC_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.    af #TOC_ENTRY_PN \\g[#PAGENUMBER]
.    ds $TOC_TITLE_ITEM \\*[$\\*[EN-OR-BIB]_STRING]\|
.    PDF_BOOKMARK 1 \\*[$\\*[EN-OR-BIB]_STRING]
.    TITLE_TO_TOC
.\" End collection of endnotes title string for TOC
.\" Process endnotes
.    if \\n[#PRINT_STYLE]=1 .vs \\n[#\\*[EN-OR-BIB]_LEAD]u
.    if \\n[#PRINT_STYLE]=2 \{\
.       if \\n[#\\*[EN-OR-BIB]_NO_COLS] \{\
.          if \\n[#COLUMNS] .nr #COLUMNS_WERE_ON 1
.          nr #COLUMNS 0
.       \}
.       nr #RESTORE_DOC_LEAD \\n[#DOC_LEAD]
.       ie \\n[#ADJ_\\*[EN-OR-BIB]_LEAD] .nr #DOC_LEAD \\n[#\\*[EN-OR-BIB]_LEAD]
.       el .DOC_LEAD \\n[#\\*[EN-OR-BIB]_LEAD]u
.    \}
.    vpt 0
.    RESTORE_SPACE
.    ie r#\\*[EN-OR-BIB]_STRING_V_POS .sp |\\n[#\\*[EN-OR-BIB]_STRING_V_POS]u-1v
.    el .sp |\\n[#T_MARGIN]u-\\n[#\\*[EN-OR-BIB]_LEAD]u
.    vpt
.    mk ec
.    if \\n[#SLANT_ON] \{\
\*[SLANTX]\c
.    \}
.    sp
.    if !'\\*[$\\*[EN-OR-BIB]_STRING]'' \{\
.       if \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          vs \\n[#\\*[EN-OR-BIB]_LEAD]u
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          LL \\n[#DOC_L_LENGTH]u
.          ta \\n[.l]u
.          if \\n[#COLUMNS] \{\
.             ie \\n[#\\*[EN-OR-BIB]_NO_COLS] .LL \\n[#DOC_L_LENGTH]u
.             el .LL \\n[#COL_L_LENGTH]u
.             ta \\n[.l]u
.          \}
.          FAMILY  \\*[$\\*[EN-OR-BIB]_STRING_FAM]
.          FT      \\*[$\\*[EN-OR-BIB]_STRING_FT]
.          ps \\n[#\\*[EN-OR-BIB]_PS]u\\*[$\\*[EN-OR-BIB]_STRING_SIZE_CHANGE]
.          vs      \\n[#\\*[EN-OR-BIB]_LEAD]u
.       \}
.       substring $\\*[EN-OR-BIB]_STRING_QUAD 0 0
.       if '\\*[$\\*[EN-OR-BIB]_STRING_QUAD]'L' .LEFT
.       if '\\*[$\\*[EN-OR-BIB]_STRING_QUAD]'C' .CENTER
.       if '\\*[$\\*[EN-OR-BIB]_STRING_QUAD]'R' .RIGHT
.       EOL
.       if \\n[#\\*[EN-OR-BIB]_STRING_COLOR]=1 .COLOR \\*[$\\*[EN-OR-BIB]_STRING_COLOR]
.       if \\n[#\\*[EN-OR-BIB]_STRING_CAPS] .CAPS
.       if \\n[#\\*[EN-OR-BIB]_STRING_SMALLCAPS] .SMALLCAPS
.       ie \\n[#\\*[EN-OR-BIB]_STRING_UNDERLINE] \{\
.          if \\n[#PRINT_STYLE]=2 .ds $TITLE_TYPE \\*[EN-OR-BIB]_STRING
.          ie \\n[#PRINT_STYLE]=1 \
.             UNDERSCORE2 3p 2p "\\*[$\\*[EN-OR-BIB]_STRING]"
.          el \{\
.             ie \\n[#\\*[EN-OR-BIB]_STRING_UNDERLINE]=2 \
.                UNDERSCORE2 \\*[$\\*[EN-OR-BIB]_UNDERLINE_GAP] \\*[$\\*[EN-OR-BIB]_RULE_GAP] "\\*[$\\*[EN-OR-BIB]_STRING]"
.             el .UNDERSCORE "\\*[$\\*[EN-OR-BIB]_STRING]"
.          \}
.       \}
.       el .PRINT "\\*[$\\*[EN-OR-BIB]_STRING]
.    \}
.    SMALLCAPS OFF
.    if \\n[#\\*[EN-OR-BIB]_STRING_COLOR]=1 .gcolor
.    CAPS OFF
.    FAMILY \\*[$\\*[EN-OR-BIB]_FAMILY]
.    FT \\*[$\\*[EN-OR-BIB]_FT]
.    ps -\\*[$\\*[EN-OR-BIB]_STRING_SIZE_CHANGE]
.    ie \\n[#PRINT_STYLE]=1 \{\
.       ie \\n[#SINGLE_SPACE]=1 .sp
.       el \{\
.          ie \\n[#\\*[EN-OR-BIB]_SINGLESPACE]=1 .sp
.          el .
.       \}
.    \}
.    el \{\
.       ie '\\*[EN-OR-BIB]'BIB' .sp 2
.       el .sp
.    \}
.    SHIM
.    QUAD \\*[$\\*[EN-OR-BIB]_QUAD]
.END
.
.ALIAS SETUP_BIBLIOGRAPHY SETUP_BIB_EN
.ALIAS SETUP_ENDNOTES     SETUP_BIB_EN
\#
\# ENDNOTES, BIBLIOGRAPHY and TOC LEADING
\# --------------------------------------
\# *Argument:
\#   <leading> [ ADJUST ]
\# *Function:
\#   Depending on the name by which it's called, creates or modifies
\#   register #<type>_LEAD, where <type> is BIB, EN, or TOC.  Creates or removes
\#   register #ADJ_<type>_LEAD.  Stores arguments in strings if BIB,
\#   EN, or TOC leading are set before START.
\# *Notes:
\#   Default is same as doc lead for TYPESET, adjusted; 24 for TYPEWRITE.
\#
.MAC _LEAD END
.    if '\\$0'BIBLIOGRAPHY_LEAD' .ds $SECTION BIB
.    if '\\$0'ENDNOTE_LEAD' .ds $SECTION EN
.    if '\\$0'TOC_LEAD' .ds $SECTION TOC
.    rr #ADJ_\\*[$SECTION]_LEAD
.    ds $\\*[$SECTION]_LEAD \\$1
.    rm $ADJUST_\\*[$SECTION]_LEAD
.    if '\\$2'ADJUST' \{\
.       nr #ADJ_\\*[$SECTION]_LEAD 1
.       ds $ADJUST_\\*[$SECTION]_LEAD ADJUST
.    \}
.    if !\\n[#OK_PROCESS_LEAD] .return
.    nr #\\*[$SECTION]_LEAD (p;\\$1)
.END
.
.ALIAS BIBLIOGRAPHY_LEAD _LEAD
.ALIAS ENDNOTE_LEAD      _LEAD
.ALIAS TOC_LEAD          _LEAD
\#
\# ====================================================================
\#
\# +++BIBLIOGRAPHY+++
\#
\# Mom treats bibliographies and endnotes very similarly.  The chief
\# difference is that endnotes are collected and formatted inside a
\# diversion, while bibliographies are built "by hand."  ENDNOTES sets
\# up the endnotes page and outputs the formatted diversion.
\# BIBLIOGRAPHY sets up the bibliography page, then awaits refer
\# commands.
\#
\# All of the bibliography control macros have their exact
\# counterparts in the endnotes control macros.  See, therefore,
\# Arguments, Functions, and Notes in the Endnotes section.
\#
\# Bibliography control macros
\#
.MAC BIBLIOGRAPHY_PT_SIZE END
.    nr #BIB_PS (p;\\$1)
.END
\#
.MAC BIBLIOGRAPHY_HDRFTR_CENTER END
.    ie '\\$1'' .nr #BIB_HDRFTR_CENTER 1
.    el .rr #BIB_HDRFTR_CENTER
.END
\#
.MAC BIBLIOGRAPHY_STRING END
.    ds $BIB_STRING \\$1
.END
\#
.MAC BIBLIOGRAPHY_STRING_ADVANCE END
.    nr #BIB_STRING_V_POS (u;\\$1)
.END
\#
.MAC BIBLIOGRAPHY_STRING_V_POS END
.    nr #BIB_STRING_V_POS (u;\\$1)
.END
.
.ALIAS BIBLIOGRAPHY_HEADER_V_POS BIBLIOGRAPHY_STRING_V_POS
\#
.MAC BIBLIOGRAPHY_NO_COLUMNS END
.    ie '\\$1'' .nr #BIB_NO_COLS 1
.    el .rr #BIB_NO_COLS
.END
\#
.MAC BIBLIOGRAPHY_NO_FIRST_PAGENUM END
.    ie '\\$1'' .nr #BIB_NO_FIRST_PN 1
.    el .rr #BIB_NO_FIRST_PN
.END
\#
.MAC BIBLIOGRAPHY_ALLOWS_HEADERS END
.    ie '\\$1'' .nr #BIB_ALLOWS_HEADERS 1
.    el \{\
.       ie '\\$1'ALL' \{\
.          nr #BIB_ALLOWS_HEADERS 1
.          nr #BIB_ALLOWS_HEADERS_ALL 1
.       \}
.       el \{\
.          rr #BIB_ALLOWS_HEADERS
.          rr #BIB_ALLOWS_HEADERS_ALL
.       \}
.    \}
.END
\#
.MAC BIBLIOGRAPHY_PAGENUM_STYLE END
.    ds $BIB_PN_STYLE \\$1
.END
\#
.MAC BIBLIOGRAPHY_FIRST_PAGENUMBER END
.    nr #BIB_FIRST_PN \\$1
.END
\#
.MAC SINGLESPACE_BIBLIOGRAPHY END
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie \\n[#SINGLE_SPACE] \{\
.          nr #BIB_SINGLESPACE 1
.          rr #IGNORE
.          if \\n[#OK_PROCESS_LEAD] \{\
.             BIBLIOGRAPHY_LEAD 12 ADJUST
.             nr #IGNORE 1
.          \}
.       \}
.       el \{\
.          ie '\\$1'' \{\
.             nr #BIB_SINGLESPACE 1
.             rr #IGNORE
.             if \\n[#OK_PROCESS_LEAD] \{\
.                BIBLIOGRAPHY_LEAD 12 ADJUST
.                nr #IGNORE 1
.             \}
.          \}
.          el \{\
.             rr #BIB_SINGLESPACE
.             rr #IGNORE
.             if \\n[#OK_PROCESS_LEAD] \{\
.                BIBLIOGRAPHY_LEAD 24 ADJUST
.                nr #IGNORE 1
.             \}
.          \}
.       \}
.    \}
.END
\#
\# Style for outputting collected bibliographic references
\# -------------------------------------------------------
\# *Argument:
\#   LIST | PLAIN [ <list separator> ] [ <list prefix> ]
\# *Function:
\#   Sets #BIB_LIST to 1 for numbered list style, 0 for plain output
\# *Notes:
\#   Technically, user is supposed to enter PLAIN if s/he wants an
\#   unnumbered bibliography, but the el clause says "any arg but
\#   LIST means unnumbered."  Effectively, any arg but LIST produces
\#   a "plain" bibliographic list.
\#
\# The 2nd and 3rd args have the same options as the 2nd and 3rd
\# args to LIST.
\#
.MAC BIBLIOGRAPHY_TYPE END
.    ie '\\$1'LIST' \{\
.       nr #BIB_LIST 1
.       ie '\\$2'' \
.          if '\\*[$BIB_LIST_SEPARATOR]'' .ds $BIB_LIST_SEPARATOR .
.       el .ds $BIB_LIST_SEPARATOR \\$2
.       ie '\\$3'' .ds $BIB_LIST_PREFIX
.       el .ds $BIB_LIST_PREFIX \\$3
.    \}
.    el .nr #BIB_LIST 0
.END
\#
\# Spacing between items in bibliographies
\# ---------------------------------------
\# *Argument:
\#   <amount of space>
\# *Function:
\#   Gets value for #BIB_SPACE in units.
\# *Notes:
\#   Requires a unit of measure.
\#
.MAC BIBLIOGRAPHY_SPACING END
.    ds $BIB_SPACE \\$1
.    if \\n[#BIB_LEAD]=0 \{\
.       nr #DEFER_BIB_SPACING 1
.       return
.    \}
.    ds $EVAL_BIB_SPACE \\*[$BIB_SPACE]
.    substring $EVAL_BIB_SPACE -1
.    ie '\\*[$EVAL_BIB_SPACE]'v' \{\
.       substring $BIB_SPACE 0 0
.       nr #BIB_SPACE \\n[#BIB_LEAD]*\\*[$BIB_SPACE]
.    \}
.    el .nr #BIB_SPACE (\\$1)
.END
\#
\# Bibliography (user space macro)
\# -------------------------------
\# *Function:
\#   Sets up a new page, with title, ready to accept the output
\#   of refer's $LIST$ or .R1 bibliography .R2
\# *Notes:
\#   Bibliography pages are set up almost identically to endnotes pages.
\#
.MAC BIBLIOGRAPHY END
.    if \\n[defer] .NEWPAGE
.    ie '\\$1'' \{\
.       rr #FN_REF
.       rr #EN_REF
.       nr #BIBLIOGRAPHY 1
.       nr #BIB_FIRST_PAGE 1
.       nr #SKIP_FOOTER +1
.       SETUP_BIBLIOGRAPHY
.       nr #SKIP_FOOTER -1
.       if \\n[#PRINT_STYLE]=1 \{\
.          ie \\n[#SINGLE_SPACE]=1 .vs \\n[#BIB_LEAD]u
.          el \{\
.             ie \\n[#BIB_SINGLESPACE]=1 .vs \\n[#BIB_LEAD]u
.             el .vs \\n[#BIB_LEAD]u
.          \}
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          ie \\n[#ADJ_BIB_LEAD] \
.             nr #DOC_LEAD \\n[#RESTORE_DOC_LEAD]
.          el .DOC_LEAD \\n[#RESTORE_DOC_LEAD]u
.          rr #RESTORE_DOC_LEAD
.       \}
.       if \\n[#COLUMNS_WERE_ON] .nr #COLUMNS 1
.       if \\n[#HEADER_STATE]=1 .HEADERS
.       if \\n[#LINENUMBERS]=2 \{\
.          NUMBER_LINES RESUME
.          nr #LINENUMBERS 1
.       \}
.       di BIB
.    \}
.    el \{\
.       br
.       di
.\" Part of workaround for refer spitting out a blank page if the
.\" last ref falls on the bottom line.
.       nr num*refs \\n[ref*num*first-pass]
.       nf
.       chop BIB
.       BIB
.    \}
.    rr #BIBLIOGRAPHY
.END
\#
\# ====================================================================
\#
\# +++TABLE OF CONTENTS+++
\#
\# Strings to allocate space for leaders and entry page numbers
\#
.ds $TOC_PN \\*[ST102]\F[\\*[$TOC_PN_FAM]]\f[\\*[$TOC_PN_FT]]\
\s[\\n[#TOC_PS]u]^\\*[ST102X]\\*[ST103]\s[\\*[$TOC_PN_SIZE_CHANGE]]\
\h'.2n'\h'\w'0'u*\\n[#TOC_PN_PADDING]u'\\*[ST103X]
\#
.ds $TOC_PN_TYPEWRITE \\*[ST102]^\\*[ST102X]\\*[ST103]\
\h'\w'0'u*\\n[#TOC_PN_PADDING]u'\\*[ST103X]
\#
\# TOC collector
\#
.MAC TO_TOC END
.    if !'\\n[.ev]'TOC_EV' .ev TOC_EV
.    nr #TOC_CH_NUM_INDENT \w'\\*[$TOC_CH_NUM]'
.    da TOC_ENTRIES
\!.  ie \\\\n[#SKIP_ENTRY]=1 \{\
.     rr #SKIP_ENTRY
\!.  \}
\!.  el \{\
.       TQ
.       ie \\n[#PRINT_STYLE]=1 \{\
\!.        fam \\*[$TYPEWRITER_FAM]
\!.        ft  R
\!.        ps \\*[$TYPEWRITER_PS]
.          ds _TYPEWRITE _TYPEWRITE
.       \}
.       el \{\
.          ie '\\$0'HD_TO_TOC' \{\
\!.           ps \\n[#TOC_PS]u\\*[$TOC_HEAD_\\n[#LEVEL]_SIZE]
.          \}
.          el \{\
\!.           FAMILY \\*[$TOC_TITLE_FAM]
\!.           FT     \\*[$TOC_TITLE_FT]
\!.           ps \\n[#TOC_PS]u\\*[$TOC_TITLE_SIZE]
.          \}
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          rm _TYPEWRITE
.          if \\n[#SPACE_TOC_ITEMS] \{\
.             if \\n[#POST_TOP]=1 \{\
.                ie !\\n[#LEVEL]=\\n[#LAST_LEVEL] \{\
.                   ie \\n[#LEVEL]>\\n[#LAST_LEVEL] \!.sp .2v
.                   el \!.sp .4v
.                \}
.                el \{\
.                   if \\n[#COLLATED_DOC] \
.                      if '\\$0'TITLE_TO_TOC' \!.sp .4v
.                \}
.             \}
.          \}
.       \}
\!.     PAD_MARKER ^
.       if !'\\$0'HD_TO_TOC' \{\
\!.        if \\n[#TOC_TITLE_CAPS]=1 .CAPS
.       \}
.       if '\\$0'HD_TO_TOC' \{\
.          nr #POST_TOP 1
\!.        if \\n[#TOC_HEAD_\\n[#LEVEL]_CAPS]=1 .CAPS
.       \}
\!.     vpt 0
.       ie '\\$0'HD_TO_TOC' \{\
.          if \\n[#PRINT_STYLE]=1 \{\
.             ds $TOC_HEAD_\\n[#LEVEL]_FAM] \\*[$TYPEWRITER_FAM]
.             ds $TOC_HEAD_\\n[#LEVEL]_FT]  R
.          \}
\!.        PAD \
"\f[\\*[$TOC_HEAD_\\n[#LEVEL]_FAM]\
\\*[$TOC_HEAD_\\n[#LEVEL]_FT]]\
\h'\\\\n[#TOC_INDENT_ADJ]u'\h'\\n[#TOC_HEAD_\\n[#LEVEL]_INDENT]u'\
\\*[$TOC_HD_NUM]\\*[$TOC_HEAD_\\n[#LEVEL]_ITEM]\\*[$TOC_PN\\*[_TYPEWRITE]]" \
"\\*[PDFBOOKMARK.NAME]"
.       \}
.       el \{\
.          if \\n[#PRINT_STYLE]=1 \{\
.             ds $TOC_TITLE_FAM \\*[$TYPEWRITER_FAM]
.             ds $TOC_TITLE_FT  R
.          \}
\!.        PAD \
"\f[\\*[$TOC_TITLE_FAM]\\*[$TOC_TITLE_FT]]\
\h'\\n[#TOC_TITLE_INDENT]u'\\*[$TOC_TITLE_ITEM]\\*[$TOC_PN\\*[_TYPEWRITE]]" \
"\\*[PDFBOOKMARK.NAME]"
.       \}
.       ie '\\$0'HD_TO_TOC' \
\!.        if \\n[#TOC_HEAD_\\n[#LEVEL]_CAPS]=1 .CAPS OFF
.       el \
\!.        if \\n[#TOC_TITLE_CAPS]=1 .CAPS OFF
\!.     PAD_MARKER #
\!.     EOL
\!.     ST 102 L
\!.     ST 103 R QUAD
.       if \\n[#PRINT_STYLE]=2 \{\
\!.        FAMILY  \\*[$TOC_PN_FAM]
\!.        FT      \\*[$TOC_PN_FT]
\!.        ps \\n[#TOC_PS]u
.       \}
\!.     TAB 102
\!.     PRINT \fR\\*[LEADER]\f[]
\!.     TN
.       if \\n[#PRINT_STYLE]=2 \{\
\!.        ps \\*[$TOC_PN_SIZE_CHANGE]
.       \}
\!.     PRINT \\n[#TOC_ENTRY_PN]
\!. \}
.   da
.   ev
.END
.
.ALIAS HD_TO_TOC    TO_TOC
.ALIAS TITLE_TO_TOC TO_TOC
\#
\# Control macros for toc
\# ----------------------
\#
\# TOC TITLE STYLE
\# ---------------
\# *Arguments:
\#   FAMILY <family>
\#   FONT   <font>
\#   SIZE   <+|-n>
\#   COLOR  <color>
\#   CAPS
\#   INDENT
\# *Function:
\#   Assigns complete style parameters to TITLEs (doc titles,
\#   chapter titles, etc) in the TOC.
\# *Notes:
\#   TITLEs are not headings, therefore they require their own style
\#   macro.  Otherwise, the same as TOC_ENTRY_STYLE.
\#
.MAC TOC_TITLE_STYLE END
.    nr #ARG_NUM 0 1
.    nr #ATTRIB \\n[#NUM_ARGS]
.    while \\n+[#ARG_NUM]<=\\n[#ATTRIB] \{\
.       if '\\$1'FAMILY' \{\
.          shift
.          ds $TOC_TITLE_FAM  \\$1
.          shift
.       \}
.       if '\\$1'FONT' \{\
.          shift
.          ds $TOC_TITLE_FT   \\$1
.          shift
.       \}
.       if '\\$1'SIZE' \{\
.          shift
.          ds $TOC_TITLE_SIZE \\$1
.          shift
.       \}
.       if '\\$1'CAPS' \{\
.          nr #TOC_TITLE_CAPS 1
.          shift
.       \}
.       if '\\$1'NO_CAPS' \{\
.          rr #TOC_TITLE_CAPS
.          shift
.       \}
.       if '\\$1'SMALLCAPS' \{\
.          nr #TOC_TITLE_SMALLCAPS 1
.          shift
.       \}
.       if '\\$1'NO_SMALLCAPS' \{\
.          rr #TOC_TITLE_SMALLCAPS
.          shift
.       \}
.       if '\\$1'INDENT' \{\
.          shift
.          nr #TOC_TITLE_INDENT \\$1
.          shift
.       \}
.    \}
.END
\#
\# TOC HEADER STRING
\# -----------------
\# *Argument:
\#   <string for "doc header" of first toc page>
\# *Function:
\#   Creates or modifies string $TOC_HEADER_STRING
\# *Notes:
\#   Default is "Contents".
\#
.MAC TOC_HEADER_STRING END
.    ds $TOC_HEADER_STRING \\$1
.END
\#
\# TOC HEADER CAPS and SMALLCAPS
\# -----------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns capitalization or smallcaps style of the toc title string
\#   on or off.
\# *Notes:
\#   Users may want the toc title string to be in
\#   caps, but the page header to be in lower case.  If the
\#   argument to TOC_HEADER_STRING is in lower case and
\#   TOC_HEADER_CAPS is turned on, this is exactly what will
\#   happen.  Ditto for SMALLCAPS.
\#
.MAC TOC_HEADER_CAPS END
.   ie '\\$1'' .nr #TOC_STRING_CAPS 1
.   el .nr #TOC_STRING_CAPS 0
.END
.
.MAC TOC_HEADER_SMALLCAPS END
.   ie '\\$1'' .nr #TOC_STRING_SMALLCAPS 1
.   el .nr #TOC_STRING_SMALLCAPS 0
.END
.
\#
\# TOC VERTICAL PLACEMENT
\# ----------------------
\# *Argument:
\#   <distance from page top>
\# *Function:
\#   Creates register #TOC_HEADER_V_POS.
\# *Notes:
\#   Default is same as normal docheader position.
\#
.MAC TOC_HEADER_V_POS END
.    nr #TOC_HEADER_V_POS (u;\\$1)
.END
\#
\#
\# TOC POINT SIZE
\# --------------
\# *Argument:
\#   <base point size for toc pages>
\# *Function:
\#   Creates or modifies register #TOC_PS.
\# *Notes:
\#   This size control macro differs from other size control macros
\#   in that it sets an absolute point size, not a relative one.
\#   See notes for ENDNOTE_PT_SIZE for explanation.
\#
\#   No unit of measure required (points assumed).  Default is 12.5
\#   for TYPESET.
\#
.MAC TOC_PT_SIZE END
.    nr #TOC_PS (p;\\$1)
.END
\#
\# TOC ENTRIES PAGE NUMBERS PADDING
\# --------------------------------
\# *Argument:
\#   <number of placeholders for toc entries page numbers>
\# *Function:
\#   Creates or modifies register #TOC_PN_PADDING.
\# *Notes:
\#   "Placeholders" is the maximum number of digits in a page
\#   number numeral.
\#
\#   Default is 3.
\#
.MAC TOC_PADDING END
.    nr #TOC_PN_PADDING \\$1
.END
\#
\# PAGINATE TOC
\# ------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes register #PAGINATE_TOC.
\# *Notes:
\#   Default is to paginate toc.
\#
.MAC PAGINATE_TOC END
.    ie '\\$1'' .nr #PAGINATE_TOC 1
.    el .nr #PAGINATE_TOC 0
.END
\#
.MAC TOC_FIRST_PAGENUM END
.    nr #TOC_START_PAGENUM \\$1
.END
\#
\# TOC PAGES PAGE-NUMBERING STYLE
\# ------------------------------
\# *Argument:
\#   DIGIT | ROMAN | roman | ALPHA | alpha
\# *Function:
\#   Creates or modifies string $TOC_PN_STYLE
\# *Notes:
\#   Page numbering style for page numbers that appear in the
\#   headers/footers of toc pages.  See notes for PAGENUM_STYLE.
\#
\#   Default is roman.
\#
.MAC TOC_PAGENUM_STYLE END
.    ds $TOC_PN_STYLE \\$1
.END
\#
\# TOC RECTO_VERSO SWITCH
\# ----------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes register #TOC_RV_SWITCH
\# *Notes:
\#   Allows switching of L/R margins if a doc is recto/verso and
\#   the first toc page happens to fall the wrong way
\#
.MAC TOC_RV_SWITCH END
.    ie '\\$1'' .nr #TOC_RV_SWITCH 1
.    el .rr #TOC_RV_SWITCH
.END
\#
\# TOC ENTRY SPACING
\# -----------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles whether a small amount of space is inserted between TOC
\#   entries for greater legibility.
\#
.MAC SPACE_TOC_ITEMS END
.    ie !'\\$1'' .rr #SPACE_TOC_ITEMS
.    el .nr #SPACE_TOC_ITEMS 1
.END
\#
\# NUMBERING OF TOC CHAPTER/SECTION ENTRIES
\# ----------------------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Determines whether chapter numbers are prefixed to title
\#   entries in the TOC (title here means chapter/chapter-title
\#   or, if the doctype is DEFAULT or NAMED, the section title.
\# *Notes:
\#   Aliased as TOC_PREFIX_SECTION_NUMBER.
\#
.MAC TOC_PREFIX_CHAPTER_NUMBER END
.    ie '\\$1'' .nr #TOC_PREFIX_CH_NUM 1
.    el .rr #TOC_PREFIX_CH_NUM
.END
.
.ALIAS TOC_PREFIX_SECTION_NUMBER TOC_PREFIX_CHAPTER_NUMBER
\#
\# PADDING OF TOC CHAPTER/SECTION NUMBERS
\# --------------------------------------
\# *Arguments:
\#   <amount of padding> | <anything>
\# *Function:
\#   Insert figure spaces before toc chapter numbers so they
\#   right align.
\# *Notes:
\#   Aliased as PAD_TOC_SECTION_NUMBERS.
\#
.MAC PAD_TOC_CHAPTER_NUMBERS END
.    ie !'\\$1'' .nr #PAD_TOC_CH_NUM \\$1
.    el .rr #PAD_TOC_CH_NUM
.END
.
.ALIAS PAD_TOC_SECTION_NUMBERS PAD_TOC_CHAPTER_NUMBERS
\#
\# NUMBERING OF TOC HEAD ENTRIES
\# -----------------------------
\# *Arguments:
\#   FULL | TRUNCATE | NONE
\# *Function:
\#   Determines how, or whether, to prepend heading numbers to TOC
\#   entries.
\# *Notes:
\#   FULL means the complete numbering string (default).
\#
\#   TRUNCATE means prepend a single digit sufficient to identify
\#   an entry's place in the numbering scheme with reference to the
\#   level above it.  Thus, if a HEADING 1 is the second HEADING 1
\#   and therefore numbered "2.", a HEADING 2 beneath it (in the TOC)
\#   will have only "1." prepended to the entry; TOC indenting makes it
\#   evident under which level the HEADING 2 belongs.
\#
\#   Note that TRUNCATE also removes chapter numbers, if
\#   PREFIX_CHAPTER_NUMBER is on.
\#
.MAC TOC_ENTRY_NUMBERS END
.    if '\\$1'TRUNCATE' .nr #TRUNC_TOC_HD_NUM 1
.    if '\\$1'FULL'     .nr #TRUNC_TOC_HD_NUM 0
.    if '\\$1'NONE'     .nr #TOC_NO_HD_NUM 1
.END
\#
\# User defined TITLE entry string
\#
.MAC TOC_TITLE_ENTRY END
.    nr #USER_SET_TITLE_ITEM 1
.    ds $USER_SET_TITLE_ITEM \\$1
.END
\#
\# APPEND AUTHOR(S) TO TOC DOC TITLE ENTRIES
\# -----------------------------------------
\# *Argument:
\#   <none> | <name(s) of author(s) as they should appear in toc doc title entries>
\# *Function:
\#   Creates register #TOC_AUTHORS (to tell TOC to append authors
\#   to toc doc title entries).  Optionally creates string
\#   $TOC_AUTHORS.
\# *Notes:
\#   Normally, TOC does not append the author(s) to a toc doc title
\#   entry.  This special macro instructs TOC to do so.
\#
\#   If user has multiple authors for each doc when collating,
\#   TOC_APPENDS_AUTHOR "<string>" must be inserted somewhere between
\#   COLLATE and START in each doc.  Otherwise, mom prints only the
\#   first author given to AUTHOR.
\#
.MAC TOC_APPENDS_AUTHOR END
.    nr #TOC_AUTHORS 1
.    if !'\\$1'' .ds $TOC_AUTHORS \\$1
.END
\#
\# TABLE OF CONTENTS PAGE SETUP
\# ----------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Some changes to the TOC layout (e.g. margins and page headers)
\#   are not covered by the TOC and endnotes control macros.  This
\#   macro permits access to any and all page setup macros not so
\#   covered.
\# *Notes
\#   Wraps a diversion that ends when the macro is invoked with an
\#   argument.  The contained formatting macros must be preceded by
\#   '\!'.  The diversion is output before START in TOC.
\#
.MAC TOC_PAGE_SETTINGS END
.    nr #TOC_PAGE_PARAMS 1
.    ie '\\$1'' \
.       di TOC_PAGE_PARAMS
.    el .di
.END
\#
\# TABLE OF CONTENTS
\# -----------------
\# *Arguments:
\#   none
\# *Function:
\#   Takes care of the administrivia of setting up the TOC as if
\#   it's a collated doc, then outputs the formatted TOC_ENTRIES
\#   diversion.
\#
.MAC TOC END
.    ie (\\n[@TOP]=0)&(\\n[.t]<=\\n[.v]) \
'       br  \" When last line of text is on or near b-margin.
.    el .br \" All other cases
.    if dPDF.EXPORT \
.       if \\n[#FLEX_ACTIVE] \
.          if !\\n[#NO_FLEX] \
.             tm .ds pre-toc-\\n%@\\n[#COL_NUM] 1
.    if \\n[#TOC_RV_SWITCH]=1 .nr #TOC_RV_SWITCH 2
.    char \[leader] " .
.    LEADER_CHARACTER \[leader]
.    if !\\n[#TOC_HEAD_1_INDENT] \
.       nr #TOC_INDENT_ADJ 1.5m
.    if \\n[#TOC_PREFIX_CH_NUM] \
.       nr #TOC_INDENT_ADJ \\n[#TOC_CH_NUM_INDENT]
.    if !\\n[#DOC_TYPE]=2 \{\
.       if !'\\$1'INCLUDE_TITLE' \{\
.          if r #LEVEL .nr #SKIP_ENTRY 1
.          nr #TOC_INDENT_ADJ 0
.       \}
.    \}
.    nr #TOC 1
.    nr TOC.RELOCATE 0
.    if \\n[#LINENUMBERS]=1 \{\
.       NUMBER_LINES OFF
.       nr #LINENUMBERS 2
.    \}
.    if !r #PAGINATE_TOC .PAGINATE_TOC
.    nr #TOC_FIRST_PAGE 1
.    if \\n[#FINIS] \{\
.       if \\n[#FOOTERS_WERE_ON] \
.          FOOTERS \" Have to turn FOOTERS on for next bit to work, so we can't skip this step
.    \}
.    if \\n[#FOOTERS_ON]=1 \{\
.       if !'\\*[$HDRFTR_CENTER_OLD]'' \
.          ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_OLD]
.       ie \\n[#PAGINATE_TOC]=1 .PAGINATE
.       el .PAGINATION OFF
.    \}
.    if \\n[#FOOTERS_WERE_ON] .FOOTERS OFF  \" But have to turn FOOTERS off again so they don't print when FINIS was called
.    rr #COLUMNS
.    COLLATE
.    if \\n[#PRINT_STYLE]=1 \{\
.       rr #IGNORE
.       if \\n[#SINGLE_SPACE] .DOC_LEAD 24
.       DOC_LEAD_ADJUST
.       TRAPS
.       nr #IGNORE 1
.    \}
.    if \\n[#FINIS] \{\
.       if \\n[#FOOTERS_WERE_ON] .FOOTERS  \" Finally, turn footers on if they were on
.       rr #FOOTERS_WERE_ON
.       if \\n[#PAGINATION_WAS_ON] \{\
.          nr #PAGINATE 1
.          rr #PAGINATION_WAS_ON
.       \}
.       rr #FINIS
.    \}
.    ie \\n[#PAGINATE_TOC]=1 .PAGINATE
.    el .PAGINATION OFF
.    ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_NEW]
.    rm $HDRFTR_CENTER_OLD
.    rm $HDRFTR_CENTER_NEW
.    rr #COLLATED_DOC
.    if !r #TOC_START_PAGENUM .nr #TOC_START_PAGENUM 1
.    PAGENUMBER \\n[#TOC_START_PAGENUM]
.    if \\n[#LINENUMBERS]=2 .nr #LINENUMBERS 3
.    L_MARGIN \\n[#DOC_L_MARGIN]u
.    LL       \\n[#DOC_L_LENGTH]u
.    HEADER_CENTER "\\*[$TOC_HEADER_STRING]
.    if \\n[#SLANT_ON] .nop \\*[SLANTX]
.    PAGENUM_STYLE \\*[$TOC_PN_STYLE]
.    PAGENUM_FAMILY \\*[$TOC_PN_FAM]
.    if r #TOC_PAGE_PARAMS .TOC_PAGE_PARAMS
.    ie \\n[#ADJ_TOC_LEAD] \{\
.       DOC_LEAD \\*[$TOC_LEAD] ADJUST
.       TRAPS
.    \}
.    el .DOC_LEAD \\*[$TOC_LEAD]
.    ie \\n[#TOC_HEADER_V_POS] \
.      DOCHEADER OFF \\n[#TOC_HEADER_V_POS]u-\\n[#DOC_LEAD]u 
.    el .DOCHEADER OFF \\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.    if (\\n[#PRINT_STYLE]=1)&(\\n[#SINGLE_SPACE]=1) \
.       DOCHEADER OFF \\n[#T_MARGIN]u-(\\n[#DOC_LEAD]u*2u)
.    START
.    PDF_BOOKMARK 1 \\*[$TOC_HEADER_STRING]
.    if \\n[#PRINT_STYLE]=1 .TYPEWRITER
.    if \\n[#PRINT_STYLE]=2 \{\
.       FAMILY \\*[$TOC_HEADER_FAM]
.       FT     \\*[$TOC_HEADER_FT]
.       ps \\n[#TOC_PS]u\\*[$TOC_HEADER_SIZE_CHANGE]
.       if \\n[#TOC_HEADER_COLOR]=1 \
.          COLOR \\*[$TOC_HEADER_COLOR]
.    \}
.    QUAD \\*[$TOC_HEADER_QUAD]
.    if \\n[#TOC_STRING_CAPS] .CAPS
.    if \\n[#TOC_STRING_SMALLCAPS] .SMALLCAPS
.    if \\n[#PRINT_STYLE]=1 \
.       UNDERSCORE 3p "\\*[$TOC_HEADER_STRING]"
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#TOC_HEADER_UNDERLINE] \{\
.          ds $TITLE_TYPE TOC_HEADER
.          ie \\n[#TOC_HEADER_UNDERLINE]=2 \
.             UNDERSCORE2 \\*[$TOC_UNDERLINE_GAP] \\*[$TOC_RULE_GAP] "\\*[$TOC_HEADER_STRING]"
.          el .UNDERSCORE "\\*[$TOC_HEADER_STRING]"
.       \}
.       el .PRINT \\*[$TOC_HEADER_STRING]
.    \}
.    SMALLCAPS OFF
.    CAPS OFF
.    if \\n[#TOC_HEADER_COLOR]=1 .gcolor
.    br
.    sp
.    SHIM_1
.    nf
.    TOC_ENTRIES
.    if \\n[#LINENUMBERS]=3 \{\
.       NUMBER_LINES RESUME
.       nr #LINENUMBERS 1
.       nn 1
.    \}
.    rr #TOC
.    rr #TOC_RV_SWITCH
.    pdfsync
.END
\#
\# ====================================================================
\#
\# +++COLUMNS+++
\#
\# COLUMNS
\# -------
\# *Arguments:
\#   <number of columns>  <width of gutters>
\# *Function:
\#   Creates registers associated with setting docs in columns.
\#   Calculates column line lengths and offsets
\# *Notes:
\#   COLUMNS, if used, s/b the last macro invoked before START.
\#
.MAC COLUMNS END
.    if \\n[#IGNORE_COLUMNS]=1 .return
.    nr #COLUMNS 1
.    nr #NUM_COLS \\$1
.    nr #GUTTER (\\$2)
.    nr #COL_L_LENGTH \\n[#L_LENGTH]-(\\n[#GUTTER]*(\\n[#NUM_COLS]-1))/\\n[#NUM_COLS]
.    nr #COL_TOTAL 0 \\n[#COL_L_LENGTH]+\\n[#GUTTER]
.    nr #COL_NUM 0 1
.    while !\\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.       nr #COL_\\n+[#COL_NUM]_L_MARGIN \\n[#L_MARGIN]+\\n[#COL_TOTAL]
.       nr #COL_TOTAL \\n+[#COL_TOTAL]
.    \}
.    if \\n[#NUM_COLS]=1 \
.       if !\\n[#COLLATE]=1 .MN_INIT
.    rr #COL_TOTAL
.    rr #COL_NUM
.END
\#
\# MARK COL V-POSITION AFTER DOCHEADER
\# -----------------------------------
\# *Arguments:
\#   none
\# *Function:
\#   Sets 1st page dc register.
\# *Notes:
\#   Only required if manual spacing, positive or negative, precedes
\#   start of columns on first page of doc.
\#
.MAC COL_MARK END
.    mk dc
.END
\#
\# NEXT COLUMN
\# -----------
\# *Arguments:
\#   <none>
\# *Function:
\#   Breaks current column and moves to next column.
\#   If current column is the last on the page, breaks
\#   to a new page.
\#
.MAC COL_NEXT END
.    if \\n[#COLUMNS] \{\
.       nr #COL_NEXT 1
.       vpt 0
.       if !'\\$1'internal' \
.          if dPDF.EXPORT \
.             if \\n[#FLEX_ACTIVE] \
.                if !\\n[#NO_FLEX] \
.                   if \\n[#COL_NUM]>1 \
.                      tm .ds page-\\n%@\\n[#COL_NUM] 1
.       ie '\\$0'COL_NEXT' .br
.       el \{\
.          brp
.          RLD 1v
.       \}
.       vpt
.       ie \\n[#COL_NUM]=\\n[#NUM_COLS] .NEWPAGE
.       el .FOOTER
.    \}
.END
\#
\# ====================================================================
\#
\# +++LISTS+++
\#
\# LIST
\# ----
\# *Arguments:
\#   [ BULLET | DASH | DIGIT | alpha | ALPHA | roman | ROMAN | USER ] \
\#   [ <separator> | NONE ] [ <prefix> ] [ <anything> ]
\# *Function:
\#   Stores indent information in effect prior to invocation and
\#   initializes a list with the supplied enumerator (and separator).
\# *Notes:
\#   Default enumerator is a bullet.
\#
\#   Enumerator *must* be supplied for every list that's to the
\#   right of another list, every time, unless the default bullet is
\#   desired.
\#
\#   <anything> moves back one list level intuitively, or exits lists
\#   completely if the level in which it's invoked is the first.
\#
.MAC LIST END
.    br
.    ds $1ST_LETTER \\$1
.    if !'\\*[$1ST_LETTER]'' .substring $1ST_LETTER 0 0
.    if '\\*[$1ST_LETTER]'r' .ds $1ST_LETTER R
.    ie '\\*[$1ST_LETTER]'R' \{\
.       if r #ROMAN_LIST .rr #ROMAN_LIST
.       if '\\$1'ROMAN'  .nr #ROMAN_LIST 1
.       if '\\$1'roman'  .nr #ROMAN_LIST 1
.       ds $LAST_CHAR \\$1
.       substring $LAST_CHAR -1
.       if !\B'\\*[$LAST_CHAR]' \{\
.          if !r #ROMAN_LIST \{\
.             LIST OFF
.             return
.          \}
.          tm1 "[mom]: You must append a number to the '\\$1' argument to \\$0.
.          tm1 "       The number should be the total number of items in this list.
.          tm1 "       See the documentation.
.          ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.       \}
.       ds $ROMAN_WIDTH \\$1
.          substring $ROMAN_WIDTH 1
.       while !\B'\\*[$ROMAN_WIDTH]' \{\
.          substring $ROMAN_WIDTH 1
.       \}
.       length #ROMAN_LENGTH \\*[$ROMAN_WIDTH]
.       ds $LIST_ARG_1 \\$1
.       substring $LIST_ARG_1 0 -(\\n[#ROMAN_LENGTH]+1)
.    \}
.    el .ds $LIST_ARG_1 \\$1
.    if !r#DEPTH \{\
.       if \\n[#INDENT_ACTIVE] \{\
.          nr #STORED_HL_INDENT \\n[#HL_INDENT]
.          nr #STORED_T_INDENT  \\n[#T_INDENT]
.          if \\n[#INDENT_STYLE_LEFT] \
.             nr #STORED_L_INDENT \\n[#L_INDENT]
.          if \\n[#INDENT_STYLE_RIGHT] \
.             nr #STORED_R_INDENT \\n[#R_INDENT]
.          if \\n[#INDENT_STYLE_BOTH] \{\
.             nr #STORED_BL_INDENT \\n[#BL_INDENT]
.             nr #STORED_BR_INDENT \\n[#BR_INDENT]
.          \}
.       \}
.       nr #CURRENT_L_LENGTH \\n[.l]
.       nr #DEPTH 0 1
.       if \\n[#INDENT_ACTIVE]=1 \{\
.          if \\n[#INDENT_LEFT_ACTIVE]=1 \
.             nr #RESTORE_PREV_INDENT 1
.          if \\n[#INDENT_BOTH_ACTIVE]=1 \{\
.             ie \\n[#DOC_TYPE]=5 .IBX CLEAR
.             el .IBX
.             nr #ORIG_L_LENGTH \\n[.l]
.             IB
.             nr #RESTORE_PREV_INDENT 2
.          \}
.          if \\n[#INDENT_RIGHT_ACTIVE]=1 \{\
.             ie \\n[#DOC_TYPE]=5 .IRX CLEAR
.             el .IRX
.             nr #ORIG_L_LENGTH \\n[.l]
.             IR
.             nr #RESTORE_PREV_INDENT 3
.             if \\n[#INDENT_LEFT_ACTIVE]=1 \
.                nr #RESTORE_PREV_INDENT 4
.          \}
.       \}
.    \}
.    ds pre-list-quad \\*[$QUAD_VALUE]
.    substring pre-list-quad 0 0
.    if '\\*[pre-list-quad]'C' \{\
.       if !'\\n[.z]'LIST*DIV' \{\
.          nr #PRE_LIST_QUAD \\n[.j]
.          nr #LIST_CENTER 1
.          if !'\\n[.z]'LIST*DIV' .di LIST*DIV
\!.        nr #IN_LIST 1
.          ad l
.       \}
.    \}
.    if '\\*[pre-list-quad]'R' \{\
.       if !'\\n[.z]'LIST*DIV' \{\
.          nr #PRE_LIST_QUAD \\n[.j]
.          nr #LIST_RIGHT 1
.          if !'\\n[.z]'LIST*DIV' .di LIST*DIV
\!.        nr #IN_LIST 1
.          ad l
.       \}
.    \}
.    ie \\n[#NUM_ARGS]=0 \{\
.       nr #ARGS_TO_LIST 1 \" So default behaves as if LIST BULLET
.       ds $ENUMERATOR\\n+[#DEPTH] \[bu]
.       ds $ENUMERATOR_TYPE\\n[#DEPTH] other
.       ds $SEPARATOR
.       ds $PREFIX
.       ds $SEPARATOR\\n[#DEPTH]
.       ds $PREFIX\\n[#DEPTH]
.    \}
.    el \{\
.       rr #ARGS_TO_LIST \" Clear this before processing arg 1.
.       if '\\*[$LIST_ARG_1]'DASH' \{\
.          nr #ARGS_TO_LIST 1
.          ds $ENUMERATOR\\n+[#DEPTH] \[en]
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] other
.          ds $SEPARATOR\\n[#DEPTH]
.          ds $PREFIX\\n[#DEPTH]
.       \}
.       if '\\*[$LIST_ARG_1]'BULLET' \{\
.          nr #ARGS_TO_LIST 1
.          ds $ENUMERATOR\\n+[#DEPTH] \[bu]
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] other
.          ds $SEPARATOR\\n[#DEPTH]
.          ds $PREFIX\\n[#DEPTH]
.       \}
.       if '\\*[$LIST_ARG_1]'DIGIT' \{\
.          nr #ARGS_TO_LIST 1
.          nr #ENUMERATOR\\n+[#DEPTH] 0 1
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] register
.          ds $SEPARATOR\\n[#DEPTH] .
.          ds $PREFIX\\n[#DEPTH]
.          if \\n[#NUM_ARGS]>=2 \{\
.             ie '\\$2'NONE' .ds $SEPARATOR\\n[#DEPTH]
.             el .ds $SEPARATOR\\n[#DEPTH] \\$2
.             if \\n[#NUM_ARGS]=3 .ds $PREFIX\\n[#DEPTH] \\$3
.          \}
.       \}
.       if '\\*[$LIST_ARG_1]'alpha' \{\
.          nr #ARGS_TO_LIST 1
.          nr #ENUMERATOR\\n+[#DEPTH] 0 1
.          af #ENUMERATOR\\n[#DEPTH] a
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] register
.          ds $SEPARATOR\\n[#DEPTH] )
.          ds $PREFIX\\n[#DEPTH]
.          if \\n[#NUM_ARGS]>=2 \{\
.             ie '\\$2'NONE' .ds $SEPARATOR\\n[#DEPTH]
.             el .ds $SEPARATOR\\n[#DEPTH] \\$2
.             if \\n[#NUM_ARGS]=3 .ds $PREFIX\\n[#DEPTH] \\$3
.          \}
.       \}
.       if '\\*[$LIST_ARG_1]'ALPHA' \{\
.          nr #ARGS_TO_LIST 1
.          nr #ENUMERATOR\\n+[#DEPTH] 0 1
.          af #ENUMERATOR\\n[#DEPTH] A
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] register
.          ds $SEPARATOR\\n[#DEPTH] )
.          ds $PREFIX\\n[#DEPTH]
.          if \\n[#NUM_ARGS]>=2 \{\
.             ie '\\$2'NONE' .ds $SEPARATOR\\n[#DEPTH]
.             el .ds $SEPARATOR\\n[#DEPTH] \\$2
.             if \\n[#NUM_ARGS]=3 \
.                ds $PREFIX\\n[#DEPTH] \\$3
.          \}
.       \}
.       if '\\*[$1ST_LETTER]'R' \{\
.          nr #ARGS_TO_LIST 1
.          nr #ENUMERATOR\\n+[#DEPTH] 0 1
.          if '\\*[$LIST_ARG_1]'roman' .af #ENUMERATOR\\n[#DEPTH] i
.          if '\\*[$LIST_ARG_1]'ROMAN' .af #ENUMERATOR\\n[#DEPTH] I
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] roman
.          ds $SEPARATOR\\n[#DEPTH] )
.          ds $PREFIX\\n[#DEPTH]
.          if \\n[#NUM_ARGS]>=2 \{\
.             ie '\\$2'NONE' .ds $SEPARATOR\\n[#DEPTH]
.             el .ds $SEPARATOR\\n[#DEPTH] \\$2
.             if \\n[#NUM_ARGS]=3 .ds $PREFIX\\n[#DEPTH] \\$3
.          \}
.       \}
.       if '\\*[$LIST_ARG_1]'USER' \{\
.          nr #ARGS_TO_LIST 1
.          ds $ENUMERATOR\\n+[#DEPTH] \\$2
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] other
.          ds $SEPARATOR\\n[#DEPTH]
.          ds $PREFIX\\n[#DEPTH]
.       \}
.       if '\\*[$LIST_ARG_1]'VARIABLE' \{\
.          if \\n[#NUM_ARGS]<2 \{\
.             tm1 "[mom]: You must follow the \\$1 argument to \\$0 with the widest
.             tm1 "       enumerator to be used.  See the documentation.
.             ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.          \}
.          nr #ARGS_TO_LIST 1
.          ds $ENUMERATOR\\n+[#DEPTH]
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] variable
.          ds $ENUMERATOR_WIDTH\\n[#DEPTH] \w'\\$2\ '
.          ds $SEPARATOR\\n[#DEPTH]
.          ds $PREFIX\\n[#DEPTH]
.       \}
.       if '\\*[$LIST_ARG_1]'PLAIN' \{\
.          nr #ARGS_TO_LIST 1
.          ds $ENUMERATOR\\n+[#DEPTH]
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] plain
.          ds $SEPARATOR\\n[#DEPTH]
.          ds $PREFIX\\n[#DEPTH]
.       \}
.       if \\n[#NUM_ARGS]=1 \{\
.          if !r#ARGS_TO_LIST \{\
.             ie \\n[#DEPTH]=1 \{\
.                ie \\n[#NEXT_DEPTH_BACK]=0 \{\
.                   SET_LIST_INDENT
.                   if \\n[#QUIT]=1 \{\
.                      QUIT_LISTS
.                      return
.                   \}
.                   return
.                \}
.                el \{\
.                   QUIT_LISTS
.                   return
.                \}
.             \}
.             el \{\
.                SET_LIST_INDENT
.                return
.             \}
.          \}
.       \}
.    \}
.    nr #TOTAL_LISTS \\n[#DEPTH]
.    if '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'register' \{\
.       nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]m\\*[$SEPARATOR\\n[#DEPTH]]\ '
.       if '\\*[$LIST_ARG_1]'ALPHA' .nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]M\\*[$SEPARATOR\\n[#DEPTH]]\ '
.    \}
.    if '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'roman' \
.       GET_ROMAN_INDENT
.    if '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'other' \
.       nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$ENUMERATOR\\n[#DEPTH]]\ '
.    if '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'variable' \
.       nr #LIST_INDENT\\n[#DEPTH] \\*[$ENUMERATOR_WIDTH\\n[#DEPTH]]
.    ll \\n[#CURRENT_L_LENGTH]u
.    ie \\n[#DEPTH]=1 \{\
.       ie \\n[#INDENT_ACTIVE]=1 \{\
.          if \\n[#INDENT_STYLE_LEFT]=1 \{\
.             if \\n[#L_INDENT_ILX] \{\
.                rr #L_INDENT 
.                rr #L_INDENT_ILX
.             \}
.             nr #L_INDENT \\n[#L_INDENT]+\\n[#LIST_INDENT\\n[#DEPTH]]
.             nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.             nr #LIST_INDENT\\n[#DEPTH] \\n[#L_INDENT]
.          \}
.          if \\n[#INDENT_BOTH_ACTIVE]=1 \{\
.             nr #L_INDENT \\n[#BL_INDENT]+\\n[#LIST_INDENT\\n[#DEPTH]]
.             nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.             nr #LIST_INDENT\\n[#DEPTH] \\n[#L_INDENT]
.          \}
.          if \\n[#INDENT_RIGHT_ACTIVE]=1 \{\
.             ie \\n[#INDENT_LEFT_ACTIVE]=1 \{\
.             \" Don't do anything; we already have a left indent
.             \}
.             el \{\
.                nr #L_INDENT +\\n[#LIST_INDENT\\n[#DEPTH]]
.                nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.             \}
.          \}
.       \}
.       el \{\
.          nr #L_INDENT +\\n[#LIST_INDENT\\n[#DEPTH]]
.          nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.       \}
.    \}
.    el \{\
.       nr #L_INDENT +\\n[#LIST_INDENT\\n[#DEPTH]]
.       nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.    \}
.END
\#
\# ITEM
\# ----
\# *Arguments:
\#   <none> | <space before item>
\# *Function:
\#   Prints enumerator for a given list depth and prepares mom to
\#   receive the text of an item.
\#
.MAC ITEM END
.    ie \\n[#NUM_ARGS]=2 .sp \\$2
.    el \
.       if \B'\\$1' .sp \\$1
.    if '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'plain' .nop 
.    if !r#DEPTH .return
.    if \\n[#LINENUMBERS]=1 \{\
.       NUMBER_LINES OFF
.       nr #LINENUMBERS 2
.    \}
.    if \\n[#KERN]=1 \{\
.       nr #KERN_WAS_ON 1
.       KERN OFF
.    \}
.    rr #IN_ITEM
.    IL
.    nr #IN_ITEM 1
.    ll \\n[#CURRENT_L_LENGTH]u \" Set ll again because IL turns IB off.
.    ie !'\\n[.z]'' \!.TRAP OFF
.    el .TRAP OFF
.    HI \\n[#HL_INDENT\\n[#DEPTH]]u
.    if '\\*[$SEPARATOR\\n[#DEPTH]]')' .nr #SEP_TYPE 1
.    if '\\*[$SEPARATOR\\n[#DEPTH]]']' .nr #SEP_TYPE 1
.    if '\\*[$SEPARATOR\\n[#DEPTH]]'}' .nr #SEP_TYPE 1
.    ie \\n[#IN_BIB_LIST]=1 \{\
.       ie \\n[#ENUMERATOR\\n[#DEPTH]]<9 \{\
.          ie \\n[#SEP_TYPE]=1 .PRINT \
\v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\
\\n+[#ENUMERATOR\\n[#DEPTH]]\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.          el .PRINT \
\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.       \}
.       el \{\
.          ie \\n[#SEP_TYPE]=1 .PRINT \
\h'-\w'\0'u'\v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\
\\n+[#ENUMERATOR\\n[#DEPTH]]\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.          el .PRINT \
\h'-\w'\0'u'\
\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.       \}
.    \}
.    el \{\
.       ie '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'register' \{\
.\" DIGIT
.          ie '\\g[#ENUMERATOR\\n[#DEPTH]]'0' \{\
.             ie \\n[#PAD_LIST_DIGITS\\n[#DEPTH]]=1 \{\
.                ie \\n[#ENUMERATOR\\n[#DEPTH]]<9 \{\
.                   ie \\n[#SEP_TYPE]=1 .PRINT \
\0\v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n+[#ENUMERATOR\\n[#DEPTH]]\
\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.                   el .PRINT \
\0\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.                \}
.                el \{\
.                   ie \\n[#SEP_TYPE]=1 .PRINT \
\v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n+[#ENUMERATOR\\n[#DEPTH]]\
\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.                   el .PRINT \
\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.                \}
.             \}
.             el \{\
.                ie \\n[#SEP_TYPE]=1 .PRINT \
\v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n+[#ENUMERATOR\\n[#DEPTH]]\
\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.                el .PRINT \
\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.             \}
.          \}
.          el \{\
.\" ALPHA
.             ie '\\g[#ENUMERATOR\\n[#DEPTH]]'A' \{\
.                ie \\n[#SEP_TYPE]=1 .PRINT \
\v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n+[#ENUMERATOR\\n[#DEPTH]]\
\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.                el .PRINT \
\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.             \}
.\" alpha
.             el .PRINT \
\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.          \}
.       \}
.       if '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'roman' \{\
.          ie \\n[#PAD_LIST_DIGITS\\n[#DEPTH]]=1 \{\
.\" ROMAN I, padded
.             ie '\\g[#ENUMERATOR\\n[#DEPTH]]'I' \{\
.                ie \\n[#SEP_TYPE]=1 .PRINT \
\h'\\n[#HL_INDENT\\n[#DEPTH]]u'\h'-\w'\\*[$PREFIX\\n[#DEPTH]]\
\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]\0'u'\
\v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n[#ENUMERATOR\\n[#DEPTH]]\
\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.                el .PRINT \
\h'\\n[#HL_INDENT\\n[#DEPTH]]u'\h'-\w'\\*[$PREFIX\\n[#DEPTH]]\
\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]\
\0'u'\\*[$PREFIX\\n[#DEPTH]]\\n[#ENUMERATOR\\n[#DEPTH]]\
\\*[$SEPARATOR\\n[#DEPTH]]
.             \}
.\" roman i, padded
.             el .PRINT \
\h'\\n[#HL_INDENT\\n[#DEPTH]]u'\h'-\w'\\*[$PREFIX\\n[#DEPTH]]\
\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]\0'u'\
\\*[$PREFIX\\n[#DEPTH]]\\n[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.          \}
.\" No pad
.          el \{\
.\" ROMAN I, no pad
.             ie '\\g[#ENUMERATOR\\n[#DEPTH]]'I' \{\
.                ie \\n[#SEP_TYPE]=1 .PRINT \
\v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n+[#ENUMERATOR\\n[#DEPTH]]\
\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.                el .PRINT \
\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.             \}
.\" roman i, no pad
.             el .PRINT \
\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.          \}
.       \}
.       if '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'other' \
.          PRINT \\*[$ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.       if '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'variable' \
.          PRINT  \\$1
.    \}
.    rr #SEP_TYPE
.    EOL
.    if \\n[#REF]=1 \{\
.       IL +\\n[#REF_BIB_INDENT]u
.       ti \\n[#L_INDENT]u-\\n[#REF_BIB_INDENT]u
.    \}
.    ie !'\\n[.z]'' \!.TRAP
.    el .TRAP
.    if \\n[#KERN_WAS_ON]=1 \{\
.       KERN
.       rr #KERN_WAS_ON
.    \}
.    if \\n[#LINENUMBERS]=2 \{\
.       NUMBER_LINES RESUME
.       nr #LINENUMBERS 1
.    \}
.END
\#
\# A utility macro that determines the space to reserve for
\# roman numeral enumerated lists.  Limit is 20 roman numerals
\# per list.  If this isn't enough, the user can add to the
\# macro.
\#
.MAC GET_ROMAN_INDENT END
.    if '\\*[$LIST_ARG_1]'roman' \{\
.       if '\\*[$ROMAN_WIDTH]'1' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 1
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]i\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'2' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 2
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]ii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'3' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 3
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]iii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'4' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 4
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]iii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'5' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 5
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]iii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'6' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 6
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]iii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'7' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 7
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]vii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'8' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 8
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]viii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'9' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 9
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]viii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'10' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 10
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]viii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'11' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 11
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]viii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'12' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 12
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]viii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'13' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 13
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]xiii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'14' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 14
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]xiii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'15' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 15
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]xiii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'16' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 16
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]xiii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'17' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 17
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]xvii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'18' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 18
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]xviii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'19' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 19
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]xviii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'20' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 20
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]xviii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.    \}
.    if '\\*[$LIST_ARG_1]'ROMAN' \{\
.       if '\\*[$ROMAN_WIDTH]'1' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 1
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]I\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'2' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 2
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]II\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'3' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 3
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]III\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'4' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 4
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]IV\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'5' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 5
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]IV\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'6' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 6
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]IV\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'7' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 7
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]VII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'8' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 8
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]VIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'9' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 9
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]VIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'10' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 10
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]VIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'11' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 11
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]VIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'12' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 12
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]VIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'13' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 13
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]XIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'14' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 14
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]XIV\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'15' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 15
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]XIV\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'16' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 16
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]XIV\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'17' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 17
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]XVII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'18' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 18
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]XVIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'19' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 19
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]XVIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'20' \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 20
.          nr #LIST_INDENT\\n[#DEPTH] \
\w'\\*[$PREFIX\\n[#DEPTH]]XVIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.    \}
.END
\#
\# SHIFT LIST
\# ----------
\# *Arguments:
\#   <amount by which to indent a list to the right>
\# *Function:
\#   Adds the value of the arg to the current list's indent.
\# *Notes:
\#   Requires a unit of measure.
\#
.MAC SHIFT_LIST END
.    nr #SHIFT_LIST\\n[#DEPTH] (\\$1)
.    nr #L_INDENT +\\n[#SHIFT_LIST\\n[#DEPTH]]
.END
\#
\# PAD LIST DIGITS
\# ---------------
\# *Arguments:
\#   [ LEFT ]
\# *Function:
\#   Adds a figure space to a list's hanging and left indent.  If
\#   LEFT is given, sets reg. #PAD_LIST_DIGITS to 1 for use in ITEM.
\#
.MAC PAD_LIST_DIGITS END
.    if '\\g[#ENUMERATOR\\n[#DEPTH]]'0' \{\
.       nr #LIST_INDENT\\n[#DEPTH] +\\w'\\0'
.       nr #L_INDENT \\n[#LIST_INDENT\\n[#DEPTH]]+\\n[#LIST_INDENT\\n-[#DEPTH]]
.       nr #HL_INDENT\\n+[#DEPTH] +\\w'\\n[#ENUMERATOR\\n[#DEPTH]]'
.       if '\\$1'LEFT' .nr #PAD_LIST_DIGITS\\n[#DEPTH] 1
.    \}
.    if '\\g[#ENUMERATOR\\n[#DEPTH]]'i' \
.       if '\\$1'LEFT' .nr #PAD_LIST_DIGITS\\n[#DEPTH] 1
.    if '\\g[#ENUMERATOR\\n[#DEPTH]]'I' \
.       if '\\$1'LEFT' .nr #PAD_LIST_DIGITS\\n[#DEPTH] 1
.END
\#
\# RESET LIST
\# ----------
\# *Arguments:
\#   none
\# *Function:
\#   Resets register enumerators to 1 or a.
\#
.MAC RESET_LIST END
.    ie '\\$1'' .nr #ENUMERATOR\\n[#DEPTH] 0 1
.    el .nr #ENUMERATOR\\n[#DEPTH] \\$1-1 1
.END
\#
\# QUIT LISTS
\# ----------
\# *Arguments:
\#   none
\# *Function:
\#   Exits lists cleanly and restores any indents that were in
\#   effect prior to LIST.
\#
.MAC QUIT_LISTS END
.   br
.   if '\\n[.z]'LIST*DIV' \{\
\!.    rr #IN_LIST
.      di
.   \}
.   IQ CLEAR
.   nr #HL_INDENT \\n[#STORED_HL_INDENT]
.   nr #T_INDENT  \\n[#STORED_T_INDENT]
.   nr #L_INDENT  \\n[#STORED_L_INDENT]
.   nr #R_INDENT \\n[#STORED_R_INDENT]
.   nr #BL_INDENT \\n[#STORED_BL_INDENT]
.   nr #BR_INDENT \\n[#STORED_BR_INDENT]
.   rr #STORED_HL_INDENT
.   if \\n[#LIST_CENTER] \
.      nr #LIST_OFFSET_VALUE \\n[.l]-\\n[dl]/2
.   if \\n[#LIST_RIGHT] \
.      nr #LIST_OFFSET_VALUE \\n[.l]-\\n[dl]
.   po +\\n[#LIST_OFFSET_VALUE]u
.   if \\n[.u] .nr #FILLED 1
.   nf
.   if dLIST*DIV \{\
.      LIST*DIV
.      rm LIST*DIV
.   \}
.   if \\n[#FILLED] .fi
.   if !\\n[#PRE_LIST_QUAD]=\\n[.j] .ad \\n[#PRE_LIST_QUAD]
.   rr #FILLED
.   po
.   rr #PRE_LIST_QUAD
.   if \\n[#RESTORE_PREV_INDENT]=1 \
.      IL
.   if \\n[#RESTORE_PREV_INDENT]=2 \{\
.      ll \\n[#ORIG_L_LENGTH]u
.      IB
.   \}
.   if \\n[#RESTORE_PREV_INDENT]=3 \{\
.      ll \\n[#ORIG_L_LENGTH]u
.      IR
.   \}
.   if \\n[#RESTORE_PREV_INDENT]=4 \{\
.      nr #R_INDENT \\n[#STORED_R_INDENT]
.      nr #L_INDENT \\n[#STORED_L_INDENT]
.      ll \\n[#ORIG_L_LENGTH]u
.      IR
.      IL
.   \}
.\" Clean up after exiting last depth of list
.   nr #REMOVE 0 1
.   while \\n+[#REMOVE]<=\\n[#TOTAL_LISTS] \{\
.      rr #LIST_INDENT\\n[#REMOVE]
.      rr #ENUMERATOR\\n[#REMOVE]
.      rm $ENUMERATOR\\n[#REMOVE]
.      rm $SEPARATOR\\n[#REMOVE]
.      rm $ENUMERATOR_TYPE\\n[#REMOVE]
.      rr #PAD_LIST_DIGITS\\n[#REMOVE]
.      rr #SHIFT_LIST\\n[#REMOVE]
.   \}
.   rr #STORED_L_INDENT
.   rr #STORED_BL_INDENT
.   rr #STORED_BR_INDENT
.   rr #STORED_R_INDENT
.   rr #STORED_R_INDENT
.   rr #REMOVE
.   rr #TOTAL_LISTS
.   rr #QUIT
.   rr #DEPTH
.   rr #NEXT_DEPTH_BACK
.   rr #RESTORE_PREV_INDENT
.   rr #ORIG_L_LENGTH
.   rr #CURRENT_L_LENGTH
.   rr #IN_ITEM
.   rr #IN_ITEM_L_INDENT
.END
\#
\# SET LIST INDENT
\# ---------------
\# *Arguments:
\#   none
\# *Function:
\#   Restores indent of prev. list in nested lists.  Also sets the
\#   #QUIT register if an invocation of LIST OFF applies to the first
\#   level of list.
\#
.MAC SET_LIST_INDENT END
.    nr #NEXT_DEPTH_BACK \\n[#DEPTH]-1
.    if \\n[#NEXT_DEPTH_BACK]=0 \{\
.       nr #QUIT 1
.       if \\n[#INDENT_ACTIVE]=1 \{\
.          if \\n[#INDENT_STYLE_BOTH]=1 \{\
.             ie \\n[#DOCS] \
.                ll \\n[#DOC_L_LENGTH]u-\\n[#STORED_BR_INDENT]u
.             el \
.                ll \\n[#L_LENGTH]u-\\n[#STORED_BR_INDENT]u
.             in \\n[#BL_INDENT]u
.          \}
.          if \\n[#INDENT_STYLE_LEFT] \{\
.             in \\n[#STORED_L_INDENT]u
.          \}
.          if \\n[#INDENT_STYLE_RIGHT] \{\
.             ie \\n[#DOCS] \
.                ll \\n[#DOC_L_LENGTH]u-\\n[#STORED_R_INDENT]u
.             el \
.                ll \\n[#L_LENGTH]u-\\n[#STORED_R_INDENT]u
.          \}
.       \}
.       return
.    \}
.    nr #L_INDENT -\\n[#LIST_INDENT\\n[#DEPTH]]+\\n[#SHIFT_LIST\\n[#DEPTH]]
.    nr #HL_INDENT \\n[#HL_INDENT\\n-[#DEPTH]]
.END
\#
\# ====================================================================
\#
\# +++DOCUMENT PROCESSING MISC AND SUPPORT MACROS+++
\#
\# COLLATE
\# -------
\# *Arguments:
\#   <none>
\# *Function:
\#   Turns headers off (if on) and saves header state, sets register
\#   #COLLATE to 1 (toggle), and breaks to a new page.
\# *Notes:
\#   COLLATE exists primarily to allow putting multiple chapters in
\#   a single file, although it can be used for any document type.  After
\#   COLLATE, any of the macros that normally precede START may be
\#   used, and should behave as expected.
\#
\#   N.B.--the START macro must be used after every COLLATE
\#
.MAC COLLATE END
.    if dPDF.EXPORT .tm .ds pre-collate-\\n% \\n%@\\n[#COL_NUM]
.    if \\n[defer] \{\
.       nr #BLANKPAGE_AFTER_DEFER 1
.       bp
.    \}
.    nr #HEADER_STATE \\n[#HEADERS_ON]
.    if (\\n[defer]=0)&(\\n[float*defer]=0) .HEADERS OFF
.    if \\n[#LINENUMBERS] \{\
.       NUMBER_LINES off
.       nr #LINENUMBERS 2
.    \}
.    if \\n[#BLANKPAGE] \{\
.       if \\n[nl]=\\n[#PAGE_TOP] \{\
.          nr #NO_NEWPAGE 1
.          RESTORE_SPACE
.       \}
.       rr #BLANKPAGE
.    \}
.    if \\n[defer] \
.       DO_FOOTER
.    EOL
.    ds $SAVED_DOC_FAM \\*[$DOC_FAM]
.    ds $SAVED_PP_FT   \\*[$PP_FT]
.    nr #COLLATE 1
.    nr #PRE_COLLATE 1
.    nr #POST_TOP 1
.    nr #HEAD_1_NUM 0 1
.    if !\\n[#LISTS] \{\
.       if \\n[eqn*label-with-chapter]=1     .nr eqn*label-num 0 1
.       if \\n[float*label-with-chapter]=1   .nr fig*label-num 0 1
.       if \\n[pdf-img*label-with-chapter]=1 .nr fig*label-num 0 1
.       if \\n[pic*label-with-chapter]=1     .nr fig*label-num 0 1
.       if \\n[tbl*label-with-chapter]=1     .nr tbl*label-num 0 1
.    \}
.    if \\n[#DOC_HEADER]=2 .nr #DOC_HEADER 1
.    if \\n[#PAGE_NUM_V_POS]=1 \{\
.       nr #PAGINATION_STATE \\n[#PAGINATE]
.       PAGINATION OFF
.    \}
.    IQ CLEAR
.    TQ
.    LL \\n[#DOC_L_LENGTH]u
.    QUAD \\*[$DOC_QUAD]
.    nr #SAVED_DOC_LEAD \\n[#DOC_LEAD]
.    nr #COLLATED_DOC 1
.    vs \\n[#DOC_LEAD]u
\*[SLANTX]
\*[CONDX]
\*[EXTX]
.    if \\n[#TOC] \{\
.       if \\n[TOC_BH]=1 .pdfswitchtopage before MOM:TOC
.       if \\n[TOC_BH]=2 .pdfswitchtopage after MOM:TOC
.    \}
.    if !\\n[#NO_NEWPAGE] .NEWPAGE
.    if !\\n[#TOC] \{\
.       if \\n[#FORCE_RECTO] \{\
.          ds $PN_FORMAT_CURR \\g[#PAGENUMBER]
.          af #PAGENUMBER 1
.          if \\n[#PAGENUMBER]%2=1 .nr #ODD_PAGENUM 1
.          af #PAGENUMBER \\*[$PN_FORMAT_CURR]
.          if \\n[#ODD_PAGENUM] .BLANKPAGE 1 DIVIDER
.          rr #ODD_PAGENUM
.          rr #BLANKPAGE_AFTER_DEFER
.       \}
.    \}
.    rr #NO_NEWPAGE
.    ch RR_@TOP
.    rr @TOP
.    if \\n[.ns] \{\
.      rs
.      nop \&
.    \}
.    if '\\n[.ev]'PAGE_TRANSITION\\n[pg-trans]' .ev
.    if \\n[#DEFER_PAGINATION] .PAGINATE
.    if !'\\*[$RESTORE_PAGENUM_STYLE]'' \{\
.       PAGENUM_STYLE \\*[$RESTORE_PAGENUM_STYLE]
.       rm $RESTORE_PAGENUM_STYLE
.    \}
.    if \\n[#CH_NUM] \
.       if \\n[#TOC]=0 .nr #CH_NUM +1
.    rm $EN_TITLE
.    COVERTITLE
.    DOC_COVERTITLE
.    TITLE
.    CHAPTER
.    CHAPTER_TITLE
.    SUBTITLE
.    MISC
.    rr #COVER_TITLE
.    rr #DOC_COVER_TITLE
.    rr #MISC
.    rr #COVER_MISC
.    rr #DOC_COVER_MISC
.    rr #COPYRIGHT
.    rr #COVER_COPYRIGHT
.    rr #DOC_COVER_COPYRIGHT
.    rr #COVER_AUTHOR
.    rr #DOC_COVER_AUTHOR
.    rm COVER_TEXT
.    rm DOC_COVER_TEXT
.    rm $COPYRIGHT
.    rm $COVER_COPYRIGHT
.    rm $DOC_COVER_COPYRIGHT
.    rr #END_QUOTE
.    rr #PAGENUM_STYLE_SET
.    rr #DOC_COVER
.    rr #COVER
.    rr #LAST_LEVEL
.    rr #LEVEL
.    if \\n[#RESTORE_PN_V_POS] \{\
.       nr #PAGE_NUM_V_POS \\n[#RESTORE_PN_V_POS]
.       rr #RESTORE_PN_V_POS
.    \}
.    nr #LOOP 0 1
.    while \\n+[#LOOP]<=\\n[@LEVEL] \
.       rr #TOC_HEAD_\\n[#LOOP]_INDENT_SET 1
.    if \\n[#FLEX_ACTIVE] .rr #NO_FLEX
.END
\#
\# NUMBER_LINES
\# ------------
\# *Arguments:
\#   <starting line number> [ <increment> [ <gutter> ] ]
\#   or
\#   <anything> | RESUME
\# *Function:
\#   Begin, suspend/turn off, or resume numbering of output lines.
\#
.MAC NUMBER_LINES END
.    br
.    if '\\n[.z]'EPI_TEXT' .return
.    if '\\$1'' \{\
.       tm1 "[mom]: NUMBER_LINES at line \\n[.c] has no argument.
.       tm1 "       You have forgotten to give a starting line number or 'RESUME'.
.       ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.    \}
.    if !\\n[#LINENUMBERS]=2 .nr #LINENUMBERS 1
.\" Test whether the first arg is a digit.
.    if \B'\\$1' \{\
.       if \\n[#QUOTE] \{\
.          if \\n[#QUOTE]=1 .ds macro QUOTE
.          if \\n[#QUOTE]=2 .ds macro BLOCKQUOTE
.          tm1 "[mom]: \\$0 at line \\n[.c] may not be used inside \\*[macro].
.          tm1 "       Please set NUMBER_LINES before \\*[macro], followed by
.          tm1 "       NUMBER_\\*[macro]_LINES.
.          ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.       \}
.       nr #LN \\$1
.       ds $LN_NUM \\$1
.       if !'\\n[.z]'' .nr #RESTORE_LN_NUM 1
.       ie '\\$2'' \
.          if '\\*[$LN_INC]'' .ds $LN_INC 1
.       el .ds $LN_INC \\$2
.       ie '\\$3'' \
.          if !\\n[#LN_GUTTER] .nr #LN_GUTTER 2
.       el .nr #LN_GUTTER \\$3
.    \}
.    ie !\\n[#LN] \{\
.\" In other words, the first arg was not a digit.
.       rr #LN
.       ie '\\$1'RESUME' \{\
.          LN_PARAMS
.          nm \\*[$LN_NUM]
.          RESTORE_PARAMS
.       \}
.       el \{\
.          nm
.\"  Register ln is still set and may confuse preprocessors like tbl.
.\"  Still, resuming line numbering must be possible, so save ln in
.\"  $LN_NUM
.          ds $LN_NUM \\n[ln]
.          if !\\n[#QUOTE] .nr ln 0
.          if !\\n[#LINENUMBERS]=2 .rr #LINENUMBERS
.       \}
.    \}
.    el \{\
.       LN_PARAMS
.       nm \\*[$LN_NUM] \\*[$LN_INC] \\n[#LN_GUTTER] -3-\\n[#LN_GUTTER]
.       RESTORE_PARAMS
.       if !'\\n[.z]'' .nr #DIVER_LN_OFF 1
.    \}
.    rr #LN
.END
\#
\# LINENUMBER STYLE PARAMETERS
\# ---------------------------
\# *Arguments:
\#   none
\# *Function:
\#   LN_PARAMS sets parameters for line numbers.
\#   RESTORE_PARAMS restores them after internal calls to .nm
\# *Notes:
\#   It's not documented, but groff's linenumbering is processed
\#   in a unique environment reserved for the numbers, such that
\#   whatever style params were in effect prior to the invocation
\#   of .nm remain in effect for the numbers even if the running
\#   text has different params.  Eg, If you set .gcolor to 'purple'
\#   before .nm then set it back to what it was, the numbers will be
\#   purple while the text remains at the default color.
\#
.MAC LN_PARAMS END
.    ie d$LN_FAM .fam \\*[$LN_FAM]
.    el .fam \\n[.fam]
.    ie d$LN_FT .ft \\*[$LN_FT]
.    el .ft \\n[.sty]
.    ie d$LN_SIZE_CHANGE .ps \\*[$LN_SIZE_CHANGE]
.    el .ps \\n[.s]
.    ie d$LN_COLOR .COLOR \\*[$LN_COLOR]
.    el .gcolor \\n[.m]
.END
\#
.MAC RESTORE_PARAMS END
.    fam
.    ft
.    ps
.    gcolor
.END
\#
\# Whether, at COLLATE, to reset line number to 1.
\#
\# NUMBER LINES PER SECTION
\# ------------------------
\# *Argument:
\#   none
\# *Function:
\#   Sets register that determines whether, at COLLATE, to reset
\#   line number to 1.
\# *Notes:
\#   The default is to continue the line numbering from where it
\#   left off.
\#
.MAC NUMBER_LINES_PER_SECTION END
.    nr #PER_SECTION 1
.END
\#
\# NUMBER QUOTE AND BLOCKQUOTE LINES AS PART OF RUNNING TEXT
\# ---------------------------------------------------------
\# *Argument:
\#   <gutter> | <anything>
\# *Function:
\#   Sets #(B)QUOTE_LN to 1 if no argument, or a single numeric
\#   argument, is given; otherwise, turns (BLOCK)QUOTE linenumbering
\#   off.
\# *Notes:
\#   #(B)QUOTE is checked for in QUOTE and BLOCKQUOTE.
\#   The single numeric argument allows establishing a different gutter from
\#   the one used for line numbers in running text.
\#
.MAC NUMBER_QUOTE_LINES END
.    ie \\n[#NUM_ARGS]=0 .nr #QUOTE_LN 1
.    el \{\
.       ie \B'\\$1' \{\
.          nr #QUOTE_LN 1
.          nr #Q_LN_GUTTER \\$1
.       \}
.       el \{\
.          ie '\\$1'SILENT' .nr #SILENT_QUOTE_LN 1
.          el \{\
.             rr #QUOTE_LN
.             rr #SILENT_QUOTE_LN
.          \}
.       \}
.    \}
.END
\#
.MAC NUMBER_BLOCKQUOTE_LINES END
.    ie \\n[#NUM_ARGS]=0 .nr #BQUOTE_LN 1
.    el \{\
.       ie \B'\\$1' \{\
.          nr #BQUOTE_LN 1
.          nr #BQ_LN_GUTTER \\$1
.       \}
.       el \{\
.          ie '\\$1'SILENT' .nr #SILENT_BQUOTE_LN 1
.          el \{\
.             rr #BQUOTE_LN
.             rr #SILENT_BQUOTE_LN
.          \}
.       \}
.    \}
.END
\#
\# OUTPUT BLANK PAGES
\# ------------------
\# *Argument:
\#   <number of blank pages to output> [ DIVIDER [ NULL ] ]
\# *Function:
\#   Outputs blank pages.
\# *Notes:
\#   If recto/verso, each page is recto/verso, even if there's
\#   nothing on it.
\#
\#   The 1st argument to BLANKPAGE is non-optional.  DIVIDER is for
\#   blank pages before endnotes, bibliographies, tocs, new chapters.
\#
.MAC BLANKPAGE END
.    nr #BLANKPAGE 1
.    nr #HOW_MANY \\$1
.    shift
.    nr #PAGES 0 1
.    if \\n[#LINENUMBERS] \{\
.       nr #LINENUMBERS_WERE_ON 1
.       NUMBER_LINES OFF
.    \}
.    while \\n+[#PAGES]<=\\n[#HOW_MANY] \{\
.       if \\n[#HEADERS_ON]=1 \{\
.          nr #HEADERS_WERE_ON 1
.          HEADERS OFF
.       \}
.       if \\n[#PAGE_NUM_V_POS]=1 \{\
.          if \\n[#PAGINATE]=1 .nr #PAGINATE_WAS_ON 1
.          nr #RESTORE_PN_V_POS \\n[#PAGE_NUM_V_POS]
.          PAGINATION OFF
.       \}
.       NEWPAGE \" Break to blank page
.       nop \&
.       br
.       if \\n[#FOOTERS_ON]=1 \{\
.          nr #FOOTERS_WERE_ON 1
.          FOOTERS OFF
.       \}
.       if \\n[#PAGE_NUM_V_POS]=2 \{\
.          if \\n[#PAGINATE]=1 .nr #PAGINATE_WAS_ON 1
.          nr #RESTORE_PN_V_POS \\n[#PAGE_NUM_V_POS]
.          PAGINATION OFF
.       \}
.       if !'\\$1'DIVIDER' .if \\n[#HEADERS_WERE_ON] .HEADERS
.    \}
.    NEWPAGE
.    ie '\\$1'DIVIDER' \{\
.       nop \&
.       if \\n[#BLANKPAGE_AFTER_DEFER] .bp
.       if \\n[#FOOTERS_WERE_ON] .FOOTERS
.          if \\n[#RESTORE_PN_V_POS] \{\
.             if \\n[#PAGINATE_WAS_ON] .PAGINATE
.             nr #PAGE_NUM_V_POS \\n[#RESTORE_PN_V_POS]
.          \}
.       if \\n[#HEADERS_WERE_ON] .HEADERS
.       shift
.       if '\\$1'NULL' .nr #PAGE_NUM_ADJ -\\n[#HOW_MANY]
.    \}
.    el \{\
.       if '\\$1'' \{\
.          if \\n[#FOOTERS_WERE_ON] .FOOTERS
.          if \\n[#RESTORE_PN_V_POS] \{\
.             if \\n[#PAGINATE_WAS_ON] .PAGINATE
.             nr #PAGE_NUM_V_POS \\n[#RESTORE_PN_V_POS]
.          \}
.       \}
.       if '\\$1'NULL' \{\
.          if \\n[#FOOTERS_WERE_ON] .FOOTERS
.          if \\n[#PAGE_NUM_V_POS]=2 \
.             if \\n[#PAGINATE_WAS_ON] .PAGINATE
.       \}
.    \}
.    if \\n[#PAGINATE]=1 \
.       if '\\$1'NULL' .nr #PAGE_NUM_ADJ -\\n[#HOW_MANY]
.       if \\n[#RESTORE_PN_V_POS]=1 \{\
.          RESTORE_SPACE
.          sp |\\n[#HEADER_MARGIN]u
.          PRINT_PAGE_NUMBER
.       \}
.    if \\n[#LINENUMBERS_WERE_ON] .NUMBER_LINES RESUME
.    rr #HOW_MANY
.    rr #HEADERS_WERE_ON
.    rr #FOOTERS_WERE_ON
.    rr #PAGINATE_WAS_ON
.END
\#
\# FLOATS
\# ------
\#
.am PSPIC \" Need to do this for PSPIC inside a float
.  vpt 0
\h'(\\n[ps-offset]u + \\n[ps-deswid]u)'
.  sp -1
.  vpt
..
\#
.MAC PROCESS_FLOATS END
.    if \\n[#TAB_ACTIVE] \{\
.       nr #RESTORE_TAB 1
.       TQ
.    \}
.    if !\\n[tbl*no-top-hook] .tbl@top-hook
.    rr tbl*no-top-hook
.    sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.    nr defer-count \\n[defer]
.    nr #TMP_PAGE_OFFSET \\n[.o]
.    po \\n[#L_MARGIN]u
.    ev protect
.    evc FLOAT
.    nf
.    RESTORE_SPACE
.    if '\\*[float*type:\\n[defer]]'boxed-tbl:\\n[defer]' \{\
.       ch RR_@TOP
.\" Get depth of the first deferred float when there's more than one.
.       if (\\n[.t] >= 1)&(\\n[float-depth:\\n[defer]] > (\\n[.t]+\\n[#DOC_LEAD])) \
.          tbl*float-warning
.       if \\n[#MLA] .sp \\n[tbl*label-lead-diff]u
.       if (\\n[tbl*have-caption:\\n[defer]]=1)&(\\n[tbl*caption-after-label]=0) \
.          sp \\n[tbl*caption-lead-diff]u
.       if \\n[tbl*caption-after-label] \
.          sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.    \}
.    if \\n[float*pic:1] \{\
.       if (\\n[pic*have-caption]=1)&(\\n[pic*caption-after-label]=0) \{\
.          ie \\n[#COLUMNS] \
.             sp |\\n[dc]u+\\n[pic*caption-lead-diff]u
.          el .sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u+\\n[pic*caption-lead-diff]u
.       \}
.       rr pic*caption-lead-diff
.       rr pic*top-lead-diff
.       rr float*pic
.    \}
.    if \\n[float*img] \{\
.       ie \\n[#COLUMNS] \
.          sp |\\n[dc]u
.       el \
.          sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.       if \\n[pdf-img:frame] \{\
.          sp -(\\*[pdf-img:frame-weight]p*2u)
.          rr pdf-img:frame
.       \}
.    \}
.    nr loop-count  0 1
.    nr new-defer   0 1
.    while \\n+[loop-count]<=\\n[defer-count] \{\
.       nr tbl*no-top-hook 1
.       rnn defer float*defer \" So '.if \n[defer]' is skipped during float output
.       vpt
.       ch RR_@TOP
.       rr @TOP
.       if \\n[pdf-img*have-caption] \
.          if !\\n[pdf-img*caption-after-label] .sp -.5v
.       rr pdf-img*have-caption
.       rr pic*have-caption
.       if '\\*[float*type:\\n[loop-count]]'table:\\n[loop-count]' \{\
.          ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.          ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u
.       \}
.       ie !\\n[float-span:\\n[loop-count]] \{\
.          ie ((\\n[float-depth:\\n[loop-count]]-\\n[.v])>\\n[.t]):(\\n[D-float:\\n[loop-count]]>\\n[.t]) \{\
.\" Insufficient space, defer to next page
.             rn FLOAT*DIV:\\n[loop-count] NEW*FLOAT*DIV:\\n+[new-defer]
.             rnn float-depth:\\n[loop-count] new-float-depth:\\n[new-defer]
.             rnn D-float:\\n[loop-count] new-D-float:\\n[new-defer]
.          \}
.          el \{\
.             output-float
.             ie (\\n[.t]-1)<(\\n[#DOC_LEAD]u/2) .SHIM_1
.             el .sp .5
.          \}
.       \}
.       el \{\
.          rr tbl*no-top-hook
.          if \\n[float-span:\\n[loop-count]] \
.             rn tbl*header-div:\\n[loop-count] tbl*header-div:span
.          output-float
.          sp .5
.       \}
.       if !\\n[loop-count]=\\n[defer-count] .rr flexed
.       rr float-span:\\n[loop-count]
.       rr float*tbl:\\n[loop-count]
.       rr tbl*have-caption:\\n[loop-count]
.       rr float*tbl*center:\\n[loop-count]
.       rr tbl*have-header:\\n[loop-count]
.       rm float*div:\\n[loop-count]
.       rr float-depth:\\n[loop-count]
.       rm tbl*header-div:\\n[loop-count]
.       rm float*type:\\n[loop-count]
.    \}
.    if !\\n[float*defer]=1 \{\
.       if !(\\n[loop-count]-1)=1 \{\
.          if !\\n[.t]=1 .sp -.5
.       \}
.    \}
.    if !\\n[@no-shim] \
.       if !\\n[q-float] \
.          if !\\n[#NO_SHIM] .SHIM
.\" FLOAT arrays are empty now
.\" Rename new arrays (FLOATs deferred to next page) to proper names
.    rr float*defer
.    rnn new-defer defer
.    nr loop-count 0 1
.    while \\n+[loop-count]<=\\n[defer] \{\
.       rn NEW*FLOAT*DIV:\\n[loop-count] FLOAT*DIV:\\n[loop-count]
.       rnn new-float-depth:\\n[loop-count] float-depth:\\n[loop-count]
.       rnn new-D-float:\\n[loop-count] D-float:\\n[loop-count]
.    \}
.    if !\\n[#TMP_PAGE_OFFSET]=\\n[.o] .po \\n[#TMP_PAGE_OFFSET]u
.    rr #TMP_PAGE_OFFSET
.    ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.    ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u
.    if !\\n[.t]=1 .if \\n[.t]<\\n[.v] .bp
.    ie !\\n[#NO_SHIM] .SHIM
.    el \{\
.       if !\\n[#NO_FLEX] \
.          if !\\n[flexed] .FLEX 
.    \}
.    if !\\n[#NO_SHIM] \
.       if \\n[#SHIM]>(\\n[#DOC_LEAD]-(\\n[#DOC_LEAD]/4)) \
'             sp -\\n[#DOC_LEAD]u
.    ie !\\n[flex:force] .ns
.    el \{\
.       rr flex:force
.       if !\\n[#NO_FLEX] .FLEX
.    \}
.    nr tbl*have-header 0
.    rr tbl*have-caption
.    rr loop-count
.    rr defer-count
.    rr float*before-shim
.    rr float*after-shim
.    rm float-adj
.    rr check-indent
.    if \\n[#NEWPAGE] \{\
.       vpt
'       bp
.       rr #NEWPAGE
.    \}
.    rr float*img
.    rr float*eqn
.    rr float*tbl
.    rr float*pic
.    if \\n[#RESTORE_TAB] \{\
.       TAB \\n[#CURRENT_TAB]
.       rr #RESTORE_TAB
.    \}
.END
\#
.MAC output-float END
.    if \\n[float*img] \{\
.       nr no-top-space:1 1
.    \}
.    vpt 0
.    if \\n[.ns] \{\
.       rs
.       nop \&
.       sp -1
.    \}
.    if \\n[no-top-space:1] \{\
.       ie !\\n[#COLUMNS] \{\
.          sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.          ns
.       \}
.       el .sp |\\n[dc]u
.       if \\n[float*tbl:1] \{\
.          RESTORE_SPACE
.          ie \\n[tbl*caption-top-lead-diff] \{\
.             sp \\n[tbl*caption-top-lead-diff]u
.             rr tbl*caption-top-lead-diff
.          \}
.          el \{\
.             if '\\*[float*type:1]'boxed-tbl:1' \{\
.                ie (\\n[tbl*have-caption]=1)&(\\n[tbl*caption-after-label]=0) .sp .3n
.                el .sp (\\n[#DOC_LEAD]u/2u)+.3n
.             \}
.          \}
.          rr float*tbl:1
.       \}
.       if \\n[float*img:1] \{\
.          RESTORE_SPACE
.          if \\n[pdf-img*caption-top-lead-diff] \{\
.             sp \\n[pdf-img*caption-top-lead-diff]u
.             rr float*img:1
.             rr pdf-img*caption-top-lead-diff
.          \}
.       \}
.    \}
.    if \\n[float*pic] \{\
.       nr pic*top-space-adj \\n[#DOC_LEAD]-\\n[pic@text-lead]
.       if (\\n[pic*have-caption]=0):(\\n[pic*caption-after-label]=1) \
.          sp \\n[pic*top-space-adj]u
.       if \\n[#COLUMNS] \
.          if !'\\*[pic*space-adj:\\n[loop-count]]'' \
.             sp \\*[pic*space-adj:\\n[loop-count]]
.    \}
.    nf
.    if \\n[q-float] \
.       if !\\n[has-caption] .sp \\n[#Q_LEAD_DIFF]u
.    ns
.    vpt
.    if \\n[check-indent] \{\
.       if \\n[#INDENT_LEFT_ACTIVE] \{\
.          in \\n[#L_INDENT]u/2u
.       \}
.    \}
.    rr no-top-space:1
.    if \\n[loop-count]>1 \{\
.       if !'\\*[float-adj:\\n[loop-count]]'' \{\
.          rs
.          sp \\*[float-adj:\\n[loop-count]]
.          ns
.          nr restore-v-pos 1
.       \}
.    \}
.    nr check-indent 1
.    FLOAT*DIV:\\n[loop-count]
.    if \\n[no-top-space:1] \
.       RESTORE_SPACE
.    if \\n[restore-v-pos] \{\
.       sp -\\*[float-adj:\\n[loop-count]]
.       rm float-adj:\\n[loop-count]
.       rr restore-v-pos
.    \}
.    if \\n[#COLUMNS] \
.       if !'\\*[pic*space-adj:\\n[loop-count]]'' .sp -\\*[pic*space-adj:\\n[loop-count]]
.    rm pic*space-adj:\\n[loop-count]
.    if \\n[D-float:1] \
.       rr D-float:1
.    rr D-float
.    rr @no-shim
.    rr q-float
.    rm B_QUOTE
.    rm P_QUOTE
.END
\#
\# FLOAT
\# -----
\# *Arguments:
\#   [ ADJUST +|-<amount> ] [ FORCE] [ SPAN] [ NO_SHIM] | [ NO_FLEX ] [ TARGET ] | <anything>
\# *Function:
\#   Captures input in a diversion, which is output immediately if
\#   there's room on the page; otherwise outputs diversion at top of
\#   next page.
\# *Notes:
\#   ADJUST allows for raising or lowering the contents of
\#   the diversion within the space allotted.  FORCE breaks to
\#   a new page immediately.
\#
.MAC FLOAT END
.    if \\n[#NUM_ARGS]>0 \{\
.       nr loop-count 0 1
.       nr loop-counter \\n[#NUM_ARGS]
.       while \\n+[loop-count]<=\\n[loop-counter] \{\
.          if '\\$1'FORCE' \{\
.             nr #FORCE 1
.             shift
.          \}
.          if '\\$1'SPAN' \{\
.              nr float-span 1
.              shift
.          \}
.          if '\\$1'ADJUST' \{\
.             shift
.             ds float-adj \\$1
.             shift
.          \}
.          if '\\$1'CENTER' \{\
.             nr center-float 1
.             shift
.          \}
.          if '\\$1'CENTRE' \{\
.             nr center-float 1
.             shift
.          \}
.          if '\\$1'INDENT' \{\
.             shift
.             nr indent-float \\$1
.             shift
.          \}
.          if '\\$1'RIGHT' \{\
.             nr right-float 1
.             shift
.          \}
.          if '\\$1'NO_SHIM' \{\
.             nr @no-shim 1
.             shift
.          \}
.          if '\\$1'NO_FLEX' \{\
.             nr @no-flex 1
.             shift 1
.          \}
.          if '\\$1'TARGET' \{\
.             shift
.             ds float*target "\\$1
.             shift 1
.          \}
.       \}
.    \}
.    ie \\n[float*started] .rr float*started
.    el \{\
.       while !'\\$1'' .shift 1
.       nr float*started 1
.    \}
.    ie '\\$1'' \{\
.\" Harmonize floats treated as defers and floats proper to the top
.\" of the next page between passes when flex is enabled.
.\"
.\" Without this, floats near the bottom of the page may be deferred
.\" on the first pass, but when flex-spacing moves the line just
.\" before the float to the bottom of the page, the upcoming .br
.\" causes the float to be proper to the next page instead of
.\" deferred to it.
.       nr floatnum +1
.       ie !\\n[#NO_FLEX] \{\
.\" Only on 2nd pass
.          if !dPDF.EXPORT \{\
.             ie d float\\n[floatnum]:no-defer .br
.             el \{\
.\" .v in the following is arbitrary.  Groff rounds down decimal
.\" fractions so flex-spacing may be slightly short.  Since there
.\" are no conditions under which a .t-1 (bottom margin) < .v
.\" on the 1st pass doesn't cause a float to be deferred, all floats
.\" on the second pass that meet the condition are also, correctly,
.\" deferred.
.                if (\\n[.t]-1)<\\n[.v] \
.                   if !\\n[@TOP] .nr no-break 1
.             \}
.          \}
.\" Only on 1st pass
.          ie !\\n[no-break] \{\
.             ds pre-float:page@col \\n%@\\n[#COL_NUM]
.             br
.             ds post-float:page@col \\n%@\\n[#COL_NUM]
.             if dPDF.EXPORT \{\
.                if !'\\*[pre-float:page@col]'\\*[post-float:page@col]' \
.                   tm .ds float\\n[floatnum]:no-defer 1
.             \}
.          \}
.          el .rr no-break
.       \}
.       el .br
.       if \\n[nl]=\\n[#PAGE_TOP] \
.          RESTORE_SPACE
.       ds ev-pre-float \\n[.ev]
.       ev FLOAT
.       evc \\*[ev-pre-float]
.       di FLOAT*DIV
.       if !'\\*[float*target]'' .PDF_TARGET "\\*[float*target]
.       rm float*target
.       nf
.    \}
.    el \{\
.       br
.\" So @no-shim persists if float output with output-float
.       if r @no-shim .nr float*no-shim 1
.       if \\n[float-span] \{\
.          nr span 1
\!.        rr span
.       \}
\!.     rm tbl*header-div:span
\!.     nr tbl*no-print-header 1
.       di
.       if \\n[float-span] \{\
.          nr dn-save \\n[dn]
.          da FLOAT*DIV
\!.        rr float-span
.          da
.          nr dn \\n[dn-save]
.          rr dn-save
.       \}
.       ie \\n[float*tbl] \
.          if !\\n[tbl*have-header] .ev 0
.       el .ev 0
.       if \\n[tbl*boxed] \{\
.          ch FOOTER \\n[#VARIABLE_FOOTER_POS]u+\\n[#DOC_LEAD]u
.          ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u+\\n[#DOC_LEAD]u
.          ie !\\n[#MLA] \{\
.             ie (\\n[tbl@label]=1):(\\n[tbl@source]=1):(\\n[tbl*autolabel]=1) .nr dn -.65v
.             el .nr dn +.65v
.             rr tbl@label
.             rr tbl@source
.          \}
.          el .if !\\n[tbl@source] .nr dn -1.65v
.       \}
.\" Defer float
.       if (\\n[dn]>\\n[.t]):(\\n[D-float]>\\n[.t]):(\\n[defer]>0) \{\
.          if !\\n[float-span] \{\
.             if (\\n[dn]+(\\n[.v]*2)>(\\n[.p]-\\n[#TOP_MARGIN]-\\n[#DOC_LEAD]-\\n[#B_MARGIN])) \{\
.                tm1 "[mom]: Floated element exceeds page depth.
.                ab   [mom]: Aborting '\\n[.F]' at line \\n[.c].
.             \}
.          \}
.\" Save depth of diversion here.  The .da zeroes it.
.          nr dn-save \\n[dn]
.          if \\n[#FLEX_ACTIVE] \{\
.             if !\\n[@no-flex] \{\
.                da FLOAT*DIV
\!.              FLEX
\!.              nr flexed 1
.                da
.             \}
.          \}
.          nr dn \\n[dn-save]
.          rr dn-save
.          ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.          ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u
.          ev 0
.          ie \\n[@TOP] \{\
.             br
.             if \\n[tbl*boxed] .rs
.             rr tbl*boxed
.          \}
.          el \{\
.             if !\\n[defer] .nr defer 0 1
.             rn FLOAT*DIV FLOAT*DIV:\\n+[defer]
.             if !'\\*[float-adj]'' \
.                rn float-adj float-adj:\\n[defer]
.             if \\n[float-span] \
.                if !\\n[tbl*boxed] .rnn float-span float-span:\\n[defer]
.             if \\n[float*tbl] \{\
.                if \\n[defer]>0 \{\
.                   nr no-top-space:\\n[defer] 1
.                   nr float*tbl:\\n[defer] 1
.                   if \\n[tbl*have-caption] \
.                      nr tbl*have-caption:\\n[defer] 1
.                \}
.                ie \\n[tbl*boxed] \
.                   ds float*type:\\n[defer] boxed-tbl:\\n[defer]
.                el .ds float*type:\\n[defer] table:\\n[defer]
.                if \\n[tbl*center] .nr float*tbl-center:\\n[defer] 1
.                if \\n[tbl*have-header] .rnn tbl*have-header tbl*have-header:\\n[defer]
.                rn tbl*header-div tbl*header-div:\\n[defer]
.                rr tbl*center
.             \}
.             if \\n[float*eqn] \{\
.                if \\n[defer]=1 .nr no-top-space:\\n[defer] 1
.                ds float*type:\\n[defer] eqn
.             \}
.             if \\n[float*pic] \{\
.                ds float*type:\\n[defer] pic
.                nr float*pic:\\n[defer] 1
.                rn pic*space-adj pic*space-adj:\\n[defer]
.             \}
.             if \\n[float*img] \{\
.                ds float*type:\\n[defer] img
.                nr float*img:\\n[defer] 1
.                nr no-top-space:\\n[defer] 1
.             \}
.             if \\n[D-float] .nr D-float:\\n[defer] \\n[D-float]
.             nr float-depth:\\n[defer] \\n[dn]
.             if \\n[#FORCE] \{\
.                ie \\n[#COLUMNS] .COL_NEXT
.                el .NEWPAGE
.                rr #FORCE
.             \}
.             if \\n[tbl*boxed] .rr tbl*boxed
.             if \\n[table] .rr table
.             br
.             return \" output div after header
.          \}
.       \}
.       nr dn-save \\n[dn]
.       if \\n[#FLEX_ACTIVE] \{\
.          if !\\n[@no-flex] \{\
.             da FLOAT*DIV
\!.           FLEX
\!.           nr flexed 1
.             da
.          \}
.       \}
.       nr dn \\n[dn-save]
.       ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.       ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u
.       vpt 0
.       if !'\\*[float-adj]'' .sp \\*[float-adj]
.       if \\n[.u] .nr fill 1
.       if \\n[@TOP] \{\
.          nr no-adjust 1
.          rr @TOP
.       \}
.       if \\n[float*tbl] \{\
.          if (\\n[#MLA]=1)&(\\n[tbl@source]=0) \
.             chop FLOAT*DIV
.          if \\n[nl]=\\n[#PAGE_TOP] \{\
.             ie (\\n[tbl*have-caption]=1)&(\\n[tbl*caption-after-label]=0) \{\
.                ie !\\n[#MLA] .sp \\n[tbl*caption-lead-diff]u
.                el .ch RR_@TOP
.             \}
.             el \{\
.                ev protect
.                evc FLOAT
.                nf
.                rs
.                ie \\n[tbl*boxed] .sp |\\n[#PAGE_TOP]u+.3n
.                el .sp |\\n[#PAGE_TOP]u-.25v
.             \}
.          \}
.       \}
.       if \\n[float*img] \
.          if \\n[pdf-img:frame] \
.             sp -(\\*[pdf-img:frame-weight]p*2u)
.       if !'\\n[.ev]'protect' \{\
.          ev protect
.          evc FLOAT
'           nf
.       \}
.       if \\n[float*tbl] \{\
.          if \\n[tbl*boxed] \
.             if \\n[tbl*center] \
.                if \\n[#L_INDENT] \
.                   in -\\n[#L_INDENT]u/2u
.       \}
.       if \\n[center-float] \
.          in (\\n[.l]u-\\n[dl]u)/2u
.       if \\n[indent-float] \
.          in \\n[indent-float]u
.       if \\n[right-float] \
.          in \\n[.l]u-\\n[dl]u
.       FLOAT*DIV
.       if (\\n[center-float]>0):(\\n[indent-float]>0):(\\n[right-float]>0) \
.          in
.       ev
.       if \\n[float*tbl] \{\
.          rr tbl*no-print-header
.          ie \\n[tbl*boxed] \{\
.             ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.             ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u
.             ie \\n[nl]>(\\n[.p]+\\n[#VARIABLE_FOOTER_POS]) \{\
.                ie \\n[#COLUMNS] .COL_NEXT
.                el .NEWPAGE
.             \}
.             el \{\
.                if \\n[dn-save]=\\n[bx-tbl-depth] .sp .35v
.                rr dn-save
.                ie \\n[tbl*plain-boxed] .sp .5v
.                el \{\
.                   if !\\n[tbl*autolabel] \{\
.                      if !\\n[#MLA] \{\
.                        if \\n[tbl@label]=1 .sp .5
.                      \}
.                   \}
.                \}
.                rr tbl*boxed
.                rr bx-tbl-depth
.             \}
.          \}
.          el \{\
.             if !'\\*[tbl*label]'' \
.                if \\n[tbl*autolabel]=0 .sp .5
.          \}
.          rr float*tbl
.          rr tbl*center
.          rm tbl*header-div
.          rr tbl*have-caption
.          rr tbl*have-label
.          rr tbl*have-source
.          rm tbl*caption
.          rm tbl*label
.          rm tbl*source
.       \}
.       if \\n[float*img] \
.          if (\\n[.t]-1)>(\\n[#DOC_LEAD]u/2u) .sp .5
.       if \\n[D-float] \{\
.          ie \\n[dn]=0 .sp \\n[D-float]u+\\n[#DOC_LEAD]u
.          el \
.             if \\n[dn]<\\n[D-float] \
.                sp \\n[D-float]u+\\n[#DOC_LEAD]u-\\n[dn]u
.\" Flex won't grab .h of D-floats without a dummy text line.
.          vpt 0
.          nop \&
.          sp -1
.          vpt 1
.       \}
.       if \\n[fill] \{\
.          fi
.          rr fill
.       \}
.       rm FLOAT*DIV
.       if !'\\*[float-adj]'' \
.          if !\\n[no-adjust] .sp -\\*[float-adj]
.       vpt
.       if !\\n[#NO_SHIM] \
.          if !\\n[@no-shim] .SHIM
.       rm float-adj
.       rm no-adjust
.       rr center-float
.       rr indent-float
.       rr right-float
.       rr D-float
.       rr @no-shim
.       rr @no-flex
.       rr #FORCE
.       rm P_QUOTE
.       rm B_QUOTE
.       if \\n[float*img] .rr float*img
.       if \\n[float*pic] .rr float*pic
.       if \\n[float*eqn] .rr float*eqn
.       rr float*target
.       rm float*target
.       if \\n[#NO_SHIM] \
.          if !\\n[#NO_FLEX] .nr post-float 1
.       ev \\*[ev-pre-float]
.       rm ev-pre-float
.    \}
.END
\#
\# SET TRAPS FOR HEADERS/FOOTERS/FOOTNOTES
\# ---------------------------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Sets header/footer/footnotes/etc... traps.
\#
\#   TRAPS calculates the number of lines that actually fit on a
\#   page based on #B_MARGIN and resets page bottom trap to coincide
\#   with the depth of that number of lines, or, if #ADJ_DOC_LEAD=1,
\#   adjusts #DOC_LEAD so that the last line of text on a page falls
\#   exactly on #B_MARGIN.
\#
.MAC RR_@TOP END \" Trap-invoked after first line of text on a new page
.    rr @TOP
.    if \\n[.ns] \{\
.       vpt 0
.       rs
.       if \\n[.u] .nr fill 1
.       nf
.       nop \&
.       sp -1
.       if \\n[fill] .fi
.       if r #NEWPAGE .rr #NEWPAGE
.    \}
.    if \\n[.vpt]=0 .vpt
.END
\#
.MAC TRAPS END
.    if !\\n[#UNADJUSTED_DOC_LEAD] .nr #UNADJUSTED_DOC_LEAD \\n[#DOC@LEAD]
.\" Remove all header/footer traps
.    if !\\n[#NO_TRAP_RESET] \{\
.       ch DO_T_MARGIN
.       ch DO_B_MARGIN
.       ch HEADER
.       ch FOOTER
.       ch FN_OVERFLOW_TRAP
.\" Plant header trap
.       wh 0 HEADER
.    \}
.\" Adjust lead so last line of text falls on B_MARGIN
.       nr #LINES_PER_PAGE 0 1
.       nr #DOC_LEAD_ADJ 0 1
.       nr #DEPTH_TO_B_MARGIN \\n[#PAGE_LENGTH]-\\n[#ORIGINAL_B_MARGIN]-\\n[#DOC_LEAD]
.\" Get the number of unadjusted lines that fit on the page; always a
.\" bit short of the bottom margin
.       while \\n[#T_MARGIN]+(\\n[#DOC_LEAD]*\\n+[#LINES_PER_PAGE])<\\n[#DEPTH_TO_B_MARGIN] \{\
.
.       \}
.       nr #LINES_PER_PAGE -1
.\" Add machine units, 1 at a time, increasing the leading until the
.\" new leading fills the page properly
.       while \\n[#T_MARGIN]+(\\n[#DOC_LEAD]+\\n+[#DOC_LEAD_ADJ]*\\n[#LINES_PER_PAGE])<=\\n[#DEPTH_TO_B_MARGIN] \{\
.
.       \}
.       DOC_LEAD \\n[#DOC_LEAD]u+\\n[#DOC_LEAD_ADJ]u
.\" The "visual" bottom margin is what \n[nl] would report on the
.\" last line before the FOOTER trap is sprung
.       nr #VISUAL_B_MARGIN \\n[#T_MARGIN]+(\\n[#LINES_PER_PAGE]*\\n[#DOC_LEAD])
.\" Get the difference between #B_MARGIN and #VISUAL_B_MARGIN
.       nr #FOOTER_DIFF (\\n[#PAGE_LENGTH]-\\n[#B_MARGIN])-\\n[#VISUAL_B_MARGIN]
.\" Set #B_MARGIN to 1 machine unit lower on the page than #VISUAL_B_MARGIN
.       nr #B_MARGIN \\n[#B_MARGIN]+(\\n[#FOOTER_DIFF]-1)
.\" Set the FN_OVERFLOW_TRAP position
.       nr #FN_OVERFLOW_TRAP_POS \\n[#B_MARGIN]-\\n[#FN_LEAD]
.       if \\n[#PRINT_STYLE]=1 .nr #FN_OVERFLOW_TRAP_POS \\n[#ORIGINAL_B_MARGIN]u
.\" Set footer and footnote overflow traps
.    if !\\n[#NO_TRAP_RESET] \{\
.       nr #FN_COUNT 0 1
.       nr #SPACE_REMAINING 0
.       nr #FN_DEPTH 0
.       nr #VARIABLE_FOOTER_POS 0-\\n[#B_MARGIN]u
.       wh \\n[.p]u FOOTER
.       wh -(\\n[#FN_OVERFLOW_TRAP_POS]u) FN_OVERFLOW_TRAP
.       ch FOOTER -\\n[#B_MARGIN]u
.    \}
.END
\#
\# CHECK INDENT
\# ------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Adds left, right, or both indent values to document elements
\#   like heads and subheads that are processed in environments.
\#
.MAC CHECK_INDENT END
.    if \\n[#INDENT_LEFT_ACTIVE] \{\
.       in \\n[#L_INDENT]u
.       if \\n[#QUOTE] \{\
.          in -\\n[#L_INDENT]u \"Because we added an indent in 2nd line of macro
.          ll -\\n[#L_INDENT]u
.          ta \\n[.l]u
.       \}
.       if \\n[#EPIGRAPH] \{\
.          in -\\n[#L_INDENT]u
.          ll -\\n[#L_INDENT]u
.          ta \\n[.l]u
.       \}
.    \}
.    if \\n[#INDENT_RIGHT_ACTIVE] \{\
.       ll -\\n[#R_INDENT]u
.       ta \\n[.l]u
.    \}
.    if \\n[#INDENT_BOTH_ACTIVE] \{\
.       in \\n[#BL_INDENT]u
.       ll -\\n[#BR_INDENT]u
.       ta \\n[.l]u
.       if \\n[#QUOTE] \{\
.          in -\\n[#BL_INDENT]u
.          ie \\n[#BR_INDENT]=\\n[#BL_INDENT] \{\
.             ll -\\n[#BR_INDENT]u
.             ta \\n[.l]u
.          \}
.          el \{\
.             ll -(\\n[#BR_INDENT]u/2u)
.             ta \\n[.l]u
.          \}
.       \}
.       if \\n[#EPIGRAPH] \{\
.          in -\\n[#BL_INDENT]u
.          ie \\n[#BR_INDENT]=\\n[#BL_INDENT] \{\
.             ll -\\n[#BR_INDENT]u
.             ta \\n[.l]u
.          \}
.          el \{\
.             ll -(\\n[#BR_INDENT]u/2u)
.             ta \\n[.l]u
.          \}
.       \}
.    \}
.END
\#
\# REMOVE INDENT
\# -------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Removes left, right, or both indent values from document elements
\#   like heads and subheads that are processed in environments.
\#
.MAC REMOVE_INDENT END
.    in 0
.    ll \\n[#L_LENGTH]u
.    ta \\n[.l]u
.END
\#
\# This .em (for all DOC_TYPEs, except 4 [LETTER]) ensures that
\# deferred footnotes and floats that happen on the 2nd to last page
\# get output, and the last page/col isn't flexed.
\#
.MAC TERMINATE END
.    if dPDF.EXPORT .tm .ds last-page \\n%@\\n[#COL_NUM]
.    ie \\n[#FN_DEPTH] \{\
.       ie \\n[#FN_DEFER] \{\
.          br
.          nr #TERMINATE 1
.          FOOTNOTE
.          nf
.          FOOTNOTE OFF
.       \}
.       el \{\
.          br
.          ch FN_OVERFLOW_TRAP
.          FOOTER
.       \}
.    \}
.    el \{\
.       br
.       ch FN_OVERFLOW_TRAP
.       FOOTER
.    \}
.    if \\n[defer] \
'       bp
.END
\#
\# END MACRO FOR LETTERS
\# ---------------------
\# *Arguments:
\#   none
\# *Function:
\#   The .em macro executed at the end of letters.  Turns footers
\#   and pagination off, terminates and outputs diversion CLOSING
\#   (indented with the author's name underneath).
\#
.MAC ALL_DONE END
.    ch FOOTER
.    ch HEADER
.    br
.    if \\n[#DOC_TYPE]=4 \{\
.       if !'\\n[.z]'' \{\
.          br
.          ALD \\*[$SIG_SPACE]
.          di
.       \}
.       IQ CLEAR
.       TQ
.       LEFT
.       ie !'\\*[$CLOSE_INDENT]'' .IL \\*[$CLOSE_INDENT]
.       el .IL \\n[#DOC_L_LENGTH]u/2u
.       sp
.       if \\n[#CLOSING] \{\
.          CLOSING_TEXT
.          br
.       \}
.       PRINT \\*[$AUTHOR_1]
.    \}
.END
\#
\# Set up a default papersize of US letter
\#
.PAPER LETTER
\#
\# ====================================================================
\#
\# +++DOCUMENT PROCESSING ALIASES+++
\#
\# Create aliases to make life easier for users: synonyms, short forms
\# and alternate spellings.
\#
.ALIAS CITATION            BLOCKQUOTE
.ALIAS CITE                BLOCKQUOTE
.ALIAS DOC_R_MARGIN        DOC_RIGHT_MARGIN
.ALIAS DOC_L_MARGIN        DOC_LEFT_MARGIN
.ALIAS DOC_L_LENGTH        DOC_LINE_LENGTH
.ALIAS DOC_RMARGIN         DOC_RIGHT_MARGIN
.ALIAS DOC_LMARGIN         DOC_LEFT_MARGIN
.ALIAS DOC_LLENGTH         DOC_LINE_LENGTH
.ALIAS DOC_FAM             DOC_FAMILY
.ALIAS DOC_LS              DOC_LEAD
.ALIAS DOC_PS              DOC_PT_SIZE
.ALIAS FILL                QUAD
.ALIAS PAGENUM             PAGENUMBER
.ALIAS PAGINATION          PAGINATE
.ALIAS PP_FT               PP_FONT
.ALIAS TOC_PS              TOC_PT_SIZE
\#
\# HEADER and FOOTER macros
\# ------------------------
\# Because the type-style of headers and footers are managed
\# identically, and the type-style macros (_<type parameter>) all
\# require the correct name of the calling macro, it's necessary
\# to create HEADER_ and FOOTER_ macros here that are basically
\# aliases with an argument.
\#
.MAC FOOTER_CENTER_COLOR END
.    HDRFTR_CENTER_COLOR \\$1
.END
\#
.MAC FOOTER_CENTER_COLOUR END
.    HDRFTR_CENTER_COLOR \\$1
.END
\#
.MAC FOOTER_CENTER_FAM END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC FOOTER_CENTER_FAMILY END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC FOOTER_CENTER_FONT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC FOOTER_CENTER_FT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC FOOTER_CENTER_PS END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC FOOTER_CENTER_SIZE END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC FOOTER_CENTRE_CAPS END
.    HDRFTR_CENTER_CAPS \\$1
.END
\#
.MAC FOOTER_CENTRE_COLOR END
.    HDRFTR_CENTER_COLOR \\$1
.END
\#
.MAC FOOTER_CENTRE_COLOUR END
.    HDRFTR_CENTER_COLOR \\$1
.END
\#
.MAC FOOTER_CENTRE_FAM END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC FOOTER_CENTRE_FAMILY END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC FOOTER_CENTRE_FONT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC FOOTER_CENTRE_FT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC FOOTER_CENTRE_PS END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC FOOTER_CENTRE_SIZE END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC FOOTER_COLOR END
.    HDRFTR_COLOR \\$1
.END
\#
.MAC FOOTER_COLOUR END
.    HDRFTR_COLOR \\$1
.END
\#
.MAC FOOTER_FAM END
.    HDRFTR_FAMILY \\$1
.END
\#
.MAC FOOTER_FAMILY END
.    HDRFTR_FAMILY \\$1
.END
\#
.MAC FOOTER_LEFT_COLOR END
.    HDRFTR_LEFT_COLOR \\$1
.END
\#
.MAC FOOTER_LEFT_COLOUR END
.    HDRFTR_LEFT_COLOR \\$1
.END
\#
.MAC FOOTER_LEFT_FAM END
.    HDRFTR_LEFT_FAMILY \\$1
.END
\#
.MAC FOOTER_LEFT_FAMILY END
.    HDRFTR_LEFT_FAMILY \\$1
.END
\#
.MAC FOOTER_LEFT_FONT END
.    HDRFTR_LEFT_FONT \\$1
.END
\#
.MAC FOOTER_LEFT_FT END
.    HDRFTR_LEFT_FONT \\$1
.END
\#
.MAC FOOTER_LEFT_PS END
.    HDRFTR_LEFT_SIZE \\$1
.END
\#
.MAC FOOTER_LEFT_SIZE END
.    HDRFTR_LEFT_SIZE \\$1
.END
\#
.MAC FOOTER_RIGHT_COLOR END
.    HDRFTR_RIGHT_COLOR \\$1
.END
\#
.MAC FOOTER_RIGHT_COLOUR END
.    HDRFTR_RIGHT_COLOR \\$1
.END
\#
.MAC FOOTER_RIGHT_FAM END
.    HDRFTR_RIGHT_FAMILY \\$1
.END
\#
.MAC FOOTER_RIGHT_FAMILY END
.    HDRFTR_RIGHT_FAMILY \\$1
.END
\#
.MAC FOOTER_RIGHT_FONT END
.    HDRFTR_RIGHT_FONT \\$1
.END
\#
.MAC FOOTER_RIGHT_FT END
.    HDRFTR_RIGHT_FONT \\$1
.END
\#
.MAC FOOTER_RIGHT_PS END
.    HDRFTR_RIGHT_SIZE \\$1
.END
\#
.MAC FOOTER_RIGHT_SIZE END
.    HDRFTR_RIGHT_SIZE \\$1
.END
\#
.MAC FOOTER_RULE_COLOR END
.    HDRFTR_RULE_COLOR \\$1
.END
\#
.MAC FOOTER_SIZE END
.    HDRFTR_SIZE \\$1
.END
\#
.MAC HEADER_CENTER_COLOR END
.    HDRFTR_CENTER_COLOR \\$1
.END
\#
.MAC HEADER_CENTER_COLOUR END
.    HDRFTR_CENTER_COLOR \\$1
.END
\#
.MAC HEADER_CENTER_FAM END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC HEADER_CENTER_FAMILY END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC HEADER_CENTER_FONT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC HEADER_CENTER_FT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC HEADER_CENTER_PS END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC HEADER_CENTER_SIZE END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC HEADER_CENTRE_COLOR END
.    HDRFTR_CENTER_COLOR \\$1
.END
\#
.MAC HEADER_CENTRE_COLOUR END
.    HDRFTR_CENTER_COLOR \\$1
.END
\#
.MAC HEADER_CENTRE_FAM END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC HEADER_CENTRE_FAMILY END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC HEADER_CENTRE_FONT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC HEADER_CENTRE_FT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC HEADER_CENTRE_PS END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC HEADER_CENTRE_SIZE END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC HEADER_COLOR END
.    HDRFTR_COLOR \\$1
.END
\#
.MAC HEADER_COLOUR END
.    HDRFTR_COLOR \\$1
.END
\#
.MAC HEADER_FAM END
.    HDRFTR_FAMILY \\$1
.END
\#
.MAC HEADER_FAMILY END
.    HDRFTR_FAMILY \\$1
.END
\#
.MAC HEADER_LEFT_COLOR END
.    HDRFTR_LEFT_COLOR \\$1
.END
\#
.MAC HEADER_LEFT_COLOUR END
.    HDRFTR_LEFT_COLOR \\$1
.END
\#
.MAC HEADER_LEFT_FAM END
.    HDRFTR_LEFT_FAMILY \\$1
.END
\#
.MAC HEADER_LEFT_FAMILY END
.    HDRFTR_LEFT_FAMILY \\$1
.END
\#
.MAC HEADER_LEFT_FONT END
.    HDRFTR_LEFT_FONT \\$1
.END
\#
.MAC HEADER_LEFT_FT END
.    HDRFTR_LEFT_FONT \\$1
.END
\#
.MAC HEADER_LEFT_PS END
.    HDRFTR_LEFT_SIZE \\$1
.END
\#
.MAC HEADER_LEFT_SIZE END
.    HDRFTR_LEFT_SIZE \\$1
.END
\#
.MAC HEADER_RIGHT_COLOR END
.    HDRFTR_RIGHT_COLOR \\$1
.END
\#
.MAC HEADER_RIGHT_COLOUR END
.    HDRFTR_RIGHT_COLOR \\$1
.END
\#
.MAC HEADER_RIGHT_FAM END
.    HDRFTR_RIGHT_FAMILY \\$1
.END
\#
.MAC HEADER_RIGHT_FAMILY END
.    HDRFTR_RIGHT_FAMILY \\$1
.END
\#
.MAC HEADER_RIGHT_FONT END
.    HDRFTR_RIGHT_FONT \\$1
.END
\#
.MAC HEADER_RIGHT_FT END
.    HDRFTR_RIGHT_FONT \\$1
.END
\#
.MAC HEADER_RIGHT_PS END
.    HDRFTR_RIGHT_SIZE \\$1
.END
\#
.MAC HEADER_RIGHT_SIZE END
.    HDRFTR_RIGHT_SIZE \\$1
.END
\#
.MAC HEADER_RULE_COLOR END
.    HDRFTR_RULE_COLOR \\$1
.END
\#
.MAC HEADER_SIZE END
.    HDRFTR_SIZE \\$1
.END
\#
\# Aliases for other HEADER and FOOTER macros.
\#
.ALIAS  BIBLIOGRAPHY_FOOTER_CENTER BIBLIOGRAPHY_HDRFTR_CENTER
.ALIAS  BIBLIOGRAPHY_FOOTER_CENTRE BIBLIOGRAPHY_HDRFTR_CENTER
.ALIAS  BIBLIOGRAPHY_HEADER_CENTER BIBLIOGRAPHY_HDRFTR_CENTER
.ALIAS  BIBLIOGRAPHY_HEADER_CENTRE BIBLIOGRAPHY_HDRFTR_CENTER
.
.ALIAS  ENDNOTES_FOOTER_CENTER ENDNOTES_HDRFTR_CENTER
.ALIAS  ENDNOTES_FOOTER_CENTRE ENDNOTES_HDRFTR_CENTER
.ALIAS  ENDNOTES_HEADER_CENTER ENDNOTES_HDRFTR_CENTER
.ALIAS  ENDNOTES_HEADER_CENTRE ENDNOTES_HDRFTR_CENTER
.
.ALIAS  FOOTER_CENTER           HDRFTR_CENTER
.ALIAS  TOC_PAGEFOOTER_CENTER   HDRFTR_CENTER
.ALIAS  TOC_PAGEFOOTER_CENTRE   HDRFTR_CENTER
.ALIAS  FOOTER_CENTER_CAPS      _HDRFTR_CAPS
.ALIAS  FOOTER_CENTER_PAD       HDRFTR_CENTER_PAD
.ALIAS  FOOTER_CENTER_SMALLCAPS _HDRFTR_SMALLCAPS
.ALIAS  FOOTER_CENTRE           HDRFTR_CENTER
.ALIAS  FOOTER_CENTRE_CAPS      _HDRFTR_CAPS
.ALIAS  FOOTER_CENTRE_PAD       HDRFTR_CENTER_PAD
.ALIAS  FOOTER_CENTRE_SMALLCAPS _HDRFTR_SMALLCAPS
.ALIAS  FOOTER_LEFT             HDRFTR_LEFT
.ALIAS  FOOTER_LEFT_CAPS        _HDRFTR_CAPS
.ALIAS  FOOTER_LEFT_SMALLCAPS   _HDRFTR_SMALLCAPS
.ALIAS  FOOTER_PLAIN            HDRFTR_PLAIN
.ALIAS  FOOTER_RECTO            HDRFTR_RECTO
.ALIAS  FOOTER_RIGHT            HDRFTR_RIGHT
.ALIAS  FOOTER_RIGHT_CAPS       _HDRFTR_CAPS
.ALIAS  FOOTER_RIGHT_SMALLCAPS  _HDRFTR_SMALLCAPS
.ALIAS  FOOTER_RULE             HDRFTR_RULE
.ALIAS  FOOTER_RULE_GAP         HDRFTR_RULE_GAP
.ALIAS  FOOTER_VERSO            HDRFTR_VERSO
.
.ALIAS  HEADER_CENTER           HDRFTR_CENTER
.ALIAS  TOC_PAGEHEADER_CENTER   HDRFTR_CENTER
.ALIAS  TOC_PAGEHEADER_CENTRE   HDRFTR_CENTER
.ALIAS  HEADER_CENTER_CAPS      _HDRFTR_CAPS
.ALIAS  HEADER_CENTER_PAD       HDRFTR_CENTER_PAD
.ALIAS  HEADER_CENTER_SMALLCAPS _HDRFTR_SMALLCAPS
.ALIAS  HEADER_CENTRE           HDRFTR_CENTER
.ALIAS  HEADER_CENTRE_CAPS      _HDRFTR_CAPS
.ALIAS  HEADER_CENTRE_PAD       HDRFTR_CENTER_PAD
.ALIAS  HEADER_CENTRE_SMALLCAPS _HDRFTR_SMALLCAPS
.ALIAS  HEADER_LEFT             HDRFTR_LEFT
.ALIAS  HEADER_LEFT_CAPS        _HDRFTR_CAPS
.ALIAS  HEADER_LEFT_SMALLCAPS   _HDRFTR_SMALLCAPS
.ALIAS  HEADER_PLAIN            HDRFTR_PLAIN
.ALIAS  HEADER_RECTO            HDRFTR_RECTO
.ALIAS  HEADER_RIGHT            HDRFTR_RIGHT
.ALIAS  HEADER_RIGHT_CAPS       _HDRFTR_CAPS
.ALIAS  HEADER_RIGHT_SMALLCAPS  _HDRFTR_SMALLCAPS
.ALIAS  HEADER_RULE             HDRFTR_RULE
.ALIAS  HEADER_RULE_GAP         HDRFTR_RULE_GAP
.ALIAS  HEADER_VERSO            HDRFTR_VERSO
.
.ALIAS  SWITCH_FOOTERS     SWITCH_HDRFTR
.ALIAS  SWITCH_HEADERS     SWITCH_HDRFTR
\#
\# Create type-style aliases for tags, titles, and page elements
\#
\# These are used for creating aliases with while loops
\#
.ds ELEMENT_TYPE_1  BIBLIOGRAPHY_STRING
.ds ELEMENT_TYPE_2  BIBLIOGRAPHY_HEADER
.ds ELEMENT_TYPE_3  BLOCKQUOTE
.ds ELEMENT_TYPE_4  CITATION
.ds ELEMENT_TYPE_5  CITE
.ds ELEMENT_TYPE_6  ENDNOTES_HEADER
.ds ELEMENT_TYPE_7  ENDNOTE_STRING
.ds ELEMENT_TYPE_8  EPIGRAPH
.ds ELEMENT_TYPE_9  HDRFTR_CENTER
.ds ELEMENT_TYPE_10 HDRFTR_LEFT
.ds ELEMENT_TYPE_11 HDRFTR_RIGHT
.ds ELEMENT_TYPE_12 LINENUMBER
.ds ELEMENT_TYPE_13 PAGENUM
.ds ELEMENT_TYPE_14 QUOTE
.ds ELEMENT_TYPE_15 TOC_HEADER
.ds ELEMENT_TYPE_16 CODE
.ds ELEMENT_TYPE_17 FINIS
.ds ELEMENT_TYPE_18 COPYRIGHT
\#
\# Create aliases for _FAMILY
.ALIAS BIBLIOGRAPHY_FAMILY       _FAMILY
.ALIAS COVER_FAMILY              _FAMILY
.ALIAS DOCHEADER_FAMILY          _FAMILY
.ALIAS DOC_COVER_FAMILY          _FAMILY
.ALIAS ENDNOTE_FAMILY            _FAMILY
.ALIAS ENDNOTE_LINENUMBER_FAMILY _FAMILY
.ALIAS ENDNOTE_NUMBER_FAMILY     _FAMILY
.ALIAS ENDNOTE_STRING_FAMILY     _FAMILY
.ALIAS ENDNOTE_TITLE_FAMILY      _FAMILY
.ALIAS FOOTNOTE_FAMILY           _FAMILY
.ALIAS HDRFTR_FAMILY             _FAMILY
.ALIAS PAGENUMBER_FAMILY         _FAMILY
.ALIAS TOC_FAMILY                _FAMILY
.ALIAS TOC_PAGENUMBER_FAMILY     _FAMILY
.ALIAS TOC_PN_FAMILY             _FAMILY
.ALIAS TOC_TITLE_FAMILY          _FAMILY
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<=18 \{\
. ALIAS \*[ELEMENT_TYPE_\n[#LOOP]]_FAMILY _FAMILY
.\}
\# Covers, docheader
.nr #LOOP 0 1
.while \n+[#LOOP]<=12 \{\
. ALIAS \*[TITLE_TYPE_\n[#LOOP]]_FAMILY           _FAMILY
. ALIAS COVER_\*[TITLE_TYPE_\n[#LOOP]]_FAMILY     _FAMILY
. ALIAS DOC_COVER_\*[TITLE_TYPE_\n[#LOOP]]_FAMILY _FAMILY
.\}
\#
\# Create aliases for _FONT
.ALIAS BIBLIOGRAPHY_FONT       _FONT
.ALIAS ENDNOTE_FONT            _FONT
.ALIAS ENDNOTE_LINENUMBER_FONT _FONT
.ALIAS ENDNOTE_NUMBER_FONT     _FONT
.ALIAS ENDNOTE_TITLE_FONT      _FONT
.ALIAS FOOTNOTE_FONT           _FONT
.ALIAS TOC_PN_FONT             _FONT
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<=18 \{\
. ALIAS \*[ELEMENT_TYPE_\n[#LOOP]]_FONT _FONT
.\}
\# Covers, docheader
.nr #LOOP 0 1
.while \n+[#LOOP]<=12 \{\
. ALIAS \*[TITLE_TYPE_\n[#LOOP]]_FONT           _FONT
. ALIAS COVER_\*[TITLE_TYPE_\n[#LOOP]]_FONT     _FONT
. ALIAS DOC_COVER_\*[TITLE_TYPE_\n[#LOOP]]_FONT _FONT
.\}
\#
\# Create aliases for _SIZE
.ALIAS   ENDNOTE_LINENUMBER_SIZE _SIZE
.ALIAS   ENDNOTE_NUMBER_SIZE     _SIZE
.ALIAS   ENDNOTE_TITLE_SIZE      _SIZE
.ALIAS   FOOTNOTE_SIZE           _SIZE
.ALIAS   HDRFTR_SIZE             _SIZE
.ALIAS   TOC_PN_SIZE             _SIZE
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<=18 \{\
. ALIAS \*[ELEMENT_TYPE_\n[#LOOP]]_SIZE _SIZE
.\}
\# Covers, docheader
.nr #LOOP 0 1
.while \n+[#LOOP]<=12 \{\
. ALIAS \*[TITLE_TYPE_\n[#LOOP]]_SIZE           _SIZE
. ALIAS COVER_\*[TITLE_TYPE_\n[#LOOP]]_SIZE     _SIZE
. ALIAS DOC_COVER_\*[TITLE_TYPE_\n[#LOOP]]_SIZE _SIZE
.\}
\#
\# Create aliases for TITLE_LEAD
.nr #LOOP 0 1
.while \n+[#LOOP]<=12 \{\
. ALIAS \*[TITLE_TYPE_\n[#LOOP]]_LEAD           TITLE_LEAD
. ALIAS COVER_\*[TITLE_TYPE_\n[#LOOP]]_LEAD     TITLE_LEAD
. ALIAS DOC_COVER_\*[TITLE_TYPE_\n[#LOOP]]_LEAD TITLE_LEAD
.\}
\#
\# Create aliases for _UNDERLINE
.ALIAS BIBLIOGRAPHY_HEADER_UNDERLINE  _UNDERLINE
.ALIAS BIBLIOGRAPHY_HEADER_UNDERSCORE _UNDERLINE
.ALIAS BIBLIOGRAPHY_STRING_UNDERLINE  _UNDERLINE
.ALIAS BIBLIOGRAPHY_STRING_UNDERSCORE _UNDERLINE
.ALIAS BIB_STRING_UNDERLINE           _UNDERLINE
.ALIAS ENDNOTES_HEADER_UNDERLINE      _UNDERLINE
.ALIAS ENDNOTES_HEADER_UNDERSCORE     _UNDERLINE
.ALIAS ENDNOTES_STRING_UNDERLINE      _UNDERLINE
.ALIAS ENDNOTES_STRING_UNDERSCORE     _UNDERLINE
.ALIAS ENDNOTE_TITLE_UNDERLINE        _UNDERLINE
.ALIAS ENDNOTE_TITLE_UNDERSCORE       _UNDERLINE
.ALIAS EN_STRING_UNDERLINE            _UNDERLINE
.ALIAS EN_STRING_UNDERSCORE           _UNDERLINE
.ALIAS TOC_HEADER_UNDERLINE           _UNDERLINE
.ALIAS TOC_HEADER_UNDERSCORE          _UNDERLINE
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<=12 \{\
. ALIAS \*[TITLE_TYPE_\n[#LOOP]]_UNDERLINE            _UNDERLINE
. ALIAS \*[TITLE_TYPE_\n[#LOOP]]_UNDERSCORE           _UNDERLINE
. ALIAS COVER_\*[TITLE_TYPE_\n[#LOOP]]_UNDERLINE      _UNDERLINE
. ALIAS COVER_\*[TITLE_TYPE_\n[#LOOP]]_UNDERSCORE     _UNDERLINE
. ALIAS DOC_COVER_\*[TITLE_TYPE_\n[#LOOP]]_UNDERLINE  _UNDERLINE
. ALIAS DOC_COVER_\*[TITLE_TYPE_\n[#LOOP]]_UNDERSCORE _UNDERLINE
.\}
\#
\# Create aliases for _COLOR
.ALIAS BIBLIOGRAPHY_HEADER_COLOR _COLOR
.ALIAS COVER_COLOR               _COLOR
.ALIAS DOCHEADER_COLOR           _COLOR
.ALIAS ENDNOTE_TITLE_COLOR       _COLOR
.ALIAS FINIS_COLOR               _COLOR
.ALIAS FOOTNOTE_COLOR            _COLOR
.ALIAS HDRFTR_COLOR              _COLOR
.ALIAS HDRFTR_RULE_COLOR         _COLOR
.ALIAS LINEBREAK_COLOR           _COLOR
.ALIAS SECTION_COLOR             _COLOR
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<=18 \{\
. ALIAS \*[ELEMENT_TYPE_\n[#LOOP]]_COLOR _COLOR
.\}
\# Covers, docheader
.nr #LOOP 0 1
.while \n+[#LOOP]<=12 \{\
. ALIAS \*[TITLE_TYPE_\n[#LOOP]]_COLOR           _COLOR
. ALIAS COVER_\*[TITLE_TYPE_\n[#LOOP]]_COLOR     _COLOR
. ALIAS DOC_COVER_\*[TITLE_TYPE_\n[#LOOP]]_COLOR _COLOR
.\}
\#
\# Create aliases for _CAPS
.ALIAS BIBLIOGRAPHY_HEADER_CAPS _CAPS
.ALIAS BIBLIOGRAPHY_STRING_CAPS _CAPS
.ALIAS ENDNOTE_TITLE_CAPS       _CAPS
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<=12 \{\
. ALIAS \*[TITLE_TYPE_\n[#LOOP]]_CAPS           _CAPS
. ALIAS COVER_\*[TITLE_TYPE_\n[#LOOP]]_CAPS     _CAPS
. ALIAS DOC_COVER_\*[TITLE_TYPE_\n[#LOOP]]_CAPS _CAPS
.\}
\#
\# Create aliases for _SMALLCAPS
.ALIAS BIBLIOGRAPHY_HEADER_SMALLCAPS _SMALLCAPS
.ALIAS BIBLIOGRAPHY_STRING_SMALLCAPS _SMALLCAPS
.ALIAS ENDNOTE_TITLE_SMALLCAPS       _SMALLCAPS
.ALIAS HDRFTR_CENTER_SMALLCAPS       _SMALLCAPS
.ALIAS HDRFTR_LEFT_SMALLCAPS         _SMALLCAPS
.ALIAS HDRFTR_RIGHT_SMALLCAPS        _SMALLCAPS
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<=12 \{\
. ALIAS \*[TITLE_TYPE_\n[#LOOP]]_SMALLCAPS           _SMALLCAPS
. ALIAS COVER_\*[TITLE_TYPE_\n[#LOOP]]_SMALLCAPS     _SMALLCAPS
. ALIAS DOC_COVER_\*[TITLE_TYPE_\n[#LOOP]]_SMALLCAPS _SMALLCAPS
.\}
\#
\# Create aliases for _QUAD
.ALIAS  BIBLIOGRAPHY_HEADER_QUAD  _QUAD
.ALIAS  BIBLIOGRAPHY_QUAD         _QUAD
.ALIAS  BIBLIOGRAPHY_STRING_QUAD  _QUAD
.ALIAS  BLOCKQUOTE_QUAD           _QUAD
.ALIAS  COPYRIGHT_QUAD            _QUAD
.ALIAS  COVER_COPYRIGHT_QUAD      _QUAD
.ALIAS  COVER_MISC_QUAD           _QUAD
.ALIAS  COVER_QUAD                _QUAD
.ALIAS  DOCHEADER_QUAD            _QUAD
.ALIAS  DOC_COVER_COPYRIGHT_QUAD  _QUAD
.ALIAS  DOC_COVER_MISC_QUAD       _QUAD
.ALIAS  DOC_COVER_QUAD            _QUAD
.ALIAS  DOC_QUAD                  _QUAD
.ALIAS  ENDNOTES_HEADER_QUAD      _QUAD
.ALIAS  ENDNOTE_QUAD              _QUAD
.ALIAS  ENDNOTE_STRING_QUAD       _QUAD
.ALIAS  ENDNOTE_TITLE_QUAD        _QUAD
.ALIAS  EPIGRAPH_QUAD             _QUAD
.ALIAS  FOOTNOTE_QUAD             _QUAD
.ALIAS  MISC_QUAD                 _QUAD
.ALIAS  TOC_HEADER_QUAD           _QUAD
\#
\# Support aliases
\#
.ALIAS   COL_BREAK               COL_NEXT
.ALIAS   DOC_COVER               COVER
.ALIAS   DOC_COVERS              COVERS
.ALIAS   DOC_COVERTITLE          COVERTITLE
.ALIAS   DOC_COVER_COUNTS_PAGES  COVER_COUNTS_PAGES
.ALIAS   DOC_COVER_LEAD          COVER_LEAD
.ALIAS   DOC_DOC_COVERTITLE      COVERTITLE
.ALIAS   DO_DOC_COVER            DO_COVER
.ALIAS   PRINT_FOOTNOTE_RULE     FOOTNOTE_RULE
\#
\# Miscellaneous aliases
.ALIAS   SECTION        LINEBREAK
.ALIAS   SECTION_CHAR   LINEBREAK_CHAR
\#
\# Miscellaneous macros to take care of backward compatibility
\# -----------------------------------------------------------
\#
\# As of 1.1.9, EL and TN got changed to make TRAP...TRAP OFF
\# unnecessary for users.  However, I used both macros extensively
\# throughout this file (in conjunction with TRAP...TRAP OFF).
\# EOL is the old EL; used only in om.tmac.
\#
.MAC EOL END
.    if \\n[.vpt] \{\
.       vpt 0
.       nr #RESTORE_TRAP 1
.    \}
.    br
.    sp -1v
.    if \\n[#RESTORE_TRAP] \{\
.       vpt
.       rr #RESTORE_TRAP
.    \}
.END
\#
\# PREPROCESSOR SUPPORT
\# ====================
\#
\# Utility macros--label and caption styles, lists collector, lists
\# generator.
\#
.nr lists*target 0 1
.
.MAC get-label-type END
.    if \\n[all]=1 .ds label-type eqn
.    if \\n[all]=2 .ds label-type pdf-img
.    if \\n[all]=3 .ds label-type pic
.    if \\n[all]=4 .ds label-type tbl
.    if \\n[all]=5 .ds label-type floating
.END
\#
.MAC set-defaults END
.    if '\\*[\\*[label-type]*\\*[spec-type]-family]'' \
.       ds \\*[label-type]*\\*[spec-type]-family \\*[$DOC_FAM]\"
.    if '\\*[\\*[label-type]*\\*[spec-type]-font]'' \
.       ds \\*[label-type]*\\*[spec-type]-font R\"
.    if '\\*[\\*[label-type]*\\*[spec-type]-size-change]'' \
.       ds \\*[label-type]*\\*[spec-type]-size-change +0\"
.    if !r \\*[label-type]*\\*[spec-type]-autolead \
.       nr \\*[label-type]*\\*[spec-type]-autolead 2
.    if '\\*[\\*[label-type]*\\*[spec-type]-space]'' \
.       ds \\*[label-type]*\\*[spec-type]-space +0\"
.    if '\\*[\\*[label-type]*\\*[spec-type]-color]'' \
.       ds \\*[label-type]*\\*[spec-type]-color black\"
.    if '\\*[\\*[label-type]*\\*[spec-type]-quad]'' \{\
.       ie '\\*[label-type]'eqn' \{\
.          if '\\*[spec-type]'caption' \
.             ds \\*[label-type]*\\*[spec-type]-quad C\"
.       \}
.       el .ds \\*[label-type]*\\*[spec-type]-quad L\"
.    \}
.    if '\\n[\\*[label-type]*\\*[spec-type]-quad-on-ll]'' \
.       nr \\*[label-type]*\\*[spec-type]-quad-on-ll 1
.    if '\\*[spec-type]'caption' \
.       nr default-left 1
.END
\#
.MAC set-inline-specs END
.    ds \\*[label-type]*\\*[spec-type]-specs \
\f[\\*[\\*[label-type]*\\*[spec-type]-family]\\*[\\*[label-type]*\\*[spec-type]-font]]\
\s[\\*[\\*[label-type]*\\*[spec-type]-size-change]]\
\m[\\*[\\*[label-type]*\\*[spec-type]-color]]
.END
\#
\# Line lengths, indents, and quads for captions and labels.
\# Aliased for eqn, pic, pdf-image, and tbl.
\#
.MAC SET_QUAD END
.    ds label-type \\$0
.    substring label-type 0 2
.    if '\\*[label-type]'PDF'   .ds label-type pdf-img
.    if '\\*[label-type]'TBL'   .ds label-type tbl
.    if '\\*[label-type]'PIC'   .ds label-type pic
.    if '\\*[label-type]'EQN'   .ds label-type eqn
.    ds spec-type \\$0
.    substring spec-type -6 -10
.    if '\\*[spec-type]'PTION' .ds spec-type caption
.    if '\\*[spec-type]'LABEL' .ds spec-type label
.    if '\\*[spec-type]'OURCE' .ds spec-type source
.    QUAD \\$1
.    ds \\*[label-type]*\\*[spec-type]-quad \\$1
.    substring \\*[label-type]*\\*[spec-type]-quad 0 0
.    if '\\*[label-type]'pdf-img' \{\
.       if '\\*[\\*[label-type]*\\*[spec-type]-quad]'L' \{\
.          if !\\n[pdf-img*\\*[spec-type]-quad-on-ll] \{\
.             ie !'\\*[pdf-img:pos]'-R' \
.                ll \\n[pdf-img:ind]u+\\n[pdf-img:width]u+\\n[pdf-img:frame-inset]u
.             el .ll -\\n[ind-pre-img]u
.             if '\\*[pdf-img:pos]'-C' \
.                in \\n[pdf-img:ind]u-\\n[pdf-img:frame-inset]u
.             if '\\*[pdf-img:pos]'-R' \
.                in \\n[.l]u-(\\n[pdf-img:width]u+(\\n[pdf-img:frame-inset]u*2u))
.             if '\\*[pdf-img:pos]'-I' \
.                in \\n[pdf-img:ind]u
.          \}
.       \}
.       if '\\*[\\*[label-type]*\\*[spec-type]-quad]'C' \{\
.          if !\\n[pdf-img*\\*[spec-type]-quad-on-ll] \{\
.             if '\\*[pdf-img:pos]'-L' \
.                ll \\n[pdf-img:width]u+(\\n[pdf-img:frame-inset]u*2u)
.             if '\\*[pdf-img:pos]'-C' \{\
.                ll (\\n[ll-pre-img]u-\\n[pdf-img:width]u/2u+(\\n[pdf-img:frame-inset]u))+\\n[pdf-img:width]u
.                in \\n[.l]u-(\\n[pdf-img:width]u+(\\n[pdf-img:frame-inset]u*2u))
.             \}
.             if '\\*[pdf-img:pos]'-R' \{\
.                ll -\\n[ind-pre-img]u
.                in \\n[.l]u-(\\n[pdf-img:width]u+(\\n[pdf-img:frame-inset]u*2u))
.             \}
.             if '\\*[pdf-img:pos]'-I' \{\
.                ll \\n[pdf-img:ind]u+\\n[pdf-img:width]u+(\\n[pdf-img:frame-inset]u*2u)
.                in \\n[pdf-img:ind]u
.             \}
.          \}
.       \}
.       if '\\*[\\*[label-type]*\\*[spec-type]-quad]'R' \{\
.          if !\\n[pdf-img*\\*[spec-type]-quad-on-ll] \{\
.             if '\\*[pdf-img:pos]'-L' \
.                ll \\n[pdf-img:width]u+(\\n[pdf-img:frame-inset]u*2u]
.             if '\\*[pdf-img:pos]'-C' \{\
.                ll (\\n[.l]u-\\n[ind-pre-img]u-\\n[pdf-img:width]u/2u)+\\n[pdf-img:width]u+\\n[pdf-img:frame-inset]u
.                in \\n[pdf-img:ind]u
.             \}
.             if '\\*[pdf-img:pos]'-R' \{\
.                ll -\\n[ind-pre-img]u
.                in \\n[.l]u-\\n[pdf-img:width]u
.             \}
.             if '\\*[pdf-img:pos]'-I' \{\
.                ll \\n[pdf-img:ind]u+\\n[pdf-img:width]u+(\\n[pdf-img:frame-inset]u*2u)
.                in \\n[pdf-img:ind]u
.             \}   
.          \}
.       \}
.    \}
.    if '\\*[label-type]'pic' \{\
.       if !\\n[pic*\\*[spec-type]-quad-on-ll] \{\
.          ie \\n[pic*left] .ll \\n[pic*div-width]u
.          el \{\
.             ll \\n[pic*div-width]u
\!.           in \\n[ll-pre-pic]u-\\n[pic*div-width]u/2u
.          \}
.       \}
.    \}
.    if '\\*[label-type]'tbl' \{\
.       if !\\n[tbl*\\*[spec-type]-quad-on-ll] \{\
.          ie \\n[tbl*center] \{\
.             ie '\\*[spec-type]'label' \{\
.\" Differentiate between a tbl label and a float label
.                ie !'\\*[ev-current]'FLOAT' \{\
.                   ll \\n[ll-pre-tbl]u-\\n[TW]u/2u+\\n[TW]u
.                   if \\n[tbl*have-header] \
.                      in (\\n[ll-pre-tbl]u-\\n[.i]u)-\\n[TW]u/2u+\\n[.i]u
.                \}
.                el \{\
.                   in \\n[ll-pre-tbl]u+\\n[.i]u-\\n[TW]u/2u
.                   ll \\n[.l]u-\\n[.i]u
.                \}
.             \}
.             el \{\
.                if '\\*[spec-type]'source' \{\
.                    ie \\n[float*tbl] \{\
.                       ll \\n[TW]u
\!.                     in \\n[ll-pre-tbl]u-\\n[TW]u/2u+\\n[tmp-ind]u
.                    \}
.                    el \{\
.                       ll \\n[TW]u+\\n[ind-pre-tbl]u
.                       ie \\n[ind-pre-tbl] \
\!.                        in \\n[ll-pre-tbl]u-\\n[TW]u/2u
.                       el \
\!.                        in \\n[ll-pre-tbl]u-\\n[TW]u/2u+\\n[tmp-ind]u
.                    \}
\!.                  ti -\\n[tmp-ind]u
.                \}
.                if '\\*[spec-type]'caption' \{\
.                    ll \\n[ll-pre-tbl]u+\\n[.i]u-\\n[TW]u/2u+\\n[TW]u
.                    in \\n[ll-pre-tbl]u+\\n[.i]u-\\n[TW]u/2u
.                \}
.             \}
.          \}
.          el \{\
.             ll \\n[TW]u+\\n[.i]u
.\" Check the effect of setting a source in non-MLA mode.
.             if '\\*[spec-type]'source' \{\
.                if \\n[#MLA] \{\
.                   ie \\n[float*tbl] \{\
\!.                    ll \\n[TW]u+\\n[ind-pre-tbl]u
\!.                    in \\n[tmp-ind]u+\\n[ind-pre-tbl]u
\!.                    ti -\\n[tmp-ind]u
.                   \}
.                   el \{\
.                      ll \\n[TW]u+\\n[ind-pre-tbl]u
\!.                      in \\n[tmp-ind]u
\!.                      ti -\\n[tmp-ind]u
.                   \}
.                \}
.             \}
.          \}
.       \}
.    \}
.END
\#
.ALIAS TBL*SET_CAPTION_QUAD     SET_QUAD
.ALIAS TBL*SET_LABEL_QUAD       SET_QUAD
.ALIAS TBL*SET_SOURCE_QUAD      SET_QUAD
.ALIAS PDF_IMG*SET_CAPTION_QUAD SET_QUAD
.ALIAS PDF_IMG*SET_LABEL_QUAD   SET_QUAD
.ALIAS PIC*SET_CAPTION_QUAD     SET_QUAD
.ALIAS PIC*SET_LABEL_QUAD       SET_QUAD
\#
.MAC style END
.    ds label-type \\$0
.    substring label-type 0 2
.    if '\\*[label-type]'img' .ds label-type pdf-img
.    if '\\*[label-type]'tbl' .ds label-type tbl
.    if '\\*[label-type]'pic' .ds label-type pic
.    ds spec-type \\$0
.    substring spec-type 4 6
.    if '\\*[spec-type]'cap' .ds spec-type caption
.    if '\\*[spec-type]'lab' .ds spec-type label
.    if '\\*[spec-type]'sou' .ds spec-type source
'    fam \\*[\\*[label-type]*\\*[spec-type]-family]
'    ft \\*[\\*[label-type]*\\*[spec-type]-font]
'    ps \\n[#DOC_PT_SIZE]u\\*[\\*[label-type]*\\*[spec-type]-size-change]
.    COLOR \\*[\\*[label-type]*\\*[spec-type]-color]
.END
\#
.ALIAS tbl*caption-style style
.ALIAS tbl*label-style   style
.ALIAS tbl*source-style  style
.ALIAS img*caption-style style
.ALIAS img*label-style   style
.ALIAS img*source-style  style
.ALIAS pic*caption-style style
.ALIAS pic*label-style   style
.ALIAS pic*source-style  style
\#
\# User style macros
\#
\# TYPE SPECS FOR LABELS, CAPTIONS, AND SOURCES
\# --------------------------------------------
\#  Aliased as CAPTIONS and LABELS for eqn, pic, tbl, and pdf images.
\# *Arguments:
\#   EQN | IMG | PIC | TBL | FLOATING \
\#   Remaining arguments are optional
\#   FAMILY   fam \
\#   FONT     sty \
\#   SIZE     +|-size \
\#   QUAD     LEFT | CENTRE | RIGHT [ ON_LL ] \
\#   COLOR    color \
\#   AUTOLEAD n \
\#   ADJUST   +|-n
\# *Function:
\#   Sets type specs for captions, labels, and sources according to
\#   calling alias name
\# *Notes:
\#   SIZE is relative to running text.
\#   QUAD optional arg says quad on full line length rather than
\#    pdf-img or pre-processor output.  
\#
.MAC CAPTION_LABEL_SPECS END
.    if '\\$0'CAPTIONS' .ds spec-type caption
.    if '\\$0'LABELS'   .ds spec-type label
.    if '\\$0'SOURCES'  .ds spec-type source
.    ds $LABEL-TYPE \\$1
.    if '\\$1'EQN'      .ds label-type eqn
.    if '\\$1'FLOATING' .ds label-type floating
.    if '\\$1'IMG'      .ds label-type pdf-img
.    if '\\$1'PIC'      .ds label-type pic
.    if '\\$1'TBL'      .ds label-type tbl
.    if '\\$1'ALL'      .nr all 1
.    shift
.    nr loop-counter \\n[#NUM_ARGS]
.    nr loop-count 0 1
.    while \\n+[loop-count]<=\\n[loop-counter] \{\
.       if '\\$1'FAMILY' \{\
.          shift
.          ie r all \{\
.             nr all 0 1
.             while \\n+[all]<=5 \{\
.                 get-label-type
.                 ds \\*[label-type]*\\*[spec-type]-family \\$1
.             \}
.          \}
.          el .ds \\*[label-type]*\\*[spec-type]-family \\$1
.          if \\n[#PRINT_STYLE]=1 \
.             ds \\*[label-type]*\\*[spec-type]-family \\*[$TYPEWRITER_FAM]
.          shift
.       \}
.       if '\\$1'FONT' \{\
.          shift
.          ie r all \{\
.             nr all 0 1
.             while \\n+[all]<=5 \{\
.                 get-label-type
.                 ds \\*[label-type]*\\*[spec-type]-font \\$1
.             \}
.          \}
.          el .ds \\*[label-type]*\\*[spec-type]-font \\$1
.          if \\n[#PRINT_STYLE]=1 \
.             ds \\*[label-type]*\\*[spec-type]-font R
.          shift
.       \}
.       if '\\$1'SIZE' \{\
.          shift
.          ie r all \{\
.             nr all 0 1
.             while \\n+[all]<=5 \{\
.                 get-label-type
.                 ds \\*[label-type]*\\*[spec-type]-size-change \\$1
.             \}
.          \}
.          el .ds \\*[label-type]*\\*[spec-type]-size-change \\$1
.          if \\n[#PRINT_STYLE]=1 \
.             ds \\*[label-type]*\\*[spec-type]-size-change +0
.          shift
.       \}
.       if '\\$1'AUTOLEAD' \{\
.          shift
.          ie r all \{\
.             nr all 0 1
.             while \\n+[all]<=5 \{\
.                 get-label-type
.                 nr \\*[label-type]*\\*[spec-type]-autolead (p;\\$1)
.             \}
.          \}
.          el .nr \\*[label-type]*\\*[spec-type]-autolead (p;\\$1)
.          shift
.       \}
.       if '\\$1'QUAD' \{\
.          shift
.          ie r all \{\
.             nr all 0 1
.             while \\n+[all]<=5 \{\
.                 get-label-type
.                 ds \\*[label-type]*\\*[spec-type]-quad \\$1
.                 substring \\*[label-type]*\\*[spec-type]-quad 0 0
.                 if '\\$2'ON_LL' \
.                    nr \\*[label-type]*\\*[spec-type]-quad-on-ll 1
.             \}
.          \}
.          el \{\
.             ds \\*[label-type]*\\*[spec-type]-quad \\$1
.             substring \\*[label-type]*\\*[spec-type]-quad 0 0
.             if \\n[\\*[label-type]*\\*[spec-type]-quad-on-ll] \
.                rr \\*[label-type]*\\*[spec-type]-quad-on-ll 
.             if '\\$2'ON_LL' \
.                nr \\*[label-type]*\\*[spec-type]-quad-on-ll 1
.          \}
.          ie '\\$2'ON_LL' .shift 2
.          el  .shift
.       \}
.       if '\\$1'COLOR' \{\
.          shift
.          ie r all \{\
.             nr all 0 1
.             while \\n+[all]<=5 \{\
.                 get-label-type
.                 ds \\*[label-type]*\\*[spec-type]-color \\$1
.             \}
.          \}
.          el .ds \\*[label-type]*\\*[spec-type]-color \\$1
.          if \\n[#PRINT_STYLE]=1 \
.             ds \\*[label-type]*\\*[spec-type]-color black
.          shift
.       \}
.       if '\\$1'ADJUST' \{\
.          shift
.          ie r all \{\
.             nr all 0 1
.             while \\n+[all]<=5 \{\
.                 get-label-type
.                 ds \\*[label-type]*\\*[spec-type]-space \\$1
.             \}
.          \}
.          el .ds \\*[label-type]*\\*[spec-type]-space \\$1
.          if \\n[#PRINT_STYLE]=1 \
.             ds \\*[label-type]*\\*[spec-type]-space +0
.          shift
.       \}
.       if '\\$1'INDENT' \{\
.          shift
.          ie '\\*[label-type]'floating' \{\
.             ie \B'\\$1' \{\
.                nr \\*[label-type]*\\*[spec-type]-indent-l \\$1
.                shift
.             \}
.             el \{\
.                ie '\\$1'RIGHT' \{\
.                   shift
.                   nr \\*[label-type]*\\*[spec-type]-indent-r \\$1
.                   shift
.                \}
.                el \{\
.                   tm1 \
"[mom]: Missing value for INDENT in macro '\\$0' at line \\n[.c].
.                   ab \
[mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.                \}
.             \}
.          \}
.          el \{\
.             shift
.             if !\\n[#SKIP_INDENT_WARNING] \{\
.                tm1 \
"[mom]: '\\$0 \\*[$LABEL-TYPE]' at line \\n[.c] does not take an indent.
.                tm1 \
"        No indent(s) will be applied.
.                nr #SKIP_INDENT_WARNING 1
.             \}
.             if '\\$1'INDENT' .shift
.             if '\\$1'RIGHT'  .shift
.             if \B'\\$1'      .shift
.          \}
.       \}
.    \}
.    ie r all \{\
.       nr all 0 1
.       while \\n+[all]<=5 \{\
.          get-label-type
.          set-defaults
.          set-inline-specs
.       \}
.    \}
.    el \{\
.       set-defaults
.       set-inline-specs
.    \}
.    ds revert-specs \f[]\s[0]\m[]
.    rr #SKIP_INDENT_WARNING
.    rr all
.END
.
.ALIAS CAPTIONS CAPTION_LABEL_SPECS
.ALIAS LABELS   CAPTION_LABEL_SPECS
.ALIAS SOURCES  CAPTION_LABEL_SPECS
\#
\# LABELS and CAPTIONS (floats and [block]quotes)
\# ----------------------------------------------
\# *Arguments:
\#   <text of label or caption> [ CAPTION <text of caption> ] \
\#   [ TO_LIST FIGURES | EQUATIONS | TABLES ]
\# *Function:
\#   Add label/caption to float, quotes, and blockquotes
\# *Notes:
\#   Aliased as CAPTION.  If called as CAPTION, prints all
\#   double-quoted text strings including ".br" or ".sp";
\#   may come at top or bottom of labelled object, or both.
\#   If called as LABEL, optional arg CAPTION attaches caption
\#   text to the label; may only come at bottom of object and
\#   can only take one double-quoted text string.
\#
\# These strings allow users to create labels of the form
\# 'Fig. \*[chapter].\*[fig-label]', e.g. 'Fig. 1.1'
\#
.ds chapter   \\n[#CH_NUM]
.ds fig-label \\n+[fig*label-num]
.ds tbl-label \\n+[tbl*label-num]
.ds eqn-label \\n+[eqn*label-num]
\#
\#
.MAC LABEL END
.    br
.    if \\n[.ns] \{\
.       vpt 0
.       rs
.       nop \&
.       sp -1
.       vpt
.    \}
.    if r chop-space .sp -1
.    rr chop-space
.    if \\n[#QUOTE] .nr q-float 1
.    if '\\$0'CAPTION' \{\
.       ds labelcap caption
.       ds $FLOATING_CAPTION \\$*
.    \}
.    if '\\$0'LABEL' \{\
.       ds labelcap label
.       ds $FLOATING_LABEL \\$1
.       shift
.       nr loop-counter 0 1
.       nr loop-count \\n[#NUM_ARGS]
.       while \\n+[loop-counter]<=\\n[loop-count] \{\
.          if '\\$1'CAPTION' \{\
.             nr with-caption 1
.             ds $FLOATING_CAPTION \\$2
.             shift 2
.          \}
.          if '\\$1'SHORT_CAPTION' \{\
.             ds $LIST_CAPTION \\$2
.             shift 2
.          \}
.          if '\\$1'TO_LIST' \{\
.             nr to-list 1
.             if '\\$2'FIGURES'   .ds $LIST_OF FIGURES
.             if '\\$2'EQUATIONS' .ds $LIST_OF EQUATIONS
.             if '\\$2'TABLES'    .ds $LIST_OF TABLES
.             shift 2
.          \}
.       \}
.    \}
.    if \\n[D-float] \
.       if \\n[.d]>\\n[D-float] \
.          sp \\n[.d]u-\\n[D-float]u
.    rr has-\\*[labelcap]
.    nr has-\\*[labelcap] 1
.    rr @bottom
.    if !\\n[.d]=0 .nr @bottom 1
.    ds ev-current \\n[.ev]
.    ev floating*labelcap
.    evc \\*[ev-current]
.    ps \\n[#DOC_PT_SIZE]u
.    if \\n[floating*\\*[labelcap]-indent-l] \
.       in \\n[floating*\\*[labelcap]-indent-l]u
.    if \\n[floating*\\*[labelcap]-indent-r] \
.       ll -\\n[floating*\\*[labelcap]-indent-r]u
.    ds $QUAD_PREV \\*[$QUAD_VALUE]
.    QUAD \\*[floating*\\*[labelcap]-quad]
.\" 1/4 space before both captions and labels
\!.  if \\\\n[nl]=\\\\n[#PAGE_TOP] .nr deferred-float 1
.    if !\\n[deferred-float] \{\
.       ie !\\n[@bottom] \{\
.          ie '\\n[.z]'' \
.            sp \\n[#DOC_LEAD]u/4u
.          el \
.            if '\\n[.z]'FLOAT*DIV' .sp \\n[#DOC_LEAD]u/4u
.       \}
.       el \{\
.          sp \\n[#DOC_LEAD]u/4u
.          rr @bottom
.       \}
.    \}
\!.  if \\\\n[deferred-float] \{\
.       if !\\n[#QUOTE] .sp -(\\n[#DOC_LEAD]u/4u)
\!.  \}
.    nr floating*\\*[labelcap]-lead-diff \\n[.v]
.    vs \\n[.ps]u+\\n[floating*\\*[labelcap]-autolead]u
.    nr floating*\\*[labelcap]-lead-diff \
        \\n[floating*\\*[labelcap]-lead-diff]-\\n[.v]
.    if !\\n[deferred-float] \
.       RESTORE_SPACE
.    ie '\\*[labelcap]'label' \{\
.       if \\n[to-list] \{\
.\" Strip prefix from label if list-type is being autolabelled
.\" Becomes $LIST_LABEL
.          if '\\*[$LIST_OF]'FIGURES' \
.             if r fig*label-num .STRIP_PRFX_SFFX "\\*[$FLOATING_LABEL]"
.          if '\\*[$LIST_OF]'TABLES' \
.             if r tbl*label-num .STRIP_PRFX_SFFX "\\*[$FLOATING_LABEL]"
.          if '\\*[$LIST_OF]'EQUATIONS' \
.             if r eqn*label-num .STRIP_PRFX_SFFX "\\*[$FLOATING_LABEL]"
.       \}
.       ds $FLOATING_LABEL \
\F[\\\\*[floating*label-family]]\
\f[\\\\*[floating*label-font]]\
\s[\\\\*[floating*label-size-change]]\
\m[\\\\*[floating*label-color]]\
\\*[$FLOATING_LABEL]
.    \}
.    el \{\
.       if !\\n[deferred-float] \
.          sp \\n[floating*caption-lead-diff]u
.       if !'\\*[floating*caption-space]'' \
.          sp \\*[floating*caption-space]
.       while !'\\$1'' \{\
.          nop \
\F[\\*[floating*caption-family]]\
\f[\\*[floating*caption-font]]\
\s[\\*[floating*caption-size-change]]\
\m[\\*[floating*caption-color]]\
\\$1
.          if \\n[.u]=1 .br
.          shift
.       \}
.       if !'\\*[floating*caption-space]'' \
.          sp -\\*[floating*caption-space]
.    \}
.    if \\n[with-caption] \{\
.       nr width-label \w'\\*[$FLOATING_LABEL]'
.       if !\\n[width-label]=0 \
.         as $FLOATING_LABEL \0
.       as $FLOATING_LABEL \
\F[\\\\*[floating*caption-family]]\
\f[\\\\*[floating*caption-font]]\
\s[\\\\*[floating*caption-size-change]]\
\m[\\\\*[floating*caption-color]]\
\\*[$FLOATING_CAPTION]
.       if '\\*[$LIST_CAPTION]'' \
.          ds $LIST_CAPTION \\*[$FLOATING_CAPTION]
.    \}
.    if !'\\*[$FLOATING_LABEL]'' \{\
.       sp \\n[floating*label-lead-diff]u
.       if !'\\*[floating*label-space]'' \
.          sp \\*[floating*label-space]
.       nop \\*[$FLOATING_LABEL]
.       if \\n[.u]=1 .br
.       if !'\\*[floating*label-space]'' \
.          sp -\\*[floating*label-space]
.    \}
.\" 1/4 space after captions and labels
.    ie !\\n[@bottom] \
.       sp \\n[#DOC_LEAD]u/4u
.    el \{\
.       if '\\n[.z]'FLOAT*DIV' \{\
.          sp \\n[#DOC_LEAD]u/4u
\!.        if \\\\n[deferred-float] \
.             sp -(\\n[#DOC_LEAD]u/4u)
.       \}
.    \}
\!.  rr deferred-float
.    ll
.    vs
.    QUAD \\*[$QUAD_PREV]
.    in
.    ev
.    if \\n[to-list] \{\
.       nr loop-counter 0 1
.       nr loop-count 2
.       ds labelcap label
.       while \\n+[loop-counter]<=\\n[loop-count] \{\
.          ds \\*[labelcap]-family      \\*[floating*\\*[labelcap]-family]
.          ds \\*[labelcap]-font        \\*[floating*\\*[labelcap]-font]
.          ds \\*[labelcap]-size-change \\*[floating*\\*[labelcap]-size-change]
.          ds \\*[labelcap]-color       \\*[floating*\\*[labelcap]-color]
.          ie '\\*[$LISTS_FAM]'' \
.             ds floating*\\*[labelcap]-family \\*[$DOC_FAM]
.          el \
.             ds floating*\\*[labelcap]-family \\*[$LISTS_FAM]
.          if '\\*[$LISTS_FT]'' \
.             ds floating*\\*[labelcap]-font R
.          ds floating*\\*[labelcap]-size-change +0
.          ds floating*\\*[labelcap]-color pdf:href.colour
.          ds labelcap caption
.       \}
.       ie '\\*[$LIST_LABEL]'' .TO_\\*[$LIST_OF] "\\*[$FLOATING_LABEL]
.       el .TO_\\*[$LIST_OF] "\\*[$LIST_LABEL]" "\\*[$LIST_CAPTION]
.       rr to-list
.       nr loop-counter 0 1
.       nr loop-count 2
.       ds labelcap label
.       while \\n+[loop-counter]<=\\n[loop-count] \{\
.          ds floating*\\*[labelcap]-family      \\*[\\*[labelcap]-family]
.          ds floating*\\*[labelcap]-font        \\*[\\*[labelcap]-font]
.          ds floating*\\*[labelcap]-size-change \\*[\\*[labelcap]-size-change]
.          ds floating*\\*[labelcap]-color       \\*[\\*[labelcap]-color]
.          ds labelcap caption
.       \}
.    \}
.    rr with-caption
.    rm $FLOATING_CAPTION
.    rm $FLOATING_LABEL
.    rm $LIST_LABEL
.    rm $LIST_CAPTION
.END
.
.ALIAS CAPTION LABEL
.
.MAC STRIP_PRFX_SFFX END
.\" Strip suffix from label string
.       ds suffix \\$1
.       substring suffix -1
.\" If suffix is '.' ',' ':' or ')', remove it.
.       if '\\*[suffix]'.' .nr strip-suffix 1
.       if '\\*[suffix]',' .nr strip-suffix 1
.       if '\\*[suffix]':' .nr strip-suffix 1
.       if '\\*[suffix]')' .nr strip-suffix 1
.       if \\n[strip-suffix] \{\
.          ds $LIST_LABEL \\$1
.          substring $LIST_LABEL 0 -2
.       \}
.       rr strip-suffix
.       if '\\*[$LIST_LABEL]'' .ds $LIST_LABEL \\$1
.\" Remove prefix (e.g. "Fig. ") by looping through $LIST_LABEL
.\" until a digit is encountered
.       nr loop-counter 100 \" arbitrary
.       nr loop-count 0 1
.       while \\n+[loop-count]<=\\n[loop-counter] \{\
.          substring $LIST_LABEL 1
.          if \B'\\*[$LIST_LABEL]' .break
.       \}
.       substring $LIST_LABEL 1
.END
\#
\# CAPTION_AFTER_LABEL
\# -------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Sets register indicating non-MLA captions should come after labels.
\#
.MAC CAPTION_AFTER_LABEL END
.    if '\\$1'IMG' .ds type pdf-img
.    if '\\$1'PIC' .ds type pic
.    if '\\$1'TBL' .ds type tbl
.    if !\\n[#MLA] \{\
.       nr \\*[type]*caption-after-label 1
.       if '\\$1'ALL' \{\
.          nr pdf-img*caption-after-label 1
.          nr tbl*caption-after-label 1
.          nr pic*caption-after-label 1
.       \}
.       if !'\\$2'' \{\
.          ie !'\\$1'ALL' .rr \\*[type]*caption-after-label
.          el \{\
.             rr pdf-img*caption-after-label
.             rr tbl*caption-after-label
.             rr pic*caption-after-label
.          \}
.       \}
.    \}
.END
\#
\# AUTOLABELLING
\# -------------
\# *Argument:
\#   [ PREFIX <prefix> SUFFIX <suffix> ] | <anything>
\# *Function:
\#   Turns label autonumbering on of off; optionally lets user set
\#   prefix and suffix for labels.
\# *Notes:
\#   Aliased for images (pdf), tbl, pic, and eqn.
\#
.MAC AUTOLABEL END
.    if '\\$0'AUTOLABEL_EQUATIONS' .ds label-type eqn
.    if '\\$0'AUTOLABEL_TABLES'    .ds label-type tbl
.    if '\\$0'AUTOLABEL_PIC' \{\
.       ds label-type pic
.       nr fig*autolabel 1
.    \}
.    if '\\$0'AUTOLABEL_IMAGES' \{\
.        ds label-type pdf-img
.        nr fig*autolabel 1
.    \}
.    if !'\\$1'' \{\
.       ds \\*[label-type]-label-args \\$1
.       substring \\*[label-type]-label-args -1 -3
.    \}
.    if '\\*[\\*[label-type]-label-args]'FIX' .nr \\*[label-type]-label-args 1
.    if '\\*[\\*[label-type]-label-args]'TER' .nr \\*[label-type]-label-args 1
.    if !\\n[\\*[label-type]*label-num] \
.       nr \\*[label-type]*label-num 0 1
.    if '\\*[label-type]'pdf-img' \
.       if !\\n[fig*label-num] .nr fig*label-num 0 1
.    if '\\*[label-type]'pic' \
.       if !\\n[pic*label-num] .nr fig*label-num 0 1
.    nr \\*[label-type]*autolabel 1
.    nr loop-counter 0 1
.    nr loop-count \\n[#NUM_ARGS]
.    while \\n+[loop-counter]<=\\n[loop-count] \{\
.       if '\\$1'PREFIX' \{\
.          ds \\*[label-type]*label-prfx \\$2
.          nr \\*[label-type]*label-prfx-set 1
.          shift 2
.       \}
.       if '\\$1'SUFFIX' \{\
.          ds \\*[label-type]*label-sffx \\$2
.          nr \\*[label-type]*label-sffx-set 1
.          shift 2
.       \}
.       if '\\$1'PREFIX_CHAPTER' \{\
.          if \\n[fig*autolabel] .nr fig*label-with-chapter 1
.          nr \\*[label-type]*label-with-chapter 1
.          shift 1
.          if \B'\\$1' \{\
.             nr #CH_NUM \\$1
.             shift
.          \}
.       \}
.    \}
.    if '\\*[\\*[label-type]*label-prfx]'' \{\
.       if '\\*[label-type]'eqn' \
.          if !\\n[\\*[label-type]*label-prfx-set] \
.             ds \\*[label-type]*label-prfx (\"
.       if '\\*[label-type]'pic' \
.          if !\\n[\\*[label-type]*label-prfx-set] \
.             ds \\*[label-type]*label-prfx Fig. \"
.       if '\\*[label-type]'pdf-img' \
.          if !\\n[\\*[label-type]*label-prfx-set] \
.             ds \\*[label-type]*label-prfx Fig. \"
.       if '\\*[label-type]'tbl' \
.          if !\\n[\\*[label-type]*label-prfx-set] \
.             ds \\*[label-type]*label-prfx Table \"
.    \}
.    if '\\*[\\*[label-type]*label-sffx]'' \{\
.       if '\\*[label-type]'eqn' \
.          if !\\n[\\*[label-type]*label-sffx-set] \
.             ds \\*[label-type]*label-sffx )\"
.       if '\\*[label-type]'pic' \
.          if !\\n[\\*[label-type]*label-sffx-set] \
.             ds \\*[label-type]*label-sffx .\"
.       if '\\*[label-type]'pdf-img' \
.          if !\\n[\\*[label-type]*label-sffx-set] \
.             ds \\*[label-type]*label-sffx .\"
.       if '\\*[label-type]'tbl' \
.          if !\\n[\\*[label-type]*label-sffx-set] \
.             ds \\*[label-type]*label-sffx .\"
.    \}
.    if \\n[\\*[label-type]-label-args]>0 \{\
.       if \\n[\\*[label-type]*label-prfx-set]+\\n[\\*[label-type]*label-sffx-set]=1 \{\
.          ie (\\n[\\*[label-type]*label-prfx-set]=1)&(\\n[\\*[label-type]*label-sffx-set]=0) \
.             ds missing-arg SUFFIX
.          el .ds missing-arg PREFIX
.          tm1 "[mom]: You must supply a \\*[missing-arg] argument to \\$0.
.          tm1 "       If you wish the \\*[missing-arg] to be blank, use \\*[missing-arg] "".
.          ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.       \}
.    \}
.    if \\n[#NUM_ARGS]=1 \{\
.       rr fig*autolabel
.       rr \\*[label-type]*autolabel
.       rr \\*[label-type]*label-prfx-set
.       rr \\*[label-type]*label-sffx-set
.    \}
.    rr \\*[label-type]-label-args
.END
\#
.ALIAS AUTOLABEL_EQUATIONS AUTOLABEL
.ALIAS AUTOLABEL_IMAGES    AUTOLABEL
.ALIAS AUTOLABEL_PIC       AUTOLABEL
.ALIAS AUTOLABEL_TABLES    AUTOLABEL
\#
\# SET AUTOLABEL NUMBER
\# --------------------
\# *Argument:
\#   FIG | TBL | PIC | EQN <n>
\# *Function:
\#   Sets the autolabel number for the corresponding label type.
\# *Notes:
\#   Used to set autolabel number when manual labelling of floats
\#   (in conjunction with TO_LIST) disrupts auto-incrementing.
\#   
.MAC SET_AUTOLABEL END
.    rm labelnum-type
.    if '\\$1'FIG' .ds labelnum-type fig
.    if '\\$1'TBL' .ds labelnum-type tbl
.    if '\\$1'PIC' .ds labelnum-type pic
.    if '\\$1'EQN' .ds labelnum-type eqn
.    nr labelnum \\$2-1
.    nr \\*[labelnum-type]*label-num \\n[labelnum] 1
.END
\#
\# MLA STYLE
\# ---------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Sets or removes register #MLA.
\# *Notes:
\#   MLA formatting differs from other styles wrt caption and
\#   label placement.
\#
.MAC MLA END
.    ie '\\$1'' \{\
.       nr #MLA 1
.       nr pdf-img*caption-after-label 1
.       nr pic*caption-after-label 1
.       rr tbl*caption-after-label
.    \}
.    el \
.       rr #MLA
.END
\#
.MAC mla@error END
.    tm1 "[mom]: MLA style enabled, but \\$1 has no corresponding \\$2.
.    ab   [mom]: Aborting '\\$3' at \\$4, line \\$5.
.END
\#
\# LISTS_OF
\# --------
\# *Aliases:
\#   LIST_OF_EQUATIONS
\#   LIST_OF_FIGURES
\#   LIST_OF_TABLES
\# *Arguments:
\#   [ TITLE_STRING <string> ] [ START_PAGENUM <pagenumber> ]
\# *Function:
\#   Generates lists-of based on calling alias.
\# *Notes:
\#   Called at end of file.
\#   If after TOC, and TOC is being auto-relocated, lists are also
\#   relocated.  If called before, lists are output at end of file.
\#
.MAC LISTS_OF END
.    EOL
.    ds $LIST_TYPE \\$0
.    nr #LISTS 1
.    substring $LIST_TYPE -1 -4
.    if '\\*[$LIST_TYPE]'URES' \{\
.       ds $LIST_TYPE FIGURES
.       ds list-type fig
.       ds label-type fig
.       ds \\*[$LIST_TYPE]_TITLE_STRING "List of Figures
.    \}
.    if '\\*[$LIST_TYPE]'BLES' \{\
.       ds $LIST_TYPE TABLES
.       ds list-type tbl
.       ds label-type tbl
.       ds \\*[$LIST_TYPE]_TITLE_STRING "List of Tables
.    \}
.    if '\\*[$LIST_TYPE]'IONS' \{\
.       ds $LIST_TYPE EQUATIONS
.       ds list-type eqn
.       ds label-type eqn
.       ds \\*[$LIST_TYPE]_TITLE_STRING "List of Equations
.    \}
.    nr #LIST_OF_\\*[$LIST_TYPE] 1
.    nr loop-count 0 1
.    nr loop-counter \\n[#NUM_ARGS]
.    while \\n+[loop-count]<=\\n[loop-counter] \{\
.       if '\\$1'TITLE_STRING' \{\
.          ds \\*[$LIST_TYPE]_TITLE_STRING \\$2
.          shift 2
.       \}
.       if '\\$1'START_PAGENUM' \{\
.          nr #\\*[$LIST_TYPE]_START_PAGENUM \\$2
.          shift 2
.       \}
.    \}
.    if dPDF.EXPORT \
.       if \\n[#FLEX_ACTIVE] \
.          if !\\n[#NO_FLEX] \
.             tm .ds pre-list-\\n%@\\n[#COL_NUM] 1
.    char \[leader] " .
.    LEADER_CHARACTER \[leader]
.    if \\n[#LINENUMBERS]=1 \{\
.       NUMBER_LINES OFF
.       nr #LINENUMBERS 2
.    \}
.    if \\n[#FINIS] \{\
.       if \\n[#FOOTERS_WERE_ON] \
.          FOOTERS
.    \}
.    if \\n[#FOOTERS_ON]=1 \{\
.       if !'\\*[$HDRFTR_CENTER_OLD]'' .ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_OLD]
.       ie \\n[#LISTS_NO_PAGENUM]=1 .PAGINATION OFF
.       el .PAGINATE
.    \}
.    if \\n[#FOOTERS_WERE_ON] \
.       if !\\n[#FINIS] .FOOTERS OFF
.    rr #COLUMNS
.    COLLATE
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#SINGLE_SPACE] .LS 24
.       DOC_LEAD_ADJUST
.    \}
.    if \\n[#FINIS] \{\
.       if \\n[#FOOTERS_WERE_ON] .FOOTERS
.       rr #FOOTERS_WERE_ON
.       if \\n[#PAGINATION_WAS_ON] \{\
.          nr #PAGINATE 1
.          rr #PAGINATION_WAS_ON
.       \}
.       rr #FINIS
.    \}
.    ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_NEW]
.    rm $HDRFTR_CENTER_OLD
.    rm $HDRFTR_CENTER_NEW
.    rr #COLLATED_DOC
.    DOCTYPE DEFAULT
.    DOCHEADER
.    rr #DOCHEADER_ADVANCE
.    TITLE "\\*[\\*[$LIST_TYPE]_TITLE_STRING]
.    AUTHOR ""
.    L_MARGIN \\n[#DOC_L_MARGIN]u
.    LL       \\n[#DOC_L_LENGTH]u
.    if '\\*[$LISTS_FAM]'' \
.       ds $LISTS_FAM \\*[$TOC_FAM]
.    if '\\*[$LISTS_FT]'' \
.       ds $LISTS_FT \\*[$TOC_TITLE_FT]
.    if !\\n[#LISTS_PS] \
.       nr #LISTS_PS \\n[#TOC_PS]
.    ps \\n[#LISTS_PS]u
.    if !\\n[#LISTS_LEAD] \
.       nr #LISTS_LEAD \\n[#TOC_LEAD]
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#LISTS_LEAD_ADJUST]=1 \{\
.          nr #DOC_LEAD \\n[#LISTS_LEAD]
.          DOC_LEAD_ADJUST
.          TRAPS
.       \}
.       el \{\
.          nr #DOC_LEAD \\n[#LISTS_LEAD]
.          DOC_LEAD_ADJUST OFF
.       \}
.    \}
.    ie !'\\*[$LISTS_TITLE_QUAD]'' \
.       DOCHEADER_QUAD \\*[$LISTS_TITLE_QUAD]
.    el .DOCHEADER_QUAD \\*[$TOC_HEADER_QUAD]
.    if !'\\*[$LISTS_TITLE_FAM]'' \
.       TITLE_FAMILY \\*[$LISTS_TITLE_FAM]
.    if !'\\*[$LISTS_TITLE_FT]'' \
.       TITLE_FONT  \\*[$LISTS_TITLE_FT]
.    if !'\\*[$LISTS_TITLE_SIZE]'' \
.       TITLE_SIZE \\*[$LISTS_TITLE_SIZE]
.    if !'\\*[$LISTS_TITLE_COLOR]'' \
.       TITLE_COLOR \\*[$LISTS_TITLE_COLOR]
.    if \\n[#LISTS_TITLE_CAPS] \
.       TITLE_CAPS
.    if \\n[#LISTS_TITLE_SMALLCAPS] \
.       TITLE_SMALLCAPS
.    if \\n[#LISTS_TITLE_UNDERSCORE] \{\
.       TITLE_UNDERSCORE \
\\*[DOUBLE] \
\\*[$LISTS_OF_UL_WT] \
\\*[$LISTS_OF_UL_GAP] \
\\*[$LISTS_OF_RULE_GAP]
.    \}
.    if '\\*[$LISTS_PN_FAM]'' \
.       ds $LISTS_PN_FAM \\*[$TOC_PN_FAM]
.    if '\\*[$LISTS_PN_FT]'' \
.       ds $LISTS_PN_FT \\*[$TOC_PN_FT]
.    if '\\*[$LISTS_PN_SIZE_CHANGE]'' \
.       ds $LISTS_PN_SIZE_CHANGE \\*[$TOC_PN_SIZE_CHANGE]
.    if !\\n[#EQN_PN_PADDING] \
.       nr #EQN_PN_PADDING \\n[#TOC_PN_PADDING]
.    if !\\n[#FIG_PN_PADDING] \
.       nr #FIG_PN_PADDING \\n[#TOC_PN_PADDING]
.    if !\\n[#TBL_PN_PADDING] \
.       nr #TBL_PN_PADDING \\n[#TOC_PN_PADDING]
.    ie '\\*[$LISTS_PAGENUM_STYLE]'' \
.       PAGENUM_STYLE \\*[$TOC_PAGENUM_STYLE]
.    el \
.       PAGENUM_STYLE \\*[$LISTS_PAGENUM_STYLE]
.    if r #\\*[$LIST_TYPE]_START_PAGENUM  \
.       PAGENUMBER \\n[#\\*[$LIST_TYPE]_START_PAGENUM]
.    if r #LISTS_NO_PAGENUM .PAGINATION off
.    HEADER_LEFT "\\*[$HDRFTR_LEFT]
.    HEADER_RIGHT "\\*[$HDRFTR_RIGHT]
.    HEADER_CENTER "\\*[\\*[$LIST_TYPE]_TITLE_STRING]
.    if \\n[#LINENUMBERS]=2 .nr #LINENUMBERS 3
.\" Get num placeholders for ch. num and label num.
.    if \\n[\\*[list-type]*autolabel] \{\
.       if \\n[\\*[label-type]*label-with-chapter] \{\
.          if \\n[#CH_NUM]<1000 .nr chapno-width 3
.          if \\n[#CH_NUM]<100  .nr chapno-width 2
.          if \\n[#CH_NUM]<10   .nr chapno-width 1
.       \}
.       if \\n[\\*[list-type]*label-num]<1000 .nr label-width 3
.       if \\n[\\*[list-type]*label-num]<100  .nr label-width 2
.       if \\n[\\*[list-type]*label-num]<10   .nr label-width 1
.\" Calculate width of label-num tab
.      nr label-width \\n[\\*[list-type]*label-width]
.    \}
.    if \\n[#SLANT_ON] .nop \\*[SLANTX]
.    if \\n[#COLUMNS]=1 .nr #COLUMNS 0
.    START
.    if \\n[#PRINT_STYLE]=2 .sp -1
.    if '\\*[$LIST_TYPE]'FIGURES'   .LIST_OF_FIG
.    if '\\*[$LIST_TYPE]'TABLES'    .LIST_OF_TBL
.    if '\\*[$LIST_TYPE]'EQUATIONS' .LIST_OF_EQN
.    if \\n[#LINENUMBERS]=3 \{\
.       NUMBER_LINES RESUME
.       nr #LINENUMBERS 1
.       nn 1
.    \}
.    rr #LISTS
.    pdfsync
.END
.\"
.ALIAS LIST_OF_EQUATIONS LISTS_OF
.ALIAS LIST_OF_FIGURES   LISTS_OF
.ALIAS LIST_OF_TABLES    LISTS_OF
\#
\# LISTS-OF STYLE
\# --------------
\# *Arguments:
\#   FAMILY        fam \
\#   FONT          sty \
\#   PT_SIZE       size \
\#   LEAD          leading [ADJUST] \
\#   TITLE_FAMILY  fam \
\#   TITLE_FONT    sty \
\#   TITLE_SIZE    +|-size \
\#   TITLE_QUAD    LEFT | CENTER | RIGHT \
\#   TITLE_COLOR   color \
\#   TITLE_CAPS    \
\#   TITLE_NO_CAPS \
\#   TITLE_SMALLCAPS \
\#   TITLE_NO_SMALLCAPS \
\#   TITLE_UNDERSCORE [ DOUBLE] <wt> <gap> (dbl-rule-gap) \
\#   NO_PAGINATION \
\#   PAGENUM_STYLE format \
\#   PN_FAMILY     fam \
\#   PN_FONT       sty \
\#   PN_SIZE       +|-size \
\#   PN_PADDING    n
\# *Function:
\#   Allows setting of all style parameters for lists-of.
\# *Notes:
\#   Assumption is that lists-of will all have the same style.
\#   TOC style is used if LISTS_STYLE is omitted.
\#
.MAC LISTS_STYLE END
.    nr loop-count 0 1
.    nr loop-counter \\n[#NUM_ARGS]
.    while \\n+[loop-count]<=\\n[loop-counter] \{\
.       if '\\$1'FAMILY' \{\
.          ds $LISTS_FAM \\$2
.          shift 2
.       \}
.       if '\\$1'FONT' \{\
.          ds $LISTS_FT \\$2
.          shift 2
.       \}
.       if '\\$1'TITLE_FAMILY' \{\
.          ds $LISTS_TITLE_FAM \\$2
.          shift 2
.       \}
.       if '\\$1'TITLE_FONT' \{\
.          ds $LISTS_TITLE_FT \\$2
.          shift 2
.       \}
.       if '\\$1'TITLE_SIZE' \{\
.          ds $LISTS_TITLE_SIZE \\$2
.          shift 2
.       \}
.       if '\\$1'TITLE_QUAD' \{\
.          ds $LISTS_TITLE_QUAD \\$2
.          shift 2
.       \}
.       if '\\$1'TITLE_COLOR' \{\
.          ds $LISTS_TITLE_COLOR \\$2
.          shift 2
.       \}
.       if '\\$1'TITLE_CAPS' \{\
.          nr #LISTS_TITLE_CAPS 1
.          shift 1
.       \}
.       if '\\$1'TITLE_NO_CAPS' \{\
.          rr #LISTS_TITLE_CAPS
.          shift 1
.       \}
.       if '\\$1'TITLE_SMALLCAPS' \{\
.          nr #LISTS_TITLE_SMALLCAPS 1
.          shift 1
.       \}
.       if '\\$1'TITLE_NO_SMALLCAPS' \{\
.          rr #LISTS_TITLE_NO_SMALLCAPS
.          shift 1
.       \}
.\" UNDERSCORE and UNDERLINE are identical, but we can't evaluate
.\" the results of two string comparisons.
.       if '\\$1'TITLE_UNDERSCORE' \{\
.          nr #LISTS_TITLE_UNDERSCORE 1
.          shift
.          ie '\\$1'DOUBLE' \{\
.             ds DOUBLE DOUBLE
.             shift
.             if \B'\\$1' \{\
.                ds $LISTS_OF_UL_WT \\$1
.                shift
.             \}
.             if \B'\\$1' \{\
.                ds $LISTS_OF_UL_GAP \\$1
.                shift
.             \}
.             if \B'\\$1' \{\
.                ds $LISTS_OF_RULE_GAP \\$1
.                shift
.             \}
.          \}
.          el \{\
.             if \B'\\$1' \{\
.                ds $LISTS_OF_UL_WT \\$1
.                shift
.             \}
.             if \B'\\$1' \{\
.                ds $LISTS_OF_UL_GAP \\$1
.                shift
.             \}
.          \}
.       \}
.       if '\\$1'TITLE_UNDERLINE' \{\
.          nr #LISTS_TITLE_UNDERSCORE 1
.          shift
.          ie '\\$1'DOUBLE' \{\
.             ds DOUBLE DOUBLE
.             shift
.             if \B'\\$1' \{\
.                ds $LISTS_OF_UL_WT \\$1
.                shift
.             \}
.             if \B'\\$1' \{\
.                ds $LISTS_OF_UL_GAP \\$1
.                shift
.             \}
.             if \B'\\$1' \{\
.                ds $LISTS_OF_RULE_GAP \\$1
.                shift
.             \}
.          \}
.          el \{\
.             if \B'\\$1' \{\
.                ds $LISTS_OF_UL_WT \\$1
.                shift
.             \}
.             if \B'\\$1' \{\
.                ds $LISTS_OF_UL_GAP \\$1
.                shift
.             \}
.          \}
.       \}
.       if '\\$1'TITLE_NO_UNDERSCORE' \{\
.          rr #LISTS_TITLE_UNDERSCORE 1
.          rm DOUBLE
.          rm $LISTS_OF_UL_WT
.          rm $LISTS_OF_UL_GAP
.          rm $LISTS_OF_RULE_GAP
.          shift
.       \}
.       if '\\$1'TITLE_NO_UNDERLINE' \{\
.          rr #LISTS_TITLE_UNDERSCORE 1
.          rm DOUBLE
.          rm $LISTS_OF_UL_WT
.          rm $LISTS_OF_UL_GAP
.          rm $LISTS_OF_RULE_GAP
.          shift
.       \}
.       if '\\$1'PT_SIZE' \{\
.          nr #LISTS_PS (p;\\$2)
.          shift 2
.       \}
.       if '\\$1'LEAD' \{\
.          nr #LISTS_LEAD (p;\\$2)
.          ie !'\\$3'ADJUST' \{\
.             nr #LISTS_LEAD_ADJUST 0
.             shift 2
.          \}
.          el \{\
.             nr #LISTS_LEAD_ADJUST 1
.             shift 3
.          \}
.       \}
.       if '\\$1'NO_PAGINATION' \{\
.          nr #LISTS_NO_PAGENUM 1
.          shift 1
.       \}
.       if '\\$1'PAGENUM_STYLE' \{\
.          ds $LISTS_PAGENUM_STYLE \\$2
.          shift 2
.       \}
.       if '\\$1'PN_FAMILY' \{\
.          ds $LISTS_PN_FAM \\$2
.          shift 2
.       \}
.       if '\\$1'PN_FONT' \{\
.          ds $LISTS_PN_FT \\$2
.          shift 2
.       \}
.       if '\\$1'PN_SIZE' \{\
.          ds $LISTS_PN_SIZE_CHANGE \\$2
.          shift 2
.       \}
.       if '\\$1'EQN_PN_PADDING' \{\
.          nr #EQN_PN_PADDING \\$2
.          shift 2
.       \}
.       if '\\$1'FIG_PN_PADDING' \{\
.          nr #FIG_PN_PADDING \\$2
.          shift 2
.       \}
.       if '\\$1'TBL_PN_PADDING' \{\
.          nr #TBL_PN_PADDING \\$2
.          shift 2
.       \}
.    \}
.END
\#
\# Lists-of collector
\# Strings to allocate space for leaders and entry page numbers
\#
.ds $LISTS_PN \\*[ST102]\F[\\*[$LISTS_PN_FAM]]\f[\\*[$LISTS_PN_FT]]\
\s[\\n[#LISTS_PS]u]^\\*[ST102X]\\*[ST103]\s[\\\\*[$LISTS_PN_SIZE_CHANGE]]\
\h'.5m'\h'\w'0'u*\\\\n[#LISTS_PN_PADDING]u'\\*[ST103X]
\#
.ds $LISTS_PN_TYPEWRITE \\*[ST102]^\\*[ST102X]\\*[ST103]\|\
\h'\w'\0'u*\\\\n[#LISTS_PN_PADDING]u'\\*[ST103X]
\#
.MAC LISTS_COLLECTOR END
.    nr #LISTS_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.    if \\n[#KERN] .nr #RESTORE_KERN 1
.    KERN OFF
.    if '\\$0'TO_EQUATIONS' \{\
.       ds list-type eqn
.       ds label-type eqn
.       da LIST_OF_EQN
\!.     nr #LISTS_PN_PADDING \\\\n[#EQN_PN_PADDING]
.    \}
.    if '\\$0'TO_FIGURES' \{\
.       ds list-type fig
.       ds label-type fig
.       if (\\n[pdf-img*have-label]=1):(\\n[pdf-img*autolabel]=1):\
(\\n[pic*autolabel]=1):(\\n[pic*have-label]=1) \{\
.          nr \\*[label-type]*have-label 1
.          if !'\\*[pdf-img*label]'' .rn pdf-img*label \\*[label-type]*label
.          if !'\\*[pic*label]'' .rn pic*label \\*[label-type]*label
.       \}
.       da LIST_OF_FIG
\!.     nr #LISTS_PN_PADDING \\\\n[#FIG_PN_PADDING]
.    \}
.    if '\\$0'TO_TABLES' \{\
.       ds list-type tbl
.       ds label-type tbl
.       da LIST_OF_TBL
\!.     nr #LISTS_PN_PADDING \\\\n[#TBL_PN_PADDING]
.    \}
.    br
.    ie \\n[#PRINT_STYLE]=1 \{\
\!.     fam \\*[$TYPEWRITER_FAM]
\!.     ft  R
\!.     ps \\*[$TYPEWRITER_PS]
.       ds _TYPEWRITE _TYPEWRITE
.    \}
.    el \{\
\!.     FAMILY \\\\*[$LISTS_FAM]
\!.     FONT \\\\*[$LISTS_FT]
\!.     ps \\\\n[#LISTS_PS]u
.    \}
.    if \\n[#PRINT_STYLE]=2 .rm _TYPEWRITE
\!.  PAD_MARKER ^
\!.  vpt 0
.    ie !\\n[\\*[label-type]*autolabel] \{\
.\" If there is a label...
.       if !'\\*[\\*[label-type]*label]'' \
\!.     PAD \
"\\*[ST100]\h'\w'\\*[\\*[label-type]*label]'u'\\*[ST100X]\0\\*[ST101]\h'\w'\\$2'u'\\*[ST101X]\\\\*[$LISTS_PN\\*[_TYPEWRITE]]" \
"\*[PDFBOOKMARK.NAME]"
.\" If there is no label...
.       if '\\*[\\*[label-type]*label]'' \
\!.     PAD \
"\\*[ST100]\\*[ST100X]\\*[ST101]\h'\w'\\$1'u'\0\\*[ST101X]\\\\*[$LISTS_PN\\*[_TYPEWRITE]]" \
"\*[PDFBOOKMARK.NAME]"
.    \}
.\" If autolabelling...
.    el \
\!.     PAD \
"\\*[ST100]\h'\\\\n[label-width]u'\\*[ST100X]\ \ \ \\*[ST101]\h'\w'\\$2'u'\\*[ST101X]\\\\*[$LISTS_PN\\*[_TYPEWRITE]]" \
"\*[PDFBOOKMARK.NAME]"
\!.  PAD_MARKER #
\!.  EOL
.    ie !\\n[\\*[label-type]*autolabel] \
\!.     ST 100 L
.    el \
\!.     ST 100 R
\!.  ST 101 L
\!.  ST 102 L
\!.  ST 103 R
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\\\*[$LISTS_FAM]
\!.     FT      \\\\*[$LISTS_FT]
\!.     ps \\\\n[#LISTS_PS]u
.    \}
\!.  TAB 100
\!.  PDF_LINK \\*[list-type]:\\n[lists*target] "\\$1"
\!.  TN
\!.  vpt 0
\!.  PDF_LINK \\*[list-type]:\\n[lists*target] "\\$2"
\!.  TN
\!.  vpt 0
\!.  PRINT \fR\\*[LEADER]\f[]
\!.  TN
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\\\*[$LISTS_PN_FAM]
\!.     FT      \\\\*[$LISTS_PN_FT]
\!.     ps \\\\*[$LISTS_PN_SIZE_CHANGE]
.    \}
\!.  PRINT \\n[#LISTS_ENTRY_PN]
\!.  TQ
\!.  vpt
.    da
.    if \\n[#RESTORE_KERN] .KERN
.END
.
.ALIAS TO_EQUATIONS LISTS_COLLECTOR
.ALIAS TO_FIGURES   LISTS_COLLECTOR
.ALIAS TO_TABLES    LISTS_COLLECTOR
\#
\# ***tbl***
\#
\# Support for multipage tables with headers borrowed from ms and
\# mommified by Robin Haberkorn <robin.haberkorn@googlemail.com>
\# with extensions by Peter Schaffter.
\#
.nr tbl*have-header 0
.ds T&
\#
.MAC TS END
.    if \\n[.t]<\\n[#DOC_LEAD] .nr begin-tbl 1
.    br
.    rr begin-tbl
.    rm tbl*caption
.    rm tbl*label
.    rr tbl*have-caption
.    rr tbl*have-label
.    rr tbl*have-header
.    rr float*tbl
.    rr tbl*boxed
.    nr ind-pre-tbl  \\n[.i]
.    nr ll-pre-tbl   \\n[.l]
.    nr lead-pre-tbl \\n[.v]
.    nr tbl*needs 1
.    nr doing-tbl 1
.    if !'\\n[.z]'FLOAT*DIV' \{\
.       if \\n[.u] .nr fill 1
.       nf
.    \}
.    if '\\n[.z]'FLOAT*DIV' .nr float*tbl 1
.    if !'\\n[.z]'FLOAT*DIV' \{\
.       if \\n[.t]=1 \{\
.          if !\\n[@TOP] \{\
.             ie \\n[#COLUMNS] .COL_NEXT internal
.             el .NEWPAGE
.          \}
.       \}
.    \}
.    nr loop-count 0 1
.    nr loop-counter \\n[#NUM_ARGS]
.    while \\n+[loop-count]<=\\n[loop-counter] \{\
.       if '\\$1'H' \{\
.          nr tbl*have-header 1
.          shift
.          if \\n[#NUM_ARGS]=0 .nr tbl*plain 1
.       \}
.       if '\\$1'BOXED' \{\
.          nr tbl*boxed 1
.          shift
.       \}
.       if '\\$1'CENTER' \{\
.          if \\n[#INDENT_BOTH_ACTIVE] \{\
.             IBX
.             nr #RESTORE_INDENT_BOTH 1
.          \}
.          nr tbl*center 1
.          shift
.       \}
.       if '\\$1'CENTRE' \{\
.          if \\n[#INDENT_BOTH_ACTIVE] \{\
.             IBX
.             nr #RESTORE_INDENT_BOTH 1
.          \}
.          nr tbl*center 1
.          shift
.       \}
.       if '\\$1'NEEDS' \{\
.          nr tbl*needs \\$2
.          shift 2
.       \}
.       if '\\$1'NO_SHIM' \{\
.          nr tbl*no-shim 1
.          shift
.       \}
.       if '\\$1'NO_FLEX' \{\
.          nr tbl*no-flex 1
.          shift
.       \}
.       if '\\$1'ADJUST' \{\
.          ds tbl*space-adj \\$2
.          shift 2
.       \}
.       if '\\$1'CAPTION' \{\
.          nr tbl*have-caption 1
.          ds tbl*caption \\$2
.          shift 2
.       \}
.       if '\\$1'SHORT_CAPTION' \{\
.          ds tbl*caption-short \\$2
.          shift 2
.       \}
.       if '\\$1'LABEL' \{\
.          nr tbl*have-label 1
.          ds tbl*label \\$2
.          shift 2
.       \}
.       if '\\$1'TARGET' \{\
.          ds target "\\$2
.          PDF_TARGET "\\*[target]
.          shift 2
.       \}
.    \}
.    if (\\n[tbl*have-label]=1):(\\n[tbl*autolabel]=1) \
.       ds label-type tbl
.    if (\\n[tbl*have-caption]=1)&(\\n[tbl*have-header]=0) \
.       tbl*caption-warning
.    if \\n[tbl*boxed]=1 \{\
.       if (\\n[tbl*have-label]=0)&(\\n[tbl*have-caption]=0)&\
(\\n[tbl*autolabel]=0)&(\\n[tbl*have-source]=0) \
.       nr tbl*plain-boxed 1
.    \}
.    if !\\n[tbl*have-header] .nr tbl*no-header 1
.    ds tbl*label-sffx-tmp \\*[tbl*label-sffx]
.    if !'\\*[tbl*label-sffx-tmp]'' .substring tbl*label-sffx-tmp -1
.    if '\\*[tbl*label-sffx-tmp]'.' \
.       if (\\n[tbl*caption-after-label]=0):(\\n[#MLA]=1) .chop tbl*label-sffx
.    if \\n[tbl*caption-after-label] \{\
.       if !'\\*[tbl*label-sffx]'' \
.          if '\\*[tbl*caption]'' .chop tbl*label-sffx
.    \}
.    if !'\\*[tbl*caption-short]'' .ds short -short
.    if \\n[tbl*autolabel] \{\
.       if \\n[tbl*label-with-chapter] \
.          ds chapno \\n[#CH_NUM].
.       ds tbl*label \
\\*[tbl*label-prfx]\\*[chapno]\\n+[tbl*label-num]\\*[tbl*label-sffx]\"
.         nr tbl*label-width \w'\\*[tbl*label]'
.    \}
.    ie \\n[@TOP] \{\
.       if !'\\n[.z]'FLOAT*DIV' \{\
.          RESTORE_SPACE
.          nr @TOP 1
.          if \\n[#COLUMNS] \
.             if !'\\*[tbl*space-adj]'' \
.                sp \\*[tbl*space-adj]-1v
.          if \\n[tbl*boxed] .nr tbl*boxed 2
.          vpt
.       \}
.    \}
.    el \
.       if !'\\*[tbl*space-adj]'' .sp \\*[tbl*space-adj]u
.    if !\\n[#MLA] \{\
.      if (\\n[tbl*have-caption]=0):(\\n[tbl*caption-after-label]=1) \{\
.         ie !'\\n[.z]'FLOAT*DIV' \{\
.            ie !\\n[tbl*boxed]=2 \{\
.               if \\n[tbl*have-header] .nr tbl*restore-header 1
.               if !\\n[@TOP] .sp .5v
.               if \\n[tbl*boxed] .sp .25v
.               if \\n[tbl*restore-header]=1 .nr tbl*have-header 1
.            \}
.            el \{\
.               if !\\n[tbl*boxed] .ns
.               sp .25v
.            \}
.         \}
.         el .sp .5v
.      \}
.    \}
.    if \\n[nl]=\\n[#PAGE_TOP] .ns
.    if '\\n[.z]'FLOAT*DIV' \
.       if \\n[defer]>0 .sp .5v
.    if \\n[@TOP] .rr @TOP
.    ds ev-current \\n[.ev]
.    if (\\n[nl]=\\n[#PAGE_TOP]):(\\n[nl]=\\n[dc]) \
.       nr tbl*caption-lead-diff-adj 1
.    if \\n[#MLA] \
.       if \\n[tbl*have-label]+\\n[tbl*have-caption]=0 \
.          sp .5v
.    if \\n[tbl*boxed]=2 \{\
.       if \\n[#MLA]=0 \
.          if (\\n[tbl*caption-after-label]=1):(\\n[tbl*have-caption]=0) \
.             sp 1n
.    \}
.    if \\n[tbl*have-header] \{\
.       di tbl*header-div
.       ev table-header
.       evc \\*[ev-current]
.       if !\\n[float-span] \{\
.          ie '\\*[ev-current]'FLOAT' \{\
.             ie !\\n[tbl*center] \
.                in 0
.             el \{\
.                in 0
\!.              in 0
.             \}
.          \}
.          el \!.in 0
.       \}
.    \}
.END
\#
.MAC TH END
.    ie '\\n[.z]'tbl*header-div' \{\
.       nr T. 0
.       T#
.       di
.       ev
.       if \\n[#PDF_BOOKMARKS] \{\
.          ie !'\\n[.z]'' \{\
.             if (\\n[float*img]=0)&(\\n[float*pic]=0)&(\\n[float*eqn]=0) \{\
\!.              PDF_TARGET tbl:\\\\n+[lists*target]
.                ie !'\\*[tbl*label]'' \
\!.                 TO_TABLES "\\*[tbl*label]" "\\*[tbl*caption\\*[short]]"
.                el \
\!.                 TO_TABLES "\\*[tbl*caption\\*[short]]"
.             \}
.          \}
.          el \{\
.             if '\\n[.z]'' .PDF_TARGET tbl:\\n+[lists*target]
.             ie !'\\*[tbl*label]'' \
.                TO_TABLES "\\*[tbl*label]" "\\*[tbl*caption\\*[short]]"
.             el \
.                TO_TABLES "\\*[tbl*caption\\*[short]]"
.          \}
.       \}
.       if \\n[#MLA] .if !\\n[tbl*have-caption] \
.          mla@error label caption \\n[.F] \\$0 \\n[.c]
.       if !'\\n[.z]'FLOAT*DIV' \{\
.          ie !\\n[tbl*boxed] \{\
.             nr th*needs (u;\\n[dn]+\\n[tbl*needs]v)
.             if \\n[th*needs]>\\n[.t] \{\
.                if dPDF.EXPORT \
.                   if \\n[#FLEX_ACTIVE] \
.                      if !\\n[#NO_FLEX] \
.                         tm .ds pre-newpage-\\n% \\n%@\\n[#COL_NUM]
.                ne \\n[dn]u+\\n[tbl*needs]v
.                nr tbl@needs 1
.             \}
.          \}
.          el \{\
.             nr th*needs (u;\\n[dn]+.3n+\\n[tbl*needs]v)
.             if \\n[th*needs]>\\n[.t] \{\
.                if \\n[#COLUMNS] \
.                   if !\\n[#COL_NUM]=\\n[#NUM_COLS] \
.                      nr tbl*no-top-hook 1
.                nr tbl*no-print-header 1
.                if dPDF.EXPORT \
.                   if \\n[#FLEX_ACTIVE] \
.                      if !\\n[#NO_FLEX] \
.                         tm .ds pre-newpage-\\n% \\n%@\\n[#COL_NUM]
.                ne \\n[dn]u+\\n[tbl*needs]v
.                nr tbl@needs 1
.             \}
.          \}
.       \}
.       ie (\\n[dn]-\\n[.v])>\\n[.t] \{\
.          if !\\n[@TOP] .@error ridiculously long table header
.          if \\n[tbl@needs] \{\
.             if \\n[tbl*boxed] \{\
.                RESTORE_SPACE
.                sp -1n
.             \}
.             rr tbl@needs
.          \}
.          if \\n[tbl*have-caption] .TBL*CAPTION
.       \}
.       el \{\
.          nr tbl*header-ht \\n[dn]
.          if \\n[tbl@needs] \{\
.             if \\n[tbl*boxed] \{\
.                RESTORE_SPACE
.                if !\\n[#MLA] \{\
.                   if (\\n[tbl*have-caption]=0):(\\n[tbl*caption-after-label]=1) \
.                      nop \&
.                   sp -1n
.                \}
.             \}
.             rr tbl@needs
.          \}
.          if (\\n[tbl*have-caption]=1)&(\\n[tbl*caption-after-label]=0) \
.             TBL*CAPTION
.          vs
.          tbl*print-header
.       \}
.    \}
.    el \{\
.       if \\n[tbl*have-caption] \{\
.          TBL*CAPTION
.          nr skip-th-warning 1
.       \}
.       if !\\n[skip-th-warning] .@error .TH without .TS H
.       rr skip-th-warning
.    \}
.\" When centering a boxed table inside a float, .T# won't place
.\" vertical rules in the correct horizontal position unless .ll is
.\" given a nominal value (can be anything) and an indent is set
.\" manually.
.    if '\\n[.z]'FLOAT*DIV' \{\
.       if \\n[tbl*center] \{\
.          nr float*ll \\n[.l]
.          ll 0
.          in \\n[float*ll]u-\\n[TW]u/2u
.       \}
.    \}
.END
\#
.MAC TE END
.    ev tbl*end \" Needed because of .ad changes
.    evc \\*[ev-current] 
.    nh
.    nf
.    rr tbl*no-header
.    if !'\\$1'' \{\
.       if '\\$1'SOURCE' \{\
.          ie !\\n[#MLA] \{\
.             tm1 "[mom]: \\$1 argument to \\$0 at line \\n[.c], but MLA style not enabled.
.             tm1 "       Ignoring \\$1, but continuing to process.
.          \}
.          el \{\
.             nr tbl*have-source 1
.             shift
.          \}
.       \}
.    \}
.    if (\\n[#MLA]=1)&(\\n[tbl*have-source]=0) .tbl*source-warning
.    if !'\\n[.z]'FLOAT*DIV' \{\
.       ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.       ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u
.       if \\n[.t]<(\\n[.v]/2u) \{\
.          ie (\\n[tbl*have-label]=1):\
(\\n[tbl*caption-after-label]=1):\
(\\n[tbl*have-source]=1):\
(\\n[tbl*autolabel]=1) \{\
.             rm tbl*header-div
.             nr tbl*no-top-hook 1
.             ie \\n[tbl*autolabel] \
.                if \\n[#MLA] \
.                   if !\\n[tbl*have-source] .
.             el \{\
.                nr pgnum \\n%+\\n[#PAGE_NUM_ADJ]
.                if \\n[#COLUMNS]=1 .ds col-num ", column \\n[#COL_NUM]
.                tm1 "[mom]: '\\n[.F]', macro \\$0, line \\n[.c]:
.                tm1 "        Insufficient room for label, caption, and/or source after
.                tm1 "        table on page \\n[pgnum]\\*[col-num].  Omitting, but continuing to process table.
.             \}
.             nr tbl*skip-source 1
.             nr tbl*skip-label 1
.             rr tbl*have-caption
.             ie \\n[#COLUMNS] \
.                COL_NEXT internal
.             el .NEWPAGE
.          \}
.          el \{\
.\" Don't print tbl-header at top of next page or column if tbl
.\" finishes without room for further input at bottom of page
.             rm tbl*header-div
.             nr tbl*no-print-header 1
.             ie \\n[#COLUMNS] \
.                COL_NEXT internal
.             el .NEWPAGE
.          \}
.       \}
.    \}
.    if !\\n[#MLA] \{\
.       if (\\n[tbl*have-label]=1):(\\n[tbl*autolabel]=1):(\\n[tbl*caption-after-label]=1) \{\
.          ev label
.          if '\\*[ev-current]'FLOAT' .evc 0
.          ie \\n[#PRINT_STYLE]=1 .TYPEWRITER
.          el \{\
.             tbl*label-style
.             vs \\n[.ps]u+\\n[tbl*label-autolead]u
.          \}
.          SIZESPECS
.          if \\n[tbl*label-with-chapter] \
.             ds chapno \\n[#CH_NUM].
.          TBL*SET_LABEL_QUAD \\*[tbl*label-quad]
.          di tbl*label-div
.          ie \\n[tbl*boxed] .sp \\n[#CAP_HEIGHT]u
.          el .sp \\n[#DOC_LEAD]u/4u
.          if (\\n[tbl*have-label]=1):(\\n[tbl*autolabel]=1) \{\
.             if !'\\*[tbl*label-space]'' .sp \\*[tbl*label-space]
.             ie \\n[tbl*autolabel] \{\
.                ie !\\n[tbl*caption-after-label] .nop \
\\*[tbl*label-prfx]\\*[chapno]\\n[tbl*label-num]\\*[tbl*label-sffx]
.                el \{\
.                   nop \
\\*[tbl*label-prfx]\\*[chapno]\\n+[tbl*label-num]\\*[tbl*label-sffx]\|
.                   tbl*caption-style
.                   vs \\n[.ps]u+\\n[tbl*caption-autolead]u
.                   ds tbl*caption-old \\*[tbl*caption]
.                   ds tbl*caption " \\*[tbl*caption]
.                   nop \\*[tbl*caption]
.                   ds tbl*caption \\*[tbl*caption-old]
.                \}
.             \}
.             el \{\
.                ie !\\n[tbl*caption-after-label] .nop \\*[tbl*label]
.                el \{\
.                   nop \\*[tbl*label]\ \|\c
.                   tbl*caption-style
.                   vs \\n[.ps]u+\\n[tbl*caption-autolead]u
.                   ds tbl*caption " \\*[tbl*caption]
.                   nop \\*[tbl*caption]
.                \}
.             \}
.          \}
.          br
.          di
.          in 0
.          ev
.          nr pgnum \\n%+\\n[#PAGE_NUM_ADJ]
.          ie !'\\n[.z]'FLOAT*DIV' \{\
.             rr tbl*have-header
.             rr tbl*have-caption
.             ie (\\n[dn]-\\n[.v])>\\n[.t] \{\
.                if \\n[#COLUMNS]=1 .ds col-num ", column \\n[#COL_NUM]
.                tm1 "[mom]: '\\n[.F]', macro \\$0, line \\n[.c]:
.                tm1 "        Insufficient room for label, caption, and/or source after
.                tm1 "        table on page \\n[pgnum]\\*[col-num].  Omitting, but continuing to process.
.                ie \\n[#COLUMNS] \
.                   COL_NEXT internal
.                el .NEWPAGE
.                if d tbl*header-div .rm tbl*header-div
.                rr tbl*caption-top-lead-diff
.                nr tbl*skip-source 1
.                nr tbl*skip-label 1
.             \}
.             el .print-label
.          \}
.          el .print-label
.       \}
.    \}
.    if \\n[tbl*autolabel] \{\
.       ds tbl*label \\*[chapno]\\n[tbl*label-num]
.       if dLABEL.REFS \
.          tm .ds \\*[target] \\*[chapno]\\n[tbl*label-num]
.       rm target
.    \}
.    if !\\n[tbl*skip-source] \{\
.       if \\n[tbl*have-source] \{\
.          ds tbl*source \\$1
.          SIZESPECS
.          ev source
.          evc \\*[ev-current]
.          nf
.          nh
.          ie \\n[#PRINT_STYLE]=1 \{\
.             TYPEWRITER
.             sp
.          \}
.          el \{\
.             tbl*source-style
.             vs \\n[.ps]u+\\n[tbl*source-autolead]u
.          \}
.          di tbl*source-div
.          TBL*SET_SOURCE_QUAD \\*[tbl*source-quad]
.          if (\\n[tbl*have-label]=0)&(\\n[#MLA]=0) \
.             if !\\n[tbl*autolabel] .sp \\n[#CAP_HEIGHT]u
.          if \\n[#MLA] \
.             sp \\n[#CAP_HEIGHT]u
.          if !'\\*[tbl*source-space]'' .sp \\*[tbl*source-space]
.          nop \\*[tbl*source]
.          br
.          di
.          nf
.          tbl*source-div
.          ev
.       \}
.    \}
.    if '\\n[.z]'FLOAT*DIV' .nr bx-tbl-depth \\n[.d]-1v
.    if '\\n[.z]'tbl*header-div' \{\
.       @error .TS with 'H' flag but no corresponding .TH
.       ab Aborting.
.    \}
.    ev
.    if !\\n[tbl*plain] \{\
.       ie \\n[tbl*plain-boxed] \{\
.          ie \\n[#MLA] .if !\\n[tbl*have-source] .sp .5v
.          el .sp .5v
.       \}
.       el \{\
.          if !\\n[tbl*have-source] \{\
.             if (\\n[tbl*have-label]=0)&\
(\\n[tbl*caption-after-label]=0)&(\\n[tbl*autolabel]=0) \
.                sp 1v
.             if (\\n[tbl*have-label]=1):(\\n[tbl*autolabel]=1) \
.                sp .5v
.          \}
.          if '\\n[.z]'FLOAT*DIV' .nr chop-space 1
.       \}
.    \}
.    ll \\n[ll-pre-tbl]u
.    if (\\n[nl]=\\n[dc]):(\\n[nl]=\\n[#PAGE_TOP]) .ns
.    if !'\\*[tbl*space-adj]'' .sp -\\*[tbl*space-adj]u
.    if \\n[#MLA] \
.       sp .5v
.    ie !\\n[tbl*no-shim] \{\
.       ie !\\n[#NO_SHIM] \
.          if !'\\n[.z]'FLOAT*DIV' .SHIM
.       el \
.          if !\\n[tbl*no-flex] \
.             if !\\n[#NO_FLEX] \
.                if !'\\n[.z]'FLOAT*DIV' .FLEX
.    \}
.    el \
.       if !\\n[tbl*no-flex] \
.          if !\\n[#NO_FLEX] \
.             if !'\\n[.z]'FLOAT*DIV' .FLEX
.    TBL*CLEANUP
.END
\#
\# Utility macros for tbl
\#
.MAC TBL*CAPTION END
.    ev caption
.    evc \\*[ev-current]
.    vs \\n[.ps]u+\\n[tbl*caption-autolead]u
.    nr caption-lead \\n[.v]
.    nr tbl*caption-lead-diff \\n[lead-pre-tbl]-\\n[.v]
.    nr tbl*caption-top-lead-diff \\n[tbl*caption-lead-diff]
.    ie !\\n[#MLA] \{\
.       if \\n[tbl*have-caption] \{\
.          ie !'\\n[.z]'FLOAT*DIV' \{\
.             if !\\n[tbl*caption-after-label] \{\
.                ie (\\n[nl]=\\n[#PAGE_TOP]):(\\n[nl]=\\n[dc]) \{\
.                   RESTORE_SPACE
.                   ie \\n[#COLUMNS] .sp |\\n[dc]u
.                   el .sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.                   sp \\n[tbl*caption-lead-diff]u
.                 \}
.                 el \{\
.                    if \\n[.ns] .if !(\\n[nl]=\\n[#PAGE_TOP]) .rs
.                    sp \\n[#DOC_LEAD]u/2u
.                 \}
.             \}
.          \}
.          nh
.       \}
.    \}
.    el \{\
.       if !\\n[tbl*autolabel] \{\
.          ie !\\n[tbl*have-label] \
.             mla@error caption label \\n[.F] \\$0 \\n[.c]
.          el .ev label
.       \}
.    \}
.    ie \\n[#PRINT_STYLE]=1 .nr tmp-ind 2m
.    el .nr tmp-ind 1.25m
.    ie \\n[#PRINT_STYLE]=1 .TYPEWRITER
.    el \{\
.       if !\\n[#MLA] \{\
.          tbl*caption-style
.          nr lead-current \\n[.v]
.       \}
.    \}
.    ie !\\n[#MLA] \{\
.       ie !\\n[tbl*caption-after-label] \{\
.          di tbl*caption-div
.          ie \\n[tbl*center] \!.in -\\n[ind-pre-tbl]u
.          el \!.in 0
.          TBL*SET_CAPTION_QUAD \\*[tbl*caption-quad]
.          nop \\*[tbl*caption]
.          br
.          di
.          evc 0
.          if !'\\n[.z]'FLOAT*DIV' \{\
.             ch FOOTER \\n[#VARIABLE_FOOTER_POS]u+\\n[#DOC_LEAD]u
.             ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u+\\n[#DOC_LEAD]u
.             nr caption-needs 2
.             ie \\n[tbl*boxed] .nr tbl*lead \\n[.v]+3n
.             el .nr tbl*lead \\n[.v]
.             if \
(\\n[dn]+(\\n[tbl*lead]*(\\n[tbl*needs]+1)))>=\\n[.t] \{\
.                nr pgnum \\n%+\\n[#PAGE_NUM_ADJ]
.                if \\n[#COLUMNS]=1 .ds col-num ", column \\n[#COL_NUM]
.                tm1 \
"[mom]: Table with caption at line \\n[.c] \
does not fit on page \\n[pgnum]\\*[col-num].
.                tm1 \
"       Shifting table to next page or column.
.                ie (\\n[#COLUMNS]=1)&(\\n[#COL_NUM]=\\n[#NUM_COLS]) \{\
.                   rr tbl*no-header
.                   NEWPAGE
.                \}
.                el \{\
.                   nr tbl*no-top-hook -1
.                   sp \\n[.t]u
.                   ie \\n[#COLUMNS] \
.                      sp |\\n[dc]u+\\n[tbl*caption-lead-diff]u
.                   el .sp |\\n[#PAGE_TOP]u+\\n[tbl*caption-lead-diff]u
.                \}
.             \}
.             ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.             ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u
.          \}
.          if \\n[.u] .nr fill 1
.          nf
.          if \\n[.ns] .RESTORE_SPACE
.          tbl*caption-div
.          if \\n[#PRINT_STYLE]=1 .sp .5v
.          if !'\\*[tbl*caption-space]'' \
.             sp \\*[tbl*caption-space]
.          if \\n[tbl*caption-lead-diff-adj] \{\
.             sp -\\n[tbl*caption-lead-diff]u
.             rr tbl*label-lead-diff-adj
.          \}
.          if \\n[fill] .fi
.          rr fill
.       \}
.       el \{\
.          if (\\n[tbl*have-label]=0) \{\
.             if !\\n[tbl*autolabel] \{\
.                tm1 "[mom]: CAPTION_AFTER_LABEL enabled, but no label given
.                tm1 "       for table at line \\n[.c].
.                tm1 "       Skipping caption but continuing to process.
.             \}
.          \}
.       \}
.    \}
.    el \{\
.       if (\\n[tbl*have-label]=1):(\\n[tbl*autolabel]=1) \{\
.          ie !\\n[tbl*have-caption] \
.             mla@error label caption \\n[.F] \\$0 \\n[.c]
.          el \{\
.             ie !'\\n[.z]'FLOAT*DIV' \{\
.                ie (\\n[nl]=\\n[#PAGE_TOP]):(\\n[nl]=\\n[dc]) \{\
.                   ie !\\n[#COLUMNS] \
.                      sp |\\n[#PAGE_TOP]u+\\n[tbl*caption-lead-diff]u
.                   el .sp |\\n[dc]u+\\n[tbl*caption-lead-diff]u
.                \}
.                el .sp .5v
.             \}
.             el .sp .5v
.          \}
.          ev label
.          evc \\*[ev-current]
.          nh
.          ie \\n[#PRINT_STYLE]=1 .TYPEWRITER
.          el \{\
.             tbl*label-style
.             vs \\n[.ps]u+\\n[tbl*label-autolead]u
.             nr tbl*label-lead-diff \\n[lead-pre-tbl]-\\n[.v]
.          \}
.          if \\n[tbl*label-with-chapter] \
.             ds chapno \\n[#CH_NUM].
.          TBL*SET_LABEL_QUAD \\*[tbl*label-quad]
.          di tbl*mla-label-caption
\!.        in 0
.          ie \\n[tbl*autolabel] \{\
.             ds label \
\\*[tbl*label-prfx]\\*[chapno]\\n[tbl*label-num]\\*[tbl*label-sffx]\"
.             nop \\*[label]
.             nr tbl*label-width \w'\\*[label]'
.             rr label
.          \}
.          el \{\
.             if !'\\*[tbl*label]'' \{\
.                nop \\*[tbl*label]
.                nr tbl*label-width \w'\\*[tbl*label]'
.             \}
.          \}
.          if \\n[tbl*autolabel] \
.             ds tbl*label \\*[chapno]\\n[tbl*label-num]
.          br
.          di
.       \}
.       da tbl*mla-label-caption
.       ie \\n[#PRINT_STYLE]=1 .TYPEWRITER
.       el .tbl*caption-style
.       if '\\*[tbl*caption-quad]'L' \{\
.           EOL
.           ie \\n[float*tbl] \{\
.              ie \\n[tbl*center] \
.                 ll \\n[ll-pre-tbl]u-\\n[TW]u/2u+\\n[TW]u-\\n[tmp-ind]u
.              el \
.                 ll \\n[TW]u+\\n[.i]u-\\n[tmp-ind]u
\!.            in \\n[tmp-ind]u
.              ti -\\n[tmp-ind]u
.           \}
.           el \{\
.              ie \\n[tbl*center] \{\
.                 if '\\*[tbl*label-quad]'L' \{\
.                    ll \\n[ll-pre-tbl]u-\\n[TW]u/2u+\\n[TW]u
\!.                  in \\n[tmp-ind]u
.                 \}
.              \}
.              el \
.                 in \\n[tmp-ind]u+\\n[ind-pre-tbl]u
.           \}
.           ti -\\n[tmp-ind]u
.       \}
.       nop \\*[tbl*caption]
.       br
\!.     in
.       da
.       if !'\\n[.z]'FLOAT*DIV' \{\
.          ch FOOTER \\n[#VARIABLE_FOOTER_POS]u+\\n[#DOC_LEAD]u
.          ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u+\\n[#DOC_LEAD]u
.          ie \\n[#MLA] .nr caption-needs 3
.          el .nr caption-needs 2
.          if \
(\\n[dn]+(\\n[#DOC_LEAD]*\\n[tbl*needs])+(\\n[caption-needs]*\\n[caption-lead]))>\\n[.t] \{\
.             nr pgnum \\n%+\\n[#PAGE_NUM_ADJ]
.             if \\n[#COLUMNS] .ds col-num ", column \\n[#COL_NUM]
.             tm1 \
"[mom]: Table with caption at line \\n[.c] \
does not fit on page \\n[pgnum]\\*[col-num].
.             tm1 \
"       Shifting table to next column or page.
.             ie (\\n[#COLUMNS]=1)&(\\n[#COL_NUM]=\\n[#NUM_COLS]) \{\
.                rr tbl*no-header
.                if \\n[defer] .nr skip-th-warning 1
.                NEWPAGE
.             \}
.             el \{\
.                nr tbl*no-top-hook 1
.                sp \\n[.t]u
.                if (\\n[tbl*caption-after-label]=1):(\\n[tbl*plain]=1) \
.                   sp 1n-.3n
.             \}
.          \}
.          ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.          ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u
.       \}
.       nf
.       if (\\n[nl]=\\n[#PAGE_TOP]):(\\n[nl]=\\n[dc]) \
.          nr tbl*label-lead-diff-adj 1
.       ie (\\n[.t]>1)&(\\n[@TOP]=0) \{\
.          if !\\n[#NO_FLEX] \{\
.             NO_FLEX
.             nr #RESTORE_FLEX 1
.          \}
.          if \\n[.ns] .rs
.          sp \\n[tbl*label-lead-diff]u
.       \}
.       el \{\
.          if \\n[.t]=1 .sp \\n[.t]u
.          ie \\n[#COL_NUM]>1 \
.             ie (\\n[nl]=\\n[#PAGE_TOP]):(\\n[nl]=\\n[dc]) \
.                sp |\\n[dc]u+\\n[tbl*label-lead-diff]u
.             el .sp .5v
.       \}
.       tbl*mla-label-caption
.    \}
.    ie \\n[#PRINT_STYLE]=1 .sp .5v
.    el .sp .5n
.    if \\n[tbl*label-lead-diff-adj] \{\
.       sp -\\n[tbl*label-lead-diff]u
.       rr tbl*label-lead-diff-adj
.    \}
.    br
.    if !'\\*[tbl*caption-space]'' .sp \\*[tbl*caption-space]
\!.  if \\\\n[float*tbl] .ev FLOAT
.    ev \\*[ev-current]
.END
\#
.MAC TBL*CLEANUP END
.    if !'\\n[.z]'FLOAT*DIV' \{\
.       rm tbl*header-div
.       rm short
.       rm tbl*caption
.       rm tbl*caption-short
.       rm tbl*label
.       rr tbl*center
.       rr tbl*caption-top-lead-diff
.       rr tbl*have-header
.       rr tbl*no-print-header
.       rr tbl*have-caption
.       rr tbl*have-label
.       rr tbl*plain-boxed
.       rr tbl*boxed
.    \}
.    rr doing-tbl
.    rm tbl*space-adj
.    rr tbl*skip-label
.    rr tbl*skip-source
.    rr tbl*label-warning
.    rr tbl*no-shim
.    rr tbl*no-flex
.    rr tbl*plain
.    rr tbl*caption-top-lead-diff
.    rnn tbl*have-label tbl@label
.    rnn tbl*have-source tbl@source
.    if '\\*[tbl*label-sffx-tmp]'.' .ds tbl*label-sffx .
.    if \\n[#RESTORE_INDENT_BOTH] \{\
.       IB
.       rr #RESTORE_INDENT_BOTH
.    \}
.    if \\n[#RESTORE_INDENT_LEFT] \{\
.       IL
.       rr #RESTORE_INDENT_LEFT
.    \}
.    if \\n[#RESTORE_FLEX] \{\
.       NO_FLEX off
.       rr #RESTORE_FLEX
.    \}
.END
\#
.MAC print-label END
.    if \\n[.u] .nr fill 1
.    nf
.    if \\n[tbl*center] \{\
.       if '\\n[.z]'' \{\
.          ll \\n[.l]u-\\n[TW]u/2u+\\n[TW]u
.          if \\n[ind-pre-tbl] \
.             in \\n[ind-pre-tbl]u-(\\n[ind-pre-tbl]u/2u)
.       \}
.    \}
.    if !\\n[tbl*skip-label] \
.       tbl*label-div
.    if \\n[tbl*center] \{\
.       if '\\n[.z]'' \{\
.          ll
.          in 0
.       \}
.    \}
.    if \\n[fill] .fi
.    rr fill
.END
\#
.MAC tbl@top-hook END
.    if (\\n[tbl*have-header:1]=1):(\\n[tbl*have-header]=1) \{\
.       if !r tbl*no-print-header \{\
.          nf
.          rr @TOP
.          ch RR_@TOP
.          ev top-hook
.          evc 0
.          rs
.          nop \&
.          ie !\\n[tbl*boxed] .sp -1
.          el .sp -1n
.          tbl*print-header
.          ev
.       \}
.    \}
.END
\#
.MAC tbl*print-header END
.    if \\n[.u]=1 \{\
.       nf
.       nr fill 1
.    \}
.    if \\n[#COL_NUM]>1 \
.       if !\\n[tbl*have-caption] \
.          if (\\n[@TOP]=1):(\\n[nl]=\\n[dc]) \
.             sp .3n
.    if \\n[tbl*center] \!.in \\n[ind-pre-tbl]u/2u
.    ie d tbl*header-div:span .tbl*header-div:span
.    el .tbl*header-div
.    if '\\n[.z]'FLOAT*DIV' \
.       if \\n[tbl*center] .ce 1000
.    mk #T
.    if !'\\n[.z]'FLOAT*DIV' \{\
.       ch FOOTER \\n[#VARIABLE_FOOTER_POS]u+\\n[#DOC_LEAD]u
.       ch FN_OVERFLOW_TRAP -\\n[#FN_OVERFLOW_TRAP_POS]u+\\n[#DOC_LEAD]u
.    \}
.END
\#
.MAC tbl@bottom-hook END
.       rr #DIVERTED
.       rr @TOP
.       ch RR_@TOP
.END
\#
.MAC tbl*float-warning END
.    tm1 "[mom]: Table in FLOAT, output page \\n[#PAGENUMBER], exceeds page vertical limits.
.    tm1 "       Multipage boxed tables cannot be contained within floats.
.    ab   [mom]: Aborting '\\n[.F]', approx. line \\n[.c].
.END
\#
.MAC tbl*caption-warning END
.    tm1 "[mom]: TS at line \\n[.c] has CAPTION but no H argument.
.    tm1 "       CAPTION requires H with a corresponding .TH.
.    ab   [mom]: Aborting '\\n[.F]'.
.END
\#
.MAC tbl*source-warning END
.    tm1 "[mom]: MLA enabled, but TE at line \\n[.c] has no SOURCE.
.    tm1 "       MLA style for tables requires that a source be cited.
.    ab   [mom]: Aborting '\\n[.F]'.
.END
\#
.MAC ds@need END \" Move vertically until there is enough space for \$1
.    if '\\n(.z'' \{\
.       while \\n[.t]<=(\\$1)&(\\n[nl]>\\n[#PAGE_TOP]) \{\
.          rs
'          sp \\n[.t]u
.       \}
.    \}
.END
\#
\# ***eqn***
\#
\# EQ/EN macros borrowed from ms, mommified by Robin Haberkorn
\# <robin.haberkorn@googlemail.com>, expanded by Peter Schaffter.
\#
\# EQ [ -L | -C | -I <indent> ] [label]
\# EN [ CONT | CONTINUED | ... ]
\#
\# Equations are centered by default, but can be left-justified
\# (EQ -L), explicitly centered, or indented (EQ -I).
\#
\# Each eqn block for multi-line equations aligned with 'mark' and
\# 'lineup' should be terminated by passing 'CONT' or 'CONTINUED'
\# or '...' to EN.
\#
\# Note that geqn mark and lineup work correctly in centered equations.
\#
.MAC EQ END
.    if \\n[eqn*copy-in]=1 \{\
.       if !\\n[eqn-linenum] .nr eqn-linenum \\n[.c]
.       if !\\n[pgnum] .nr pgnum \\n%+\\n[#PAGE_NUM_ADJ]
.       br
.       if \\n[.u] .nr fill 1
.       na
.       rr float*eqn
.       if '\\n[.z]'FLOAT*DIV' .nr float*eqn 1
.       nr eqn*restore-adj \\n[.j]
.       if !\\n[continued] \{\
.          PDF_TARGET eqn:\\n+[lists*target]
.          rr eqn*type
.          nr loop-counter \\n[#NUM_ARGS]
.          nr loop-count 0 1
.          while \\n+[loop-count]<=\\n[loop-counter] \{\
.             if '\\$1'-L' \{\
.                nr eqn*left 1
.                nr eqn*type 1
.                shift
.             \}
.             if '\\$1'-I' \{\
.                nr eqn*ind  1
.                nr eqn*type 2
.                shift
.                ds DI \\$1
.                ds DI@cont \\*[DI]
.                shift
.             \}
.             if '\\$1'-C' \{\
.                nr eqn*center 1
.                nr eqn*type   3
.                shift
.             \}
.             if '\\$1'ADJUST' \{\
.                ds eqn*space-adj \\$2
.                shift 2
.             \}
.             if '\\$1'LABEL' \{\
.                ds eqn*label \\$2
.                shift 2
.             \}
.             if '\\$1'SHIFT_LABEL' \{\
.                ds eqn*shift-label \\$2
.                shift 2
.             \}
.             if '\\$1'CAPTION' \{\
.                ds eqn*caption \\$2
.                shift 2
.             \}
.             if '\\$1'SHORT_CAPTION' \{\
.                ds eqn*caption-short \\$2
.                shift 2
.             \}
.             if '\\$1'TARGET' \{\
.                ds target "\\$2
.                PDF_TARGET "\\*[target]
.                shift 2
.             \}
.             if '\\$1'NO_SHIM' \{\
.                nr @no-shim 1
.                shift 1
.             \}
.             if '\\$1'NO_FLEX' \{\
.                nr eqn*no-flex
.                shift
.             \}
.          \}
.       \}
.       if (\\n[eqn*have-label]=1):(\\n[eqn*autolabel]=1) \
.          ds label-type eqn
.       if '\\*[eqn*shift-label]'' .ds eqn*shift-label 0
.       if !\\n[eqn*type] \{\
.          nr eqn*center 1
.          nr eqn*type   3
.          shift
.       \}
.       if !'\\*[eqn*caption]'' \{\
.          if '\\*[caption-quad]'L' \{\
.             if \\n[default-left] .ds caption-quad R
.             rr default-left
.          \}
.       \}
.       if !\\n[continued] \{\
.          if !'\\*[eqn*caption-short]'' .ds short -short
.          if \\n[eqn*autolabel] \{\
.             if \\n[eqn*label-with-chapter] \
.                ds chapno \\n[#CH_NUM].
.             ds eqn*label \\*[chapno]\\n+[eqn*label-num]
.             nr eqn*label-width \w'\\*[eqn*label]'
.             if dLABEL.REFS \
.                tm .ds \\*[target] \\*[chapno]\\n[eqn*label-num]
.             rm target
.             nr eqn*label-num -1
.          \}
.          ie !'\\n[.z]'' \{\
.             if (\\n[float*img]=0)&(\\n[float*pic]=0)&(\\n[float*tbl]=0) \{\
\!.              PDF_TARGET eqn:\\\\n+[lists*target]
.                ie !'\\*[eqn*label]'' \
\!.                 TO_EQUATIONS "\\*[eqn*label]" "\\*[eqn*caption\\*[short]]"
.                el \
\!.                 TO_EQUATIONS "\\*[eqn*caption\\*[short]]"
.             \}
.          \}
.          el \{\
.             PDF_TARGET eqn:\\n+[lists*target]
.             ie !'\\*[eqn*label]'' \
.                TO_EQUATIONS "\\*[eqn*label]" "\\*[eqn*caption\\*[short]]"
.             el \
.                TO_EQUATIONS "\\*[eqn*caption\\*[short]]"
.          \}
.       \}
.       if \\n[continued] \{\
.          rm continued
.          rr continued
.       \}
.       if \\n[eqn@left*cont] .nr eqn*type 1
.       if \\n[eqn@ind*cont]  \{\
.           nr eqn*type 2
.           ds DI \\*[DI@cont]
.       \}
.    \}
.    if \\n[eqn@center*cont] .nr eqn*type 3
.    ev EQN
.    evc 0
.    di eqn*div
.    in 0
.    nf
.END
\#
.MAC EN END
.    if !'\\n[.z]'eqn*div' \{\
.       @error mismatched EN
.       return
.    \}
.    br
.    di
.    ev
.    if !'\\*[eqn*label]''   .nr eqn*have-label   1
.    if !'\\*[eqn*caption]'' .nr eqn*have-caption 1
.    if !'\\$1'' \{\
.       ie '\\$1'...' .ds continued CONT
.       el .ds continued \\$1
.       substring continued 0 3
.       ie '\\*[continued]'CONT' \{\
.          nr continued 1
.          rm continued
.          if \\n[eqn*ind]    .nr eqn@ind*cont    1
.          if \\n[eqn*left]   .nr eqn@left*cont   1
.          if \\n[eqn*center] .nr eqn@center*cont 1
.       \}
.       el \{\
.          tm1 "[mom]: Invalid argument \\$1 to \\$0.
.          tm1 "       Must be 'CONTINUED', 'CONT', or '...'
.          ab   [mom]: Aborting '\\n[.F]' at line \\n[.c].
.       \}
.    \}
.    if \\n[dl]:\\n[eqn*have-label] \{\
.       ds eqn*tabs \\n[.tabs]
.       ie \\n[dl] \{\
.          if !'\\n[.z]'FLOAT*DIV' \{\
.             ie \\n[eqn*have-caption] .ne \\n[dn]u-\\n[.V]
.             el .ne \\n[dn]u-1v-\\n[.V]
.          \}
.          chop eqn*div
.          if '\\*[DD]'' \{\
.             ds DD .5v
.             if !\\n[@TOP] \{\
.                sp \\*[DD]
.                if !'\\*[eqn*space-adj]'' .sp \\*[eqn*space-adj]u
.             \}
.          \}
.          if \\n[cutaround] .ll \\n[eqn*cutaround-width]u
.          ie \\n[eqn*type]=1 \{\
.             ta (u;\\n[.l]-\\n[.i])R
.             ie \\n[continued] .nop \\*[eqn*div]
.             el \{\
.                ie \\n[eqn*autolabel] \
.nop \
\\*[eqn*div]\
\\*[eqn*label-specs]\
\t\v'+\\*[eqn*shift-label]'\
\\*[eqn*label-prfx]\\*[chapno]\\n+[eqn*label-num]\\*[eqn*label-sffx]\
\v'-\\*[eqn*shift-label]'\
\\*[revert-specs]
.                el \
.nop \
\\*[eqn*div]\
\\*[eqn*label-specs]\
\t\v'+\\*[eqn*shift-label]'\
\\*[eqn*label]\
\v'-\\*[eqn*shift-label]'\
\\*[revert-specs]
.             \}
.             if \\n[eqn-cutaround] .ll
.             if !\\n[continued] \{\
.                if \\n[eqn*have-caption] \
.                   ADD_CAPTION
.             \}
.          \}
.          el \{\
.             ie \\n[eqn*type]=2 \{\
.                ie '\\*[eqn*label-quad]'L' \{\
.                   ta \\*[DI]
.                   ie \\n[continued] .nop \t\\*[eqn*div]
.                   el \{\
.                      ie \\n[eqn*autolabel] \
.nop \
\\*[eqn*label-specs]\
\v'+\\*[eqn*shift-label]'\
\\*[eqn*label-prfx]\\*[chapno]\\n+[eqn*label-num]\\*[eqn*label-sffx]\
\v'-\\*[eqn*shift-label]'\
\t\\*[eqn*div]\
\\*[revert-specs]
.                      el \
.nop \
\\*[eqn*label-specs]\
\v'+\\*[eqn*shift-label]'\
\\*[eqn*label]\
\v'-\\*[eqn*shift-label]'\
\\*[revert-specs]\
\t\\*[eqn*div]
.                   \}
.                \}
.                el \{\
.                   ta \\*[DI] (u;\\n[.l]-\\n[.i])R
.                   ie \\n[continued] .nop \t\\*[eqn*div]
.                   el \{\
.                      ie \\n[eqn*autolabel] \
.nop \
\t\\*[eqn*div]\
\\*[eqn*label-specs]\
\t\v'+\\*[eqn*shift-label]'\
\\*[eqn*label-prfx]\\*[chapno]\\n+[eqn*label-num]\\*[eqn*label-sffx]\
\v'-\\*[eqn*shift-label]'\
\\*[revert-specs]
.                      el \
.nop \
\t\\*[eqn*div]\
\\*[eqn*label-specs]\
\t\v'+\\*[eqn*shift-label]'\
\\*[eqn*label]\
\v'-\\*[eqn*shift-label]'\
\\*[revert-specs]
.                   \}
.                \}
.                if !\\n[continued] \{\
.                   if \\n[eqn*have-caption] \
.                      ADD_CAPTION
.                \}
.             \}
.             el \{\
.                ie '\\*[eqn*label-quad]'L' \{\
.                   ta (u;\\n[.l]-\\n[.i]/2)C
.                   ie \\n[continued] .nop \t\\*[eqn*div]
.                   el \{\
.                      ie \\n[eqn*autolabel] \
.nop \
\\*[eqn*label-specs]\
\v'+\\*[eqn*shift-label]'\
\\*[eqn*label-prfx]\\*[chapno]\\n+[eqn*label-num]\\*[eqn*label-sffx]\
\v'-\\*[eqn*shift-label]'\
\t\\*[eqn*div]\
\\*[revert-specs]
.                      el \
.nop \
\\*[eqn*label-specs]\
\v'+\\*[eqn*shift-label]'\
\\*[eqn*label]\
\v'-\\*[eqn*shift-label]'\
\\*[revert-specs]\
\t\\*[eqn*div]
.                   \}
.                \}
.                el \{\
.                   ta (u;\\n[.l]-\\n[.i]/2)C (u;\\n[.l]-\\n[.i])R
.                   ie \\n[continued] .nop \t\\*[eqn*div]
.                   el \{\
.                      ie \\n[eqn*autolabel] \
.nop \
\t\\*[eqn*div]\
\\*[eqn*label-specs]\
\t\v'+\\*[eqn*shift-label]'\
\\*[eqn*label-prfx]\\*[chapno]\\n+[eqn*label-num]\\*[eqn*label-sffx]\
\v'-\\*[eqn*shift-label]'\
\\*[revert-specs]
.                      el \
.nop \
\t\\*[eqn*div]\
\\*[eqn*label-specs]\
\t\v'+\\*[eqn*shift-label]'\
\\*[eqn*label]\
\v'-\\*[eqn*shift-label]'\
\\*[revert-specs]
.                   \}
.                \}
.                if !\\n[continued] \{\
.                   if \\n[eqn*have-caption] \
.                      ADD_CAPTION
.                \}
.             \}
.          \}
.       \}
.       el \{\
.          ta (u;\\n[.l]-\\n[.i])R
.nop \
\\*[eqn*label-specs]\
\t\v'+\\*[eqn*shift-label]'\
\t\\*[eqn*label]\
\v'-\\*[eqn*shift-label]'\
\\*[revert-specs]
.       \}
.       ta \\*[eqn*tabs]
.\" if continuing (ie is a multi-line equation), don't space and SHIM
.       if !\\n[continued] \{\
.          br
.          if !\\n[@TOP] \
.             if !\\n[.t]<(\\*[DD]+1) \
.                sp \\*[DD]
.          if !'\\*[eqn*space-adj]'' .sp -\\*[eqn*space-adj]u
.          ie !\\n[eqn*no-shim] \{\
.             ie !\\n[#NO_SHIM] \
.                if !'\\n[.z]'FLOAT*DIV' .SHIM
.             el \
.                if !\\n[eqn*no-flex] \
.                   if !\\n[#NO_FLEX] \
.                      if !'\\n[.z]'FLOAT*DIV' .FLEX
.          \}
.          el \
.             if !\\n[eqn*no-flex] \
.                if !\\n[#NO_FLEX] \
.                   if !'\\n[.z]'FLOAT*DIV' .FLEX
.          rm DD
.          rm eqn*caption
.          rm eqn*caption-short
.          rm eqn*label
.          rm short
.          rr eqn*copy-in
.       \}
.       rm DI@cont
.       rr eqn*center
.       rr eqn@center*cont
.       rr eqn*have-label
.       rr eqn*have-caption
.       rr eqn*ind
.       rr eqn@ind*cont
.       rr eqn*left
.       rr eqn@left*cont
.       if !\\n[eqn-cutaround] .rm eqn*space-adj
.    \}
.    nr eqn*copy-in 1
.    ad \\n[eqn*restore-adj]
.    if \\n[fill] .fi
.    rr fill
.END
\#
.MAC ADD_CAPTION END
.    ie \\n[.t]<\\n[.v] \{\
.       if !'\\n[.z]'FLOAT*DIV' \{\
.          if \\n[#COLUMNS]=1 .ds col-num ", column \\n[#COL_NUM]
.          tm1 "[mom]: '\\n[.F]', macro EQ, line \\n[eqn-linenum]:
.          tm1 "       Insufficient room for equation caption on page \\n[pgnum]\\*[col-num].
.          tm1 "       Skipping caption but continuing to process.
.          if !\\n[@TOP] \{\
.             ie \\n[#COLUMNS] \
.                COL_NEXT internal
.             el .NEWPAGE
.          \}
.          rr eqn-linenum
.          rr pgnum
.       \}
.    \}
.    el \{\
.       if \\n[#PRINT_STYLE]=2 \{\
.          ps \\*[eqn*caption-size-change]
.          nr lead-curr \\n[.v]
.          sp .5v
.          vs \\n[.ps]u+\\n[eqn*caption-autolead]u
.          nr eqn*caption-lead-diff \\n[lead-curr]-\\n[.v]
.          sp \\n[eqn*caption-lead-diff]u
.          ps
.          if !'\\*[eqn*caption-space]'' \
.             sp \\*[eqn*caption-space]
.       \}
.       if '\\*[eqn*caption-quad]'L' \{\
.          fi
.          ad l
.          nop \
\\*[eqn*caption-specs]\
\\*[eqn*caption]\
\\*[revert-specs]
.          nf
.       \}
.       if '\\*[eqn*caption-quad]'C' \{\
.          fi
.          ad c
.          nop \
\\*[eqn*caption-specs]\
\\*[eqn*caption]\
\\*[revert-specs]
.          nf
.       \}
.       if '\\*[eqn*caption-quad]'R' \{\
.          fi
.          ad r
.          nop \
\\*[eqn*caption-specs]\
\\*[eqn*caption]\
\\*[revert-specs]
.          nf
.       \}
.       if !'\\*[eqn*caption-space]'' \
.          sp -\\*[eqn*caption-space]
.       vs
.    \}
.END
\#
\# ***pic***
\#
.MAC have-adjust END
.    nr #ARGS  0 1
.    nr #COUNT \\n[#NUM_ARGS]
.    while \\n+[#ARGS]<=\\n[#COUNT] \{\
.       if '\\$1'ADJUST' \{\
.          ds pic*space-adj \\$2
.          break
.       \}
.       shift
.    \}
.END
\#
\# User settable text style for pic
\#
\# PIC_TEXT_STYLE
\# --------------
\# *Argument:
\#   <offset from page left>
\# *Function:
\#   Stores user supplied page offset in register #L_MARGIN.
\#   Sets .po to user supplied offset.
\# *Notes:
\#   Requires unit of measure.
\#
.MAC PIC_TEXT_STYLE END
.    nr #ARGS  0 1
.    nr #COUNT \\n[#NUM_ARGS]
.    while \\n+[#ARGS]<=\\n[#COUNT] \{\
.       if '\\$1'FAMILY' \{\
.          shift
.          ds pic*text-family \\$1
.          shift
.       \}
.       if '\\$1'FONT' \{\
.          shift
.          ds pic*text-font \\$1
.          shift
.       \}
.       if '\\$1'SIZE' \{\
.          shift
.          ds pic*text-size-change \\$1
.          shift
.       \}
.       if '\\$1'AUTOLEAD' \{\
.          shift
.          nr pic*text-autolead \\$1
.          shift
.       \}
.    \}
.END
\#
\# Main macros
\#
.MAC PS END
.    if !\\n[#PP] .nop
.    br
.    have-adjust \\$@ \" Adjusting is handled by FLOAT
.    if !'\\n[.z]'FLOAT*DIV' .FLOAT ADJUST \\*[pic*space-adj]
.    PDF_TARGET fig:\\n+[lists*target]
.    ds ev-current \\n[.ev]
.    rr float*pic
.    nr float*pic 1
.    nr ind-pre-pic  \\n[.i]
.    nr ll-pre-pic   \\n[.l]
.    nr lead-pre-pic \\n[.v]
.    if \\n[#MLA] .sp .5v
.    in 0
.    ev PIC
.    evc \\n[ev-current]
.    nf
.    ie \\n[#NUM_ARGS]<2 .@error bad arguments to PS (not preprocessed with pic?)
.    el \{\
.       if \B'\\$1' \{\
.          ie !\B'\\$2' .ds pic*scale-width \\$1
.          el .ds pic*scale-width \\$2
.       \}
.    \}
.\" This is a bit confusing. pic is decorated with 2 args (width
.\" and height), which are read during pre-processing but have to be
.\" ignored when parsing args during main processing.  We shift pic's
.\" args out of the way, then pop them off the arg stack because
.\" they're not needed during macro processing.
.    while \B'\\$1' .shift
.    nr loop-counter \\n[#NUM_ARGS]
.    nr loop-count 0 1
.    while \\n+[loop-count]<=\\n[loop-counter] \{\
.       if '\\$1'LEFT' \{\
.          nr pic*left 1
.          shift 1
.       \}
.       if '\\$1'CAPTION' \{\
.          nr pic*have-caption 1
.          ds pic*caption \\$2
.          shift 2
.       \}
.       if '\\$1'SHORT_CAPTION' \{\
.          ds pic*caption-short \\$2
.          shift 2
.       \}
.       if '\\$1'LABEL' \{\
.          nr pic*have-label 1
.          ds pic*label \\$2
.          shift 2
.       \}
.       if '\\$1'TARGET' \{\
.          ds target "\\$2
.          PDF_TARGET "\\*[target]
.          shift 2
.       \}
.       if '\\$1'NO_SHIM' \{\
.          nr @no-shim 1
.          shift 1
.       \}
.       if '\\$1'NO_FLEX' \{\
.          nr @no-flex 1
.          shift 1
.       \}
.       if '\\$1'GRAP' \{\
.          nr grap 1
.          shift 1
.       \}
.    \}
.    if (\\n[pic*have-label]=1):(\\n[pic*autolabel]=1) \
.       ds label-type pic
.    ds pic*label-sffx-tmp \\*[pic*label-sffx]
.    if !'\\*[pic*label-sffx-tmp]'' \
.       substring pic*label-sffx-tmp -1
.    if '\\*[pic*label-sffx-tmp]'.' \
.       if \\n[pic*caption-after-label]=0 .chop pic*label-sffx
.    if \\n[#MLA] \{\
.       if (\\n[pic*have-label]=1):(\\n[pic*autolabel]=1) \{\
.          if !\\n[pic*have-caption] \
.             mla@error label caption \\n[.F] \\$0 \\n[.c]
.       \}
.       if \\n[pic*have-caption] \{\
.          if !\\n[pic*have-label] \{\
.             if !\\n[pic*autolabel] \
.                mla@error caption label \\n[.F] \\$0 \\n[.c]
.          \}
.       \}
.    \}
.    if !'\\*[pic*text-family]'' \
.       fam \\*[pic*text-family]
.    if !'\\*[pic*text-font]'' \
.       ft \\*[pic*text-font]
.    if !'\\*[pic*text-size-change]'' \
.       ps \\n[#DOC_PT_SIZE]u\\*[pic*text-size-change]
.    nr lead-current \\n[.v]
.    ie \\n[pic*text-autolead] \
.       vs \\n[.ps]u+(\\n[pic*text-autolead]u*1000u)
.    el .vs \\n[.ps]u
.    nr pic@text-lead \\n[.v]
.    nr pic@text-size \\n[.ps]
.    if !'\\*[pic*text-color]'' .COLOR \\*[pic*text-color]
.    if \\n[@TOP] \{\
.       RESTORE_SPACE
.       nr pic*top-lead-adj 1
.    \}
.    nr pic*top-lead-diff \\n[lead-pre-pic]u-\\n[.v]u
.    if (\\n[pic*have-caption]=0):(\\n[pic*caption-after-label]=1) \{\
.       ie \\n[pic*top-lead-adj] \{\
.          sp \\n[pic*top-lead-diff]u
.          rr pic*top-lead-adj
.       \}
.       el .if (\\n[pic*caption-after-label]=0):(\\n[#MLA]=0) \
.          sp \\n[lead-pre-pic]u/2u
.    \}
.    if \\n[pic*label-with-chapter] \
.       ds chapno \\n[#CH_NUM].
.    if \\n[pic*autolabel] \
.       ds pic*label \\*[pic*label-prfx]\\*[chapno]\\n+[fig*label-num]\\*[pic*label-sffx]
.    nr fig*label-width \w'\\*[pic*label]'
.    if !'\\*[pic*caption-short]'' .ds short -short
.    if \\n[#PDF_BOOKMARKS] \{\
.       ie !'\\*[pic*label]'' \
\!.        TO_FIGURES "\\*[pic*label]" "\\*[pic*caption\\*[short]]"
.       el \
\!.        TO_FIGURES "\\*[pic*caption\\*[short]]"
.    \}
.    di pic*div
.END
\#
.MAC PE END
.    di
.    nr pic*div-width \\n[dl]
.    if \\n[@TOP] \
.       RESTORE_SPACE
.    if !\\n[nl]=\\n[#PAGE_TOP] .sp \\n[lead-pre-pic]u/2u
.    if (\\n[pic*have-caption]=1)&(\\n[pic*caption-after-label]=0) \{\
.       ev caption
.       evc \\*[ev-current]
.       nh
.       ie \\n[#PRINT_STYLE]=1 .TYPEWRITER
.       el \{\
.          if \\n[.u] \{\
.             nr fill 1
.             nf
.          \}
.          pic*caption-style
.          if \\n[fill] .fi
.          rr fill
.          nr lead-current \\n[.v]
.          vs \\n[.ps]u+\\n[pic*caption-autolead]u
.          nr pic*caption-lead-diff \\n[lead-current]-\\n[.v]
.          in \\n[ind-pre-pic]u
.       \}
.       PIC*SET_CAPTION_QUAD \\*[pic*caption-quad]
.       if \\n[@TOP] .RESTORE_SPACE
\!.     in -\\n[ind-pre-pic]u
.       sp \\n[pic*caption-lead-diff]u
\!.     if \\\\n[.ns] .rs
.       nop \\*[pic*caption]
.       if \\n[#PRINT_STYLE]=1 .sp .5v
.       if !'\\*[pic*caption-space]'' \
.          sp \\*[pic*caption-space]
.       br
.       if \\n[grap] \!.sp -2v
.       ev
.    \}
.    if !\\n[pic*left] \!.in \\n[ll-pre-pic]u-\\n[pic*div-width]u/2u
.    if (\\n[grap]=1)&(\\n[pic*caption-after-label]=1) \!.sp -2
.    pic*div
.    br
.    if (\\n[pic*have-label]=1):(\\n[pic*autolabel]=1):(\\n[pic*caption-after-label]=1) \{\
.       nr lead-pre-label \\n[.v]
.       ev label
.       evc \\*[ev-current]
.       ie \\n[#PRINT_STYLE]=1 .TYPEWRITER
.       el \{\
.          pic*label-style
.          nr lead-current \\n[.v]
.          vs \\n[.ps]u+\\n[pic*label-autolead]u
.          in \\n[ind-pre-pic]u
.          sp \\n[lead-current]u-\\n[.v]u
.       \}
.       PIC*SET_LABEL_QUAD \\*[pic*label-quad]
\!.     in -\\n[ind-pre-pic]u
.       sp \\n[lead-pre-label]u-\\n[.v]u
.       if !'\\*[pic*label-space]'' .sp \\*[pic*label-space]
.       if \\n[#PRINT_STYLE]=1 .sp .5v
.       if \\n[#PRINT_STYLE]=2 .sp .25v
.       ie \\n[pic*autolabel] \
.          nop \\*[pic*label-prfx]\\*[chapno]\\n[fig*label-num]\\*[pic*label-sffx]\|
.       el \
.          if !'\\*[pic*label]'' .nop \\*[pic*label]
.       if dLABEL.REFS \{\
.          if \\n[pic*autolabel] \
.             tm .ds \\*[target] \\*[chapno]\\n[fig*label-num]
.          if \\n[pic*have-label] \
.             tm .ds \\*[target] \\*[pic*label]
.       \}
.       rm target
.       fam
.       ft
.       ps
.       gcolor
.       ie !\\n[pic*caption-after-label] .br
.       el \{\
.          if !'\\*[pic*caption]'' .nop \
\\*[pic*caption-specs]\\*[pic*caption]\\*[revert-specs]
.          br
.       \}
.       ev
.       in 0
.    \}
.    ev
.    sp .5v
.    FLOAT off
.    in \\n[ind-pre-pic]u
.    rm pic*caption
.    if !\\n[defer] .rm pic*label
.    rm pic*left
.    rm short
.    if !\\n[cutaround] .rm pic*space-adj
.    if !\\n[defer] .rr pic*have-caption
.    rr grap
.    rr float*pic
.    if '\\*[pic*label-sffx-tmp]'.' .ds pic*label-sffx .
.END
\#
\# ***refer***
\#
\# Footnote references
\# -------------------
\# *Function:
\#   Instruct REF to put references in footnotes.
\#
.MAC FOOTNOTE_REFS END
.    ie !'\\$1'' .rr #FN_REF
.    el \{\
.       if r #EN_REF .rr #EN_REF
.       nr #FN_REF 1
.    \}
.    REF_STYLE NOTE
.END
\#
\# Endnote references
\# ------------------
\# *Function:
\#   Instruct REF to collect references for endnotes output.
\#
.MAC ENDNOTE_REFS END
.    ie !'\\$1'' .rr #EN_REF
.    el \{\
.       if r #FN_REF .rr #FN_REF
.       nr #EN_REF 1
.       if !r#EN_MARKER_STYLE .ENDNOTE_MARKER_STYLE SUPERSCRIPT
.    \}
.    REF_STYLE NOTE
.END
\#
\# Prepare mom for a reference
\# ---------------------------
\# *Argument:
\#   <none> | INDENT  L|LEFT|R|RIGHT|B|BOTH  <indent value>
\# *Function:
\#   Calls FOOTNOTE or ENDNOTE, depending on whether #REF_FN or
\#   #REF_EN is set to 1.
\# *Notes:
\#   For convenience, REF is a toggle.
\#
\#   REF optionally takes the same arguments as FOOTNOTE, allowing
\#   users to indent references that go in footnotes when footnote
\#   indenting is required.  FOOTNOTE_REFS must be on for this.
\#
.MAC REF END
.    ie \\n[#FN_REF]+\\n[#EN_REF]=0 \{\
.       if !\\n[#REF_WARNING]=1 \{\
.          tm1 "[mom]: Before REF at line \\n[.c], neither FOOTNOTE_REFS nor ENDNOTE_REFS
.          tm1 "       has been selected.  If "sort" and "accumulate" are in your refer
.          tm1 "       commands, references will be collected for later output with $LIST$.
.          tm1 "       Otherwise, they will disappear.
.          nr #REF_WARNING 1
.       \}
.    \}
.    el \{\
.       ie \\n[#REF]=1 \{\
.          if \\n[#FN_REF]=1 .FOOTNOTE OFF
.          if \\n[#EN_REF]=1 .ENDNOTE OFF
.          rr #REF
.       \}
.       el \{\
.          rr #REF_WARNING
.          nr #REF 1
.          if \\n[#FN_REF]=1 .FOOTNOTE \\$1 \\$2 \\$3
.          if \\n[#EN_REF]=1 .ENDNOTE
.       \}
.    \}
.END
\#
\# Embedded references in text (with brackets)
\# -------------------------------------------
\#
.MAC REF_BRACKETS_NOTICE END
.    tm1 "[mom]: \\$1 has been removed from mom.  See the mom documentation 'refer.html'
.    tm1 "       for instructions on parenthetical insertions of references into text.
.    ie '\\$1'REF_STYLE' .tm1 "       Continuing to process '\\n[.F]' from line \\n[.c].
.    el .ab   [mom]: Aborting '\\n[.F]' at \\$1, line \\n[.c].
.END
\#
.MAC REF_BRACKETS_START END
.    REF_BRACKETS_NOTICE \\$0
.END
\#
.MAC REF_BRACKETS_END END
.    REF_BRACKETS_NOTICE \\$0
.END
\#
\# These four pairs of aliases allow users to embed references in
\# text and have them surrounded by (), [], {} or <>.
\#
.ALIAS REF( REF_BRACKETS_START
.ALIAS REF) REF_BRACKETS_END
\#
.ALIAS REF[ REF_BRACKETS_START
.ALIAS REF] REF_BRACKETS_END
\#
.ALIAS REF{ REF_BRACKETS_START
.ALIAS REF} REF_BRACKETS_END
\#
.ALIAS REF< REF_BRACKETS_START
.ALIAS REF> REF_BRACKETS_END
\#
.MAC REF_STYLE END
.    REF_BRACKETS_NOTICE \\$0
.END
\#
\# Refer indenting
\# ---------------
\# *Argument:
\#   FOOTNOTE | ENDNOTE | BIBLIO <indent for 2nd and subsequent lines of discrete reference entries>
\# *Function:
\#   Sets registers #REF_FN_INDENT, #REF_EN_INDENT or #REF_BIB_INDENT.
\# *Notes:
\#   Indent value requires a unit of measure.  If refs are going
\#   into footnotes or endnotes, first lines get indented; if going
\#   into a bibliography, second lines get indented
\#
.MAC INDENT_REFS END
.    if '\\$1'FOOTNOTE' .ds $REF_FN_INDENT  \\$2
.    if '\\$1'ENDNOTE'  .ds $REF_EN_INDENT  \\$2
.    if '\\$1'BIBLIO'   .ds $REF_BIB_INDENT \\$2
.END
\#
.ALIAS REF_INDENT INDENT_REFS
\#
\# Hyphenation of references
\# -------------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Sets register #REF_HY
\#
.MAC HYPHENATE_REFS END
.    ie '\\$1'' .nr #REF_HY 1
.    el \
.       if r #REF_HY .rr #REF_HY
.END
\#
\# The remainder of the definitions in this section are modified
\# versions of the definitions found in the refer module of s.tmac.
\#
.de @error
.tm [mom]: '\\n[.F]', line \\n[.c]: \\$*
..
\#
\# Underlining unavoidably turns off sentence spacing.
\#
.de ref*restore-ss
\c
.SS \\*[$SAVED_SS_VAR]
.if '\\n[.z]'END_NOTES' \{\
\c
\E*[PREV]\c
.\}
..
\# The following strings define the order of entries for different
\# types of references.  Each letter in the string refers to a database
\# field (A for author, T1/T2 for article and book titles, etc).
\#
.de ref*specs
.if \\n[#PRINT_STYLE]=1 \{\
.   char '     \[aq]
.   char \[oq] \[aq]
.\}
.\" Internet site - type 0
.ds ref*spec!0 i Q A m p T2 s o D c a u n
.\" Journal article - type 1
.ds ref*spec!1 i Q A m p T2 q O J V S N D P n
.\" Book - type 2
.ds ref*spec!2 i Q A m p T1 q b d l r E S e V O C I D P t n
.\" Article within book - type 3
.ds ref*spec!3 i Q A m p T2 B b d l r E S e V O C I D P t n
.\" Tech report - type 4
.ds ref*spec!4 i Q A m p T1 R G O C I D P n
.\" Magazine or newspaper article - type 5
.ds ref*spec!5 i Q A m p T2 O M V S N D P n
..
\#
\# Refer's "1st" macro.  Since it is possible to define database
\# fields using any single letter, we remove all possible string
\# definitions of the form [X and [x.  Also, reset ref*spec!<n>
\# strings to their defaults.
\#
.de ]-
.ref*specs
.rm [A [B [C [D [E [F [G [H [I [J [K [L [M \
    [N [O [P [Q [R [S [T [U [V [W [X [Y [Z \
    [a [b [c [d [e [f [g [h [i [j [k [l [m \
    [n [o [p [q [r [s [t [u [v [w [x [y [z
.if r [e .rr [e \" [e persists if %e field is last
.rr ref*type
.rm ref*string
..
\#
\# Refer's "2nd" macro; builds up a reference with ref*build, and
\# prints it with ref*print.
\#
.de ][
.nr ref*type \\$1
.if \\n[ref*type]=0 \{\
.   ie d [C \{\
.      if !d [I \{\
.         nr pre-1900 1 \" If pre-1900, MLA allows excluding publisher
.         nr ref*type 2
.      \}
.   \}
.   el .nr ref*type 2
.   if d [q .nr ref*type 2
.\}
.if \\n[ref*type]=3 \{\
.   if !'\\*([R'' \{\
.      nr ref*type 4
.      ds ref*spec!4 i Q A m p T2 B R O C I D P n
.   \}
.   if !'\\*([G'' \{\
.      nr ref*type 4
.      ds ref*spec!4 i A m p T2 B G O C I D P O n
.   \}
.\}
.if r [T \{\
.   als [T1 [T
.   als [T2 [T
.\}
.ie d ref*spec!\\n[ref*type] .ref*build \\*[ref*spec!\\n[ref*type]]
.el \{\
.   @error unknown reference type '\\n[ref*type]'
.   ref*build \\*[ref*spec!0]
.\}
.if !\\n[.hy]=0 \{\
.nr #RESTORE_HY \\n[.hy]
.if !r#REF_HY .nh
.\}
.ref*print
.if !\\n[#RESTORE_HY]=0 .hy \\n[#RESTORE_HY]
.rr #RESTORE_HY
.rm ref*string
.rm [F [T1 [T2
..
\#
\# Refer's "3rd" macros, which set up and terminate the output
\# of collected references
\#
.de ]<
.als ref*print ref*end-print
.nr #REF 1
.if \\n[#BIB_LIST]=1 \{\
.   nr #IN_BIB_LIST 1
.   LIST DIGIT \\*[$BIB_LIST_SEPARATOR] \\*[$BIB_LIST_PREFIX]
.\}
..
\#
.de ]>
.LIST OFF
.rr #REF
.rr #IN_BIB_LIST
.als ref*print ref*normal-print
..
\#
\# Output
\# ------
\#
\# Output normal, non-collected refs
\#
.de ref*normal-print
.nr #CURRENT_HY \\n[.hy]
\\*[ref*string]
..
\#
\# Output collected refs
\#
.de ref*end-print
.\" 10 is arbitrary
.nn 10
.nr #REF_BIB_INDENT (u;\\*[$REF_BIB_INDENT])
.ie \\n[#BIB_LIST]=0 \{\
.   in +\\n[#REF_BIB_INDENT]u
.   ti -\\n[#REF_BIB_INDENT]u
.\}
.el .ITEM
.\" Part of workaround for refer spitting out a blank page if the
.\" last ref falls on the bottom line.
\\*[ref*string]\R'ref*num*first-pass +1'\?\R'ref*num +1'\?
.sp \\n[#BIB_SPACE]u
.ie \\n[#BIB_LIST]=0 .in
.el .IL -\\n[#REF_BIB_INDENT]u
.nn 0
..
\#
.als ref*print ref*normal-print
\#
\# Build up the ref*string
\#
\# Correct MLA "typewritten" style (printstyle TYPEWRITE) demands
\# two spaces after each period.  The spaces are hardwired into the
\# string definitions (ref*add-<x>), so we have to make sure that there
\# aren't two spaces when the printstyle is TYPESET.  Since I find that
\# references look a bit crowded with 0 sentence space, I've bumped it
\# up to +4.  User's sentence spacing is reset in FOOTNOTES and ENDNOTES.
\#
.de ref*build
.if \\n[#PRINT_STYLE]=2 \{\
.   ds $RESTORE_SS_VAR \\*[$SS_VAR]
.   SS +8
.\}
.rm ref*string
.while \\n[.$] \{\
.   if d [\\$1 \{\
.      ie d ref*add-\\$1 .ref*add-\\$1
.      el .ref*add-dflt \\$1
.   \}
.   shift
.\}
.\" now add a final period
.ie d ref*string \{\
.   if !\\n[ref*suppress-period] .as ref*string .
.   if d ref*post-punct \{\
.      as ref*string "\\*[ref*post-punct]
.      rm ref*post-punct
.   \}
.\}
.el .ds ref*string
..
\#
\# The following macros determine how entries are formatted WRT
\# punctuation, type style, additional strings, etc.
\#
\# o First argument is the database field letter.
\# o Second argument is the punctuation character to use to separate this
\#   field from the previous field.
\# o Third argument is a string with which to prefix this field.
\# o Fourth argument is a string with which to postfix this field.
\# o Fifth argument is a string to add after the punctuation character
\#   supplied by the next field.
\#
\# %A Author(s)
.de ref*add-A
.ds eval*[A \\*([A
.substring eval*[A -1
.if '\\*[eval*[A]'.' \
.   if !'\\*[$REF_STYLE]'NOTE' .chop [A
.\" Per MLA, NOTE should not use idem, therefore if %i contains other than
.\" idem (e.g., ed., trans.), transpose it to after author's name
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie !'\\*[idem]'' .ref*field A "" "" ", \\*[idem]"
.   el .ref*field A
.   rm idem
.el .ref*field A
.\}
.if \\n([A .nr ref*suppress-period 1
..
\# %i Idem.  BIBLIO: In all instances, removes %A field and replaces
\# it with a dash; if %i field contains other than the word, idem,
\# appends it to the dash
.de ref*add-i
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie '\\*([i'idem' .rm [i
.   el .ds idem \\*([i
.\}
.el \{\
.   ie '\\*([i'idem' \{\
.      rm [A
.      rm [i
.      ref*field i "" \[idem] "" " "
.   \}
.   el \{\
.      ds eval*[i \\*([i
.      substring eval*[i -1
.      if '\\*[eval*[i]'.' \{\
.         chop [i
.         ds idem \\*([i
.      \}
.      rm [i
.      rm [A
.      ref*field i "" \[idem] ", \\*[idem]" " "
.   \}
.\}
..
\# %m Multiple authors (et al.)
.de ref*add-m
.if !'\\*[$REF_STYLE]'NOTE' \{\
.   ds eval*[m \\*([m
.   substring eval*[m -1
.   if '\\*[eval*[m]'.' .chop [m
.\}
.ref*field m ,
..
\# %p Post-author string (e.g., Preface, Foreword, etc)
.de ref*add-p
.\" Convert first letter to uppercase, per MLA, if BIBLIO
.if '\\*[$REF_STYLE]'BIBLIO' \{\
.   ds initial*cap \\*([p
.   substring initial*cap 0 0
.   ds [p*string \\*([p
.   substring [p*string 1
.   ds [p \E*[UC]\\*[initial*cap]\E*[LC]\\*[[p*string]
.\}
.ie '\\*[$REF_STYLE]'NOTE' .ref*field p ,
.el .ref*field p . " "
..
\# %Q Author(s) when author is not a person
.de ref*add-Q
.ie '\\*[$REF_STYLE]'NOTE' .ref*field Q
.el .ref*field Q
..
\# %T Title (generic)
.de ref*add-T1
.ie '\\*[$REF_STYLE]'NOTE' .ref*field T , \E*[IT] \E*[ref*restore-ss]
.el \{\
.   ie !'\\*([A'' .ref*field T . " \E*[IT]" \E*[ref*restore-ss]
.   el \{\
.      ie !'\\*([Q'' .ref*field T . " \E*[IT]" \E*[ref*restore-ss]
.      el .ref*field T . \E*[IT] \E*[ref*restore-ss]
.   \}
.\}
.if \\n([T .nr ref*suppress-period \\n([T
.
..
\# %T Title of a chapter or article
.de ref*add-T2
.ie '\\*[$REF_STYLE]'NOTE' \
.   ref*field T , \[lq] "" \[rq]
.el \{\
.   ie '\\*([A'' \{\
.      ref*field T . \[lq] "" \[rq]
.      if !'\\*([Q''.ref*field T . " \[lq]" "" \[rq]
.   \}
.   el .ref*field T . " \[lq]" "" \[rq]
.\}
.if \\n([T .nr ref*suppress-period \\n([T
..
\# %B Book title (when citing an article from a book)
.de ref*add-B
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie \\n([T .ref*field B "" \E*[IT] \E*[ref*restore-ss]
.   el .ref*field B , \E*[IT] \E*[ref*restore-ss]
.\}
.el \{\
.   ie \\n([T .ref*field B "" ".\E*[IT]" \E*[ref*restore-ss]
.   el .ref*field B . " \E*[IT]" \E*[ref*restore-ss]
.\}
\# refer doesn't set reg [T to 1 for these book titles, so we do it here
.ds eval*[B \\*([B
.substring eval*[B -1
.rr [T
.if '\\*[eval*[B]'!' .nr [T 1
.if '\\*[eval*[B]'?' .nr [T 1
.rm eval*[B
..
\# %q Titles that must go in quotes (e.g. an unpublished dissertation)
.de ref*add-q
.ie '\\*[$REF_STYLE]'NOTE' .ref*field q , \[lq] "" \[rq]
.el \{\
.   ie !'\\*([A'' .ref*field q . " \[lq]" "" \[rq]
.   el \{\
.      ie !'\\*([Q'' .ref*field q . " \[lq]" "" \[rq]
.      el .ref*field q . \[lq] "" \[rq]
.   \}
.\}
..
\# %R Report number for technical reports
.de ref*add-R
.ref*field R . " "
..
\# %J Journal name
.de ref*add-J
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie \\n([T .ref*field J "" "\E*[IT]" \E*[ref*restore-ss]
.   el .ref*field J , "\E*[IT]" \E*[ref*restore-ss]
.\}
.el \{\
.   ie \\n([T .ref*field J "" " \E*[IT]" \E*[ref*restore-ss]
.   el .ref*field J . " \E*[IT]" \E*[ref*restore-ss]
.\}
..
\# %M Magazine or newspaper name
.de ref*add-M
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie \\n([T .ref*field M "" "\E*[IT]" \E*[ref*restore-ss]
.   el .ref*field M , "\E*[IT]" \E*[ref*restore-ss]
.\}
.el \{\
.   ie \\n([T .ref*field M "" " \E*[IT]" \E*[ref*restore-ss]
.   el .ref*field M . " \E*[IT]" \E*[ref*restore-ss]
.\}
..
\# %E Editor(s)
.de ref*add-E
.ds eval*[E \\*([E
.substring eval*[E -1
.if '\\*[eval*[E]'.' \{\
.   if !\\n[#FN_REF]+\\n[#EN_REF] .chop [E
.   rm eval*[E
.\}
.\" Workaround for join-authors also joining editors.  MLA style
.\" requires a comma after first editor only if there are more than
.\" two, whereas join-authors always puts a comma after the first if
.\" there's more than one.
.rm eval*[E
.nr position 1 1
.nr counter 1 1
.while !'\\*[eval*[E]',' \{\
.   ds eval*[E \\*([E
.   substring eval*[E \\n+[position] \\n[position]
.   if \\n+[counter]>30 .break \" 30 is arbitrary
.\}
.\" Check for " and"
.if '\\*[eval*[E]',' \{\
.   ds eval*[E \\*([E
.   nr and-check \\n[position]+4
.   substring eval*[E \\n+[position] \\n[and-check]
.\}
.if '\\*[eval*[E]' and' \{\
.   nr counter 1 1
.   nr start-range -1 1
.   nr end-range 3 1
.   while !'\\*[eval*[E]', and' \{\
.      ds eval*[E \\*([E
.      substring eval*[E \\n+[start-range] \\n+[end-range]
.      if \\n+[counter]>50 .break \" just in case; 50 is arbitrary
.   \}
.   if '\\*[eval*[E]', and' \{\
.      length len*[E \\*([E
.      nr rhs \\n[len*[E]-\\n[start-range]
.      ds lhs \\*([E
.      ds rhs \\*([E
.      substring lhs 0 \\n[start-range]-1
.      substring rhs -(\\n[rhs]-1)
.      ds [E \\*[lhs]\\*[rhs]
.   \}
.   rm lhs
.   rm rhs
.   rr and-check
.   rr counter
.   rr start-range
.   rr end-range
.   rr len*[E
.\}
.\" End workaround
.ie !\\n[ref*type]=0 \{\
.   ie \\n([E>0 \{\
.      ie '\\*[$REF_STYLE]'NOTE' \{\
.         ie \\n([T .ref*field E "" "ed. "
.         el .ref*field E , "ed. "
.      \}
.      el \{\
.         ie \\n([T .ref*field E "" " Eds. "
.         el .ref*field E . " Eds. "
.      \}
.   \}
.   el \{\
.      ie '\\*[$REF_STYLE]'NOTE' \{\
.         ie \\n([T .ref*field E "" "ed. "
.         el .ref*field E , "ed. "
.      \}
.      el \{\
.         ie \\n([T .ref*field E "" " Ed. "
.         el .ref*field E . " Ed. "
.      \}
.   \}
.\}
.el \{\
.   ie \\n([T .ref*field E "" " "
.   el .ref*field E . " "
.\}
.rr [T
.rr [E
..
\# %e Edition
.de ref*add-e
.ie \\n([T .ref*field e "" "" " ed."
.el \{\
.   ie '\\*[$REF_STYLE]'NOTE' .ref*field e , "" " ed."
.   el .ref*field e . " " " ed."
.\}
.nr ref*suppress-period 1
.nr [e 1
.rr [T
..
\# %V Volume (of a journal, or series of books); for journals, %N may be preferable
.de ref*add-V
.if \\n[ref*type]=1 \
.   ref*field V
.if \\n[ref*type]=2 \{\
.   ie '\\*[$REF_STYLE]'NOTE' .ref*field V , "vol. "
.   el \{\
.      ie \\n([T .ref*field V "" " Vol. "
.      el .ref*field V . " Vol. "
.   \}
.\}
.if \\n[ref*type]=3 \{\
.   ie \\n([T .ref*field V "" " "
.   el .ref*field V . " "
.\}
.rr [T
..
\# %N Journal number
.de ref*add-N
.ref*field N
..
\# %S Series (books or journals)
.de ref*add-S
.if \\n[ref*type]=1 \
.   ref*field S
.if \\n[ref*type]=2 \{\
.   ie '\\*[$REF_STYLE]'NOTE' \{\
.      ie \\n([T .ref*field S
.      el .ref*field S ,
.   \}
.   el \{\
.      ie \\n([T .ref*field S "" " "
.      el .ref*field S . " "
.   \}
.\}
.if \\n[ref*type]=3 \{\
.   ie \\n([T .ref*field S "" " "
.   el .ref*field S . " "
.\}
.rr [T
\# refer doesn't set reg [T to 1 for series titles, so we do it here
.ds eval*[S \\*([S
.substring eval*[S -1
.if '\\*[eval*[S]'!' .nr [T 1
.if '\\*[eval*[S]'?' .nr [T 1
.rm eval*[S
..
\# %C City
.de ref*add-C
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie r [d \{\
.      ref*field C
.      rr [d
.   \}
.   el \
.      ref*field C "" \*[FU 2](
.   if \\n([T .nr ref*suppress-period \\n([T
.\}
.el \{\
.   ie \\n([T .ref*field C "" " "
.   el \{\
.      ie r [e .ref*field C "" " "
.      el .ref*field C . " "
.   \}
.\}
.rr [T
.rr [e
..
\# %I Publisher (I stands for Issuer)
.de ref*add-I
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie !'\\*([C'' .ref*field I :
.   el .ref*field I "" (
.\}
.el \{\
.   ie !'\\*([C'' .ref*field I :
.   el \{\
.      ie \\n([T .ref*field I "" " "
.      el .ref*field I . " "
.   \}
.\}
.rr [T
..
\# %D Date of publication
.de ref*add-D
.if \\n[ref*type]=0 \{\
.   ie '\\*[$REF_STYLE]'NOTE' .ref*field D ,
.   el .ref*field D . " "
.\}
.if \\n[ref*type]=1 \
.   ref*field D "" "(" ")"
.if \\n[ref*type]=2 \{\
.   ie '\\*[$REF_STYLE]'NOTE' .ref*field D , "" )
.   el .ref*field D ,
.\}
.if \\n[ref*type]=3 \{\
.   ie !'\\*([C'' \{\
.      ie '\\*[$REF_STYLE]'NOTE' .ref*field D , "" )
.      el .ref*field D ,
.   \}
.   el \{\
.      if '\\*([I'' \{\
.         ds eval*[D \\*([D
.         substring eval*[D 0 -4
.         ie '\\*[eval*[D]'1' .ds kern \*[BU3]
.         el .ds kern \*[BU2]
.         ie \\n[#PRINT_STYLE]=2 \
.           if '\\*[$REF_STYLE]'NOTE' .ref*field D "" (\\*[kern] )
.         el .ref*field D
.      \}
.      rm eval*[D
.      rm kern
.   \}
.\}
.if \\n[ref*type]=4 .ref*field D ,
.if \\n[ref*type]=5 .ref*field D
.ds eval*[D \\*([D
.substring eval*[D -1
.if '\\*[eval*[D]'.' .nr ref*suppress-period 1
..
\# %P Page number(s)
.de ref*add-P
.if \\n[ref*type]=5 .nr ref*type 1
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie \\n[ref*type]=1 .ref*field P : "" .
.   el .ref*field P "" "\|"
.   if \\n[ref*type]=1 .nr ref*suppress-period 1
.\}
.el \{\
.   ie \\n[ref*type]=1 .ref*field P \|:
.   el \{\
.      ie d [n .ref*field P . \| .
.      el .ref*field P . " "
.   \}
.\}
..
\# %G Gov't. ordering number
.de ref*add-G
.ie '\\*[$REF_STYLE]'NOTE' ref*field G ,
.el .ref*field G . " "
..
\# %O Other (info that goes after %T [or %B] but is hard to categorize; e.g., a dissertation)
.de ref*add-O
.ds eval*[O \\*([O
.substring eval*[O -1
.if '\\*[eval*[O]'.' .nr [O 1
.ds initial*cap \\*([O
.substring initial*cap 0 0
.ds [O*string \\*([O
.substring [O*string 1
.if '\\*[$REF_STYLE]'BIBLIO' \
.   ds [O \E*[UC]\\*[initial*cap]\E*[LC]\\*[[O*string]
.ie '\\*[$REF_STYLE]'NOTE' .ref*field O ,
.el \{\
.   if \\n([O=1 .chop [O
.   ie r [e .ref*field O "" " "
.   el \{\
.      ie !d [A .ref*field O
.      el .ref*field O . " "
.   \}
.\}
.rr [O
.rr [e
..
\# %n Annotations (after ref)
.de ref*add-n
.ds eval*[n \\*([n
.substring eval*[n -1
.if '\\*[eval*[n]'.' .chop [n
.if '\\*[eval*[n]'?' .nr [n 1
.if '\\*[eval*[n]'!' .nr [n 1
.ie '\\*[$REF_STYLE]'NOTE' .ref*field n ,
.el \{\
.   ie !'\\*([P'' .ref*field n "" " "
.   el .ref*field n . " "
.\}
.if r [n .nr ref*suppress-period 1
.rr [n
..
\#
.de ref*add-dflt
.ref*field \\$1 ,
..
\#
\# Book reprints
\# -------------
\# %d date of publication (the original date of publication)
.de ref*add-d
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ref*field d "" ( ;
.   nr [d 1
.\}
.el \{\
.   ie \\n([T .ref*field d "" " "
.   el .ref*field d . " "
.\}
.rr [T
..
\# %b main author when citing from a preface, introduction, foreword
\# or afterword
.de ref*add-b
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie \\n([T .ref*field b "" "by"
.   el .ref*field b , "by "
.\}
.el \{\
.   ie \\n([T .ref*field b "" " By "
.   el .ref*field b . " By "
.\}
.rr [T
..
\# %t title, if different from original title (the T field, which s/b
\# the original title)
.de ref*add-t
.ie '\\*[$REF_STYLE]'NOTE' .ref*field t , "rpt. of \E*[IT] " \E*[ref*restore-ss]
.el \{\
.   ie \\n([T .ref*field t "" " Rpt. of \E*[IT] " \E*[ref*restore-ss]
.   el .ref*field t . " Rpt. of \E*[IT] " \E*[ref*restore-ss]
.\}
.rr [T
..
\#
\# Translated works
\# ----------------
\# %l Trans(l)ator
.de ref*add-l
.ie '\\*[$REF_STYLE]'NOTE' \{\
.   ie \\n([T .ref*field l "" "trans. "
.   el .ref*field l , "trans. "
.\}
.el \{\
.   ie \\n([T .ref*field l "" " Trans. "
.   el .ref*field l . " Trans. "
.\}
.rr [T
..
\# %r Translato(r) and edito(r)
.de ref*add-r
.ie '\\*[$REF_STYLE]'NOTE' .ref*field r , "trans. and ed. "
.el \{\
.   ie \\n([T .ref*field r "" " Trans. and ed. "
.   el .ref*field r . " Trans. and ed. "
.\}
.rr [T
..
\#
\# Internet
\# --------
\# %s Site name
.de ref*add-s
.ie '\\*[$REF_STYLE]'NOTE' .ref*field s , \E*[IT] \E*[ref*restore-ss]
.el \{\
.ie \\n([s .ref*field s "" ".\E*[IT]" \E*[ref*restore-ss]
.el .ref*field s . " \E*[IT]" \E*[ref*restore-ss]
.\}
.\" refer doesn't set reg [T to 1 for these titles, so we do it here
.if !'\\*[$REF_STYLE]'NOTE' \{\
.   ds eval*[s \\*([s
.   substring eval*[s -1
.   rr [T
.   if '\\*[eval*[s]'.' .nr [T 1
.   if '\\*[eval*[s]'!' .nr [T 1
.   if '\\*[eval*[s]'?' .nr [T 1
.   rm eval*[s
.\}
..
\# %c content of site (ie. Web, Online posting, etc)
.de ref*add-c
.ie '\\*[$REF_STYLE]'NOTE' .ref*field c ,
.el \{\
.   ie \\n([T .ref*field c "" " "
.   el .ref*field c . " "
.\}
.rr [T
..
\# %o organization, group or sponsor of site
.de ref*add-o
.ie '\\*[$REF_STYLE]'NOTE' .ref*field o ,
.el \{\
.   ie \\n([T .ref*field o "" " "
.   el .ref*field o . " "
.\}
.rr [T
..
\# %a access date, i.e. the date you read it
.de ref*add-a
.ie '\\*[$REF_STYLE]'NOTE' .ref*field a ,
.el \{\
.   ie \\n([T .ref*field a "" " "
.   el .ref*field a . " "
.\}
.rr [T
..
\# %u URL
.de ref*add-u
.ref*field u "" < >
.rr [T
..
.de ref*add-z
.ref*field z
..
\#
\# Build up reference string from ref*add-<x> macros.
\#
\# First, a string to ensure next field's font is reset to roman
\# (TYPESET) or non-underlined (TYPEWRITE)
\#
.ie !n .ds ref*roman \f[R]\X'ps: exec decornone'\?\R'#UNDERLINE_ON 0'\?
.el .ds ref*roman \f[R]\?\R'#UNDERLINE_ON 0'\?
\#
.de ref*field
.if d ref*string \{\
.   ie d ref*post-punct \{\
.      as ref*string "\\$2\\*[ref*post-punct] \"
.      rm ref*post-punct
.   \}
.   el .as ref*string "\\$2 \"
.\}
.as ref*string "\\$3\\*([\\$1\\$4\E*[ref*roman]
.if \\n[.$]>4 .ds ref*post-punct "\\$5\E*[ref*roman]
.nr ref*suppress-period 0
..
\#
\# MARGIN NOTES
\# ------------
\#
\# Wrapper for MNinit.
\#
.MAC MN_INIT END
.    if \B'\\$2' \{\
.       tm1 "[mom]: 1.x-style \\$0 detected, but you are using v2.x.
.       tm1 "       v2.x requires flags before arguments to \\$0.
.       tm1 "       Please read docelement.html#mn-init and update your file.
.       ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.    \}
.    nr #ARGS  0 1
.    nr #COUNT 9
.    while \\n+[#ARGS]<=\\n[#COUNT] \
.      ds $MN-arg\\n[#ARGS] @
.    nr #FLAG 0 1
.    nr #COUNT \\n[#NUM_ARGS]
.    while \\n+[#FLAG]<=\\n[#COUNT] \{\
.       if '\\$1'RAGGED' \{\
.          ds $MN-arg1 \\$1
.       shift
.       \}
.       if '\\$1'SYMMETRIC' \{\
.          ds $MN-arg1 \\$1
.          shift
.       \}
.       if '\\$1'L_WIDTH' \{\
.          shift
.          ds $MN-arg2 \\$1
.          shift
.       \}
.       if '\\$1'R_WIDTH' \{\
.          shift
.          ds $MN-arg3 \\$1
.          shift
.       \}
.       if '\\$1'GUTTER' \{\
.          shift
.          ds $MN-arg4 \\$1
.          shift
.       \}
.       if '\\$1'FONTSTYLE' \{\
.          shift
.          ds $MN-arg5 \\$1
.          shift
.       \}
.       if '\\$1'SIZE' \{\
.          shift
.          ds $MN-arg6 \\$1
.          shift
.       \}
.       if '\\$1'LEAD' \{\
.          shift
.          ds $MN-arg7 \\$1
.          shift
.       \}
.       if '\\$1'COLOR' \{\
.          shift
.          ds $MN-arg8 \\$1
.          shift
.       \}
.       if '\\$1'HY' \{\
.          shift
.          ds $MN-arg9 \\$1
.          shift
.       \}
.    \}
.    if '\\*[$MN-arg5]'@' .ds $MN-arg5 \E*[$DOC_FAM]R
.    MNinit \
\\*[$MN-arg1] \\*[$MN-arg2] \
\\*[$MN-arg3] \\*[$MN-arg4] \
\\*[$MN-arg5] \\*[$MN-arg6] \
\\*[$MN-arg7] \\*[$MN-arg8] \
\\*[$MN-arg9]
.END
\#
.MAC MN_OVERFLOW_TRAP END
.    if \\n[#OVERFLOW_LEFT]=1 \{\
.       nr #no-repeat-MN-left 1
.       di MN_OVERFLOW_LEFT
.    \}
.    if \\n[#OVERFLOW_RIGHT]=1 \{\
.       nr #no-repeat-MN-right 1
.       di MN_OVERFLOW_RIGHT
.    \}
.    rr #OVERFLOW_LEFT
.    rr #OVERFLOW_RIGHT
.END
\#
\# The remainder of the margin notes macros and routines are adapted
\# from Werner Lemberg's MN.tmac.
\#
\# MNinit
\# ------
\# Usage:
\# MNinit [ragged|symmetric] \
\#        left-width right-width separation \
\#        font fontsize vertical-spacing \
\#        color hyphenation-flags
\#
\# Initialize margin notes.  Empty arguments (denoted with "") set
\# default values.  If the first argument is the string 'ragged',
\# left and right margin notes are printed ragged-right.  If it is
\# 'symmetric', left margin notes are printed ragged-left and right
\# margin notes ragged-right.  If omitted, margin notes are left
\# and right adjusted.
\#
.de MNinit
.  nr #MNinit 1
.  ds MN-left-ad b\"
.  ds MN-right-ad b\"
.  if '\\$1'@' .shift
.  if '\\$1'RAGGED' \{\
.    ds MN-left-ad l\"
.    ds MN-right-ad l\"
.    shift
.  \}
.  if '\\$1'SYMMETRIC' \{\
.    ds MN-left-ad r\"
.    ds MN-right-ad l\"
.    shift
.  \}
.  ie \B'\\$3' .nr MN-sep (n;\\$3)
.  el .nr MN-sep 1m
.  if ((\\n[.o] - \\n[MN-sep]) < 1n) \
.    ab MN: Left margin too small (<1n) for requested margin notes separation.
.  ie \B'\\$1' \{\
.    nr MN-left-width (n;\\$1)
.    nr MN-left-start (\\n[.o] - \\n[MN-sep] - \\n[MN-left-width])
.  \}
.  el \{\
.    nr MN-left-width (\\n[.o] - \\n[MN-sep])
.    nr MN-left-start 0
.  \}
.  if (\\n[MN-left-start] < 0) \
.    ab MN: Left margin too small for requested margin notes settings.
.  if (\\n[MN-left-width] < 1n) \
.    ab MN: Left margin notes width too small (<1n).
.  ie \B'\\$2' \{\
.    nr MN-right-width (n;\\$2)
.    nr MN-right-start (\\n[.o] + \\n[.l] + \\n[MN-sep])
.    if \\n[#COLUMNS]=1 \{\
.      if !\\n[#NUM_COLS]=1 \
.        nr MN-right-start (\\n[#COL_2_L_MARGIN] + \\n[#COL_L_LENGTH] + \\n[MN-sep])
.    \}
.  \}
.  el \{\
.    nr MN-right-width \\n[MN-left-width]
.    nr MN-right-start (\\n[.o] + \\n[.l] + \\n[MN-sep])
.    if \\n[#COLUMNS]=1 \{\
.      if !\\n[#NUM_COLS]=1 \
.        nr MN-right-start (\\n[#COL_2_L_MARGIN] + \\n[#COL_L_LENGTH] + \\n[MN-sep])
.    \}
.  \}
.  ie \A'\\$4' \{\
.    ds MN-font \\$4\"
.    if \\n[#PRINT_STYLE]=1 .ds MN-font CR
.  \}
.  el \{\
.    ds MN-font \\*[$PP_FT]
.    if \\n[#PRINT_STYLE]=1 .ds MN-font CR
.  \}
.  ie \B'\\$5' \{\
.    ps \\$5
.    nr MN-size \\n[.ps]
.    ps
.    if \\n[#PRINT_STYLE]=1 \{\
.       ps \\*[$TYPEWRITER_PS]
.       nr MN-size \\n[.ps]
.       ps
.    \}
.  \}
.  el \
.    nr MN-size \\n[#DOC_PT_SIZE]
.  ie \B'\\$6' \{\
'    vs \\$6
.    nr MN-spacing \\n[.v]
'    vs
.    if \\n[#PRINT_STYLE]=1 \
.       nr MN-spacing \\n[#DOC_LEAD]
.  \}
.  el .nr MN-spacing \\n[#DOC_LEAD]
.  ie \A'\\$7' \
.    if !\\n[#PRINT_STYLE]=1 .ds MN-color \\$7\"
.  el \
.    if !\\n[#PRINT_STYLE]=1 .ds MN-color
.  ie \B'\\$8' .nr MN-hy \\$8
.  el .nr MN-hy \\n[.hy]
.  ev MNbottom-left-env
.  if \A'\\*[MN-font]' .ft \\*[MN-font]
.  if \\n[MN-size] .ps \\n[MN-size]u
.  if \\n[MN-spacing] .vs \\n[MN-spacing]u
.  ll \\n[MN-left-width]u
.  ad \\*[MN-left-ad]
.  hy \\n[MN-hy]
'  in 0
.  nop \m[\\*[MN-color]]\c
.  ev
.  ev MNbottom-right-env
.  if \A'\\*[MN-font]' .ft \\*[MN-font]
.  if \\n[MN-size] .ps \\n[MN-size]u
.  if \\n[MN-spacing] .vs \\n[MN-spacing]u
.  ll \\n[MN-right-width]u
.  ad \\*[MN-right-ad]
.  hy \\n[MN-hy]
'  in 0
.  nop \m[\\*[MN-color]]\c
.  ev
.  nr MN-active 0
..
\# MN
\# --
\# Usage:
\#
\#   MN LEFT|RIGHT
\#   margin note text
\#   MN
\#
\# With a parameter, start a margin note, otherwise end a margin note.
\# If the parameter is the string 'left', define a left margin note,
\# otherwise define a right margin note.
\#
.de MN
. ds MN-dir \\$1
. if !'\\$1'LEFT' \{\
.   if !'\\$1'RIGHT' \{\
.     MN_QUIT
.     return
.   \}
. \}
. if \\n[#COLUMNS]=1 \{\
.  if \\n[#NUM_COLS]>2 \{\
.    tm [mom]: Macro MN: More than two columns.  Ignoring margin notes.
.    return
.  \}
.  if !\\n[#NUM_COLS]=1 \{\
.    ie \\n[#COL_NUM]=1 .ds MN-dir LEFT
.    el .ds MN-dir RIGHT
.  \}
. \}
.  if !\\n[#MNinit]=1 \{\
.    tm1 "[mom]: Macro MN: You must set parameters with MN_INIT before using MN.
.    ab   [mom]: Aborting '\\n[.F]' at MN, line \\n[.c].
.  \}
.  ie !'\\$1'' \{\
.    if \\n[MN-active] \{\
.      tm [mom]: Macro MN: Can't handle nested margin notes, line \\n[.c].
.      return
.    \}
.    nr MN-active 1
.    ev MN-env
.    ie '\\*[MN-dir]'LEFT' \{\
.      nr MN-left +1
.      ds MN-curr l-\\n[MN-left]\"
.      evc MNbottom-left-env
.    \}
.    el \{\
.      nr MN-right +1
.      ds MN-curr r-\\n[MN-right]\"
.      evc MNbottom-right-env
.    \}
.    mk MN-mk-\\*[MN-curr]
.    di MN-div-\\*[MN-curr]
.  \}
.  el .MN_QUIT
..
\#
\# MN_QUIT
\# -------
\# Utility macro to handle .MN OFF | QUIT | X etc
\#
.de MN_QUIT
.   if \\n[MN-active] \{\
.      br
.      di
.      nr MN-div-\\*[MN-curr]-depth \\n[dn]
.      ev
.   \}
.   nr MN-active 0
..
\#
\# MNtop
\# -----
\# Resets these registers (called in HEADER)
.de MNtop
.  nr MN-left 0
.  nr MN-right 0
.  nr MN-active 0
.  rr MN-shifted
.  ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
..
\#
\# MNbottom
\# --------
\# Executed in FOOTER.
\#
.de MNbottom
.   if '\\$0'MNbottom-left' \{\
.      ds MN-pos left
.      ds l-r l
.      ds Left-Right Left
.   \}
.   if '\\$0'MNbottom-right' \{\
.      ds MN-pos right
.      ds l-r r
.      ds Left-Right Right
.   \}
.   nr MN-curr 0
.   nr MN-last-pos 0
.   nr MN-lead-adj \\n[#DOC_LEAD]-\\n[MN-spacing]
.   vpt 0
.   if \\n[MN-active] \{\
.     di
.     tm [mom]: Macro MN: Margin note finished by new page.  Ignored.
.   \}
.   if \\n[#RECTO_VERSO] \{\
.      if e \{\
.         if '\\*[MN-pos]'right' \
.            nr MN-\\*[MN-pos]-start (\\n[.o]+\\n[.l]+\\n[MN-sep])
.         if '\\*[MN-pos]'left' \
.            nr MN-\\*[MN-pos]-start (\\n[.o]-\\n[MN-sep]-\\n[MN-left-width])
.      \}
.   \}
.   po \\n[MN-\\*[MN-pos]-start]u
.   ev MNbottom-\\*[MN-pos]-env
.   nr #P \\n%+\\n[#PAGE_NUM_ADJ]
.   while (\\n[MN-curr] < \\n[MN-\\*[MN-pos]]) \{\
.      nr MN-curr +1
.      ie (\\n[MN-last-pos] < \\n[MN-mk-\\*[l-r]-\\n[MN-curr]]) \
.         sp |\\n[MN-mk-\\*[l-r]-\\n[MN-curr]]u+\\n[MN-lead-adj]u
.      el \{\
.         nr MN-shifted 1
.         sp 1v
.         SHIM
.         if \\n[#SHIM]>\\n[MN-spacing] .sp -(1v+\\n[MN-lead-adj]u)
.         tm [mom]: Macro MN: Warning: \\*[Left-Right] margin note #\\n[MN-curr] on page \\n[#P] shifted down.
.      \}
.\" If last margin note doesn't fit
.      if ( (\\n[nl]+\\n[MN-div-\\*[l-r]-\\n[MN-curr]-depth]) > (\\n[.p]+\\n[#VARIABLE_FOOTER_POS]-1) ) \{\
.         if \\n[MN-shifted]=1 \{\
.            sp -(1v+\\n[#SHIM]u)
.            rm MN-div-\\*[l-r]-\\n[MN-curr]
.            tm1 "[mom]: \
No room to start \\*[MN-pos] margin note #\\n[MN-curr] on page \\n[#P].
.            tm1 "      Ignoring margin note.
.            rr MN-shifted
.         \}
.         nr #no-repeat-MN-\\*[MN-pos] 1
.         if '\\*[MN-pos]'left'  .nr #OVERFLOW_LEFT 1
.         if '\\*[MN-pos]'right' .nr #OVERFLOW_RIGHT 1
.         ie \\n[#FN_COUNT]=0 \{\
.            ch FOOTER \\n[.p]u
.            wh \\n[#VARIABLE_FOOTER_POS]u+\\n[MN-lead-adj]u+1u MN_OVERFLOW_TRAP
.         \}
.         el \
.            wh \\n[.p]u+\\n[#VARIABLE_FOOTER_POS]u-1u MN_OVERFLOW_TRAP
.         vpt
.      \}
.      nf
.      MN-div-\\*[l-r]-\\n[MN-curr]
.      fi
.      br
.      nr MN-last-pos \\n[nl]
.   \}
.   ev
.   po
.   if !\\n[#no-repeat-MN-\\*[MN-pos]]=1 .vpt
..
.
.ALIAS MNbottom-right MNbottom
.ALIAS MNbottom-left  MNbottom
\#
\# PDF SUPPORT
\# ===========
\#
\# Initial setup
\#
.nr CURRENT_LEVEL 0
.nr VIRTUAL_LEVEL 0
.nr #PDF_BOOKMARKS 1
.nr #PDF_BOOKMARKS_OPEN 1
.pdfview /PageMode /UseOutlines
\#
\# TOC_BEFORE_HERE
\# ---------------
\#
\# Call this and the TOC will be placed preceding this page
\#
.MAC TOC_BEFORE_HERE END
.    nr TOC_BH 1
.    pdfpagename MOM:TOC
.END
\#
\# TOC_AFTER_HERE
\# ---------------
\#
\# Call this and the TOC will be placed after this page
\#
.MAC TOC_AFTER_HERE END
.    nr TOC_BH 2
.    pdfpagename MOM:TOC
.END
\#
\# PDF_LINK_COLOR
\# -----------------
\#
\# Arguments:-
\#   <name defined by previous call to XCOLOR or NEWCOLOR> or
\#   <red> <green> <blue> all 0.0 -> 1.0
\# Notes
\#   Should be called before START but can also be called at any time to change colour
\#   The colour assigned at the end of the document is used for all links in the TOC
\#
.MAC PDF_LINK_COLOR END
.    ie \\n[.$]==3 \{\
.       ds PDFHREF.COLOUR \\$*
.       if !(\B'\\$1' & \B'\\$2' & \B'\\$3') \{\
.          tm1 "[mom]: All three arguments to \\$0 at line \\n[.c] must be decimal.
.          tm1 "       Continuing to process using default link color.
.          ds PDFHREF.COLOUR 0.0 0.3 0.9
.       \}
.       defcolor pdf:href.colour rgb \\*[PDFHREF.COLOUR]
.       ds PDFHREF.TEXT.COLOUR pdf:href.colour
.    \}
.    el \{\
.       ie \\n[.$]==0 \{\
.          if dPDFHREF.TEXTCOL.DEFAULT \
.             PDF_LINK_COLOR \\*[PDFHREF.TEXTCOL.DEFAULT]
.       \}
.       el \{\
.          ds ARG_1 \\$1
.          substring ARG_1 0 0
.          ie '\\*[ARG_1]'#' \{\
.             defcolor pdf:href.colour rgb \\$1
.             ds PDFHREF.TEXT.COLOUR pdf:href.colour
.          \}
.          el \{\
.             ie dCOLAL_\\$1 .ds PDFHREF.TEXT.COLOUR \\*[COLAL_\\$1]
.             el .ds PDFHREF.TEXT.COLOUR \\$1
.          \}
.       \}
.    \}
.    if !\\n[PDFHREF_COLOR_SET]=1 \
.       nr PDFHREF_COLOR_SET 1
.END
\#
.ALIAS PDF_LINK_COLOUR PDF_LINK_COLOR
\#
\# AUTO_RELOCATE_TOC
\# -----------------
\#
\# Call before START to have TOC automatically relocated to after the
\# DOC COVER (if there is one) or the COVER if there isn't
\#
.MAC AUTO_RELOCATE_TOC END
.    if '\\$1''                .nr TOC.RELOCATE 1
.    if '\\$1'TOP'             .nr TOC.RELOCATE 2
.    if '\\$1'BEFORE_DOCCOVER' .nr TOC.RELOCATE 3 \" Same as TOP unless no DOCCOVER
.    if '\\$1'AFTER_DOCCOVER'  .nr TOC.RELOCATE 4
.    if '\\$1'BEFORE_COVER'    .nr TOC.RELOCATE 5
.    if '\\$1'AFTER_COVER'     .nr TOC.RELOCATE 6
.END
\#
.ALIAS AUTO_TOC_RELOCATE AUTO_RELOCATE_TOC
\#
\# PDF_BOOKMARK
\# ------------
\# *Argument:
\#   Hierarchy Level
\#   Bookmark Text
\# *Function:
\#   Creates a bookmark using the given text
\#   The level controls the hierarchy of the bookmarks
\# *Notes
\#   Bookmarks can be turned off (will not be added to document outline) by calling
\#   "PDF_BOOKMARKS NO" and turned on with "PDF_BOOKMARKS".
\#
\#   Bookmarks can be open or closed by calling PDF_BOOKMARKS_OPEN
\#
.MAC PDF_BOOKMARK END
.    if \\n[#PDF_BOOKMARKS] \{\
.       ie '\\$1'NAMED' \{\
.          ds PDF_NM -T \\$2
.          ds PDF_NM2 \\$2
.          shift 2
.       \}
.       el .ds PDF_NM
.       nr LEVEL_REQ \\$1
.       shift
.       ie \\n[LEVEL_REQ]>\\n[VIRTUAL_LEVEL] \{\
.          nr VIRTUAL_LEVEL \\n[LEVEL_REQ]
.          nr LEVEL_REQ \\n[CURRENT_LEVEL]+1
.       \}
.       el \{\
.          ie \\n[LEVEL_REQ]<\\n[VIRTUAL_LEVEL] \{\
.             nr VIRTUAL_DIFF \\n[VIRTUAL_LEVEL]-\\n[LEVEL_REQ]
.             nr VIRTUAL_LEVEL \\n[LEVEL_REQ]
.             nr LEVEL_REQ (\\n[CURRENT_LEVEL]-\\n[VIRTUAL_DIFF])>?1
.          \}
.          el .nr LEVEL_REQ \\n[CURRENT_LEVEL]
.       \}
.       ds PDF_TX \\$*
.       pdfmomclean PDF_TX
.       nr PDF_LEV (\\n[LEVEL_REQ]*\\n[#PDF_BOOKMARKS_OPEN])
.       ie '\\*[.T]'ps' \{\
.           if !'\\*[PDF_NM]'' \{\
.              pdfhref M -N \\*[PDF_NM2] -- \\*[PDF_TX]
.              if !dpdf:href.map .tm gropdf-info:href \\*[PDF_NM2] \\*[PDF_TX]
.           \}
.           pdfbookmark \\n[PDF_LEV] \\*[PDF_TX]
.       \}
.       el .pdfbookmark \\*[PDF_NM] \\n[PDF_LEV] \\$*
.       nr CURRENT_LEVEL \\n[LEVEL_REQ]
.       rr LEVEL_REQ
.       rr PDF_LEV
.       rr VIRTUAL_DIFF
.       rm PDF_NM
.    \}
.END
\#
\# PDF_TITLE
\# ---------
\# *Argument:
\#   Title Text
\# *Function
\#   Set the PDF title (this is often used by PDF readers to title the main window)
\#
.MAC PDF_TITLE END
.    ds pdftitle \\$*
.    pdfmomclean pdftitle
.    nop \!x X ps:exec [/Title (\\*[pdftitle]) /DOCINFO pdfmark
.END
\#
\# PDF_BOOKMARKS
\# -------------
\# *Argument:
\#   <nothing> | <anything>
\# *Function:
\#   With no parameter turns on outline bookmarks
\#   With any parameter turns off outline bookmarks
\#
.MAC PDF_BOOKMARKS END
.    ie '\\$1'' .nr #PDF_BOOKMARKS 1
.    el .nr #PDF_BOOKMARKS 0
.END
\#
\# PDF_BOOKMARKS_OPEN
\# ------------------
\# *Argument:
\#   <number> | <nothing> | <text>
\# *Function:
\#   If arg is numeric all Bookmark levels > arg are closed
\#   If arg is empty all bookmarks are open
\#   If arg is any text then any following bookmarks are closed
\#
.MAC PDF_BOOKMARKS_OPEN END
.    ie \B'\\$1' \{\
.       nr PDFOUTLINE.FOLDLEVEL \\$1
.       nr #PDF_BOOKMARKS_OPEN 1
.    \}
.    el .if '\\*[.T]'pdf' \{\
.       nr PDFOUTLINE.FOLDLEVEL 10000
.       ie '\\$1'' .nr #PDF_BOOKMARKS_OPEN 1
.       el .nr #PDF_BOOKMARKS_OPEN 0-1
.    \}
.END
\#
\# PDF_LINK
\# --------
\# *Arguments:
\#    $1 = named link
\#    [PREFIX text] : text to prefix link
\#    [SUFFIX text] : text after link
\#    text
\#
\# *Notes
\#    Text is output as a hotspot link to named destination.
\#    If text has final '*' it is replaced with the text associated with the link
\#
.MAC PDF_LINK END
.    ds PDF_NM \\$1
.    shift
.    ie '\\$1'PREFIX' \{\
.       ds PDF_PRE -P "\&\\$2"
.       shift 2
.    \}
.    el .ds PDF_PRE
.    ie '\\$1'SUFFIX' \{\
.       ds PDF_POST -A "\\$2"
.       shift 2
.    \}
.    el .ds PDF_POST
.    ds PDF_AST_Q
.    ds PDF_TXT \&\\$1
.    ds PDF_AST \\*[PDF_TXT]
.    substring PDF_AST -1 -1
.    if '\\*[PDF_AST]'+' \{\
.       ds PDF_AST *
.       ds PDF_AST_Q ""
.    \}
.    if '\\*[PDF_AST]'*' \{\
.        chop PDF_TXT
.        ie '\\*[.T]'pdf' \{\
.           ie d pdf:look(\\*[PDF_NM]) \
.               as PDF_TXT \&\\*[PDF_AST_Q]\\*[pdf:look(\\*[PDF_NM])]\\*[PDF_AST_Q]
.           el \{\
.               as PDF_TXT Unknown
.               if !rPDF_UNKNOWN .tm \
\\n[.F]:\\n[.c]: forward reference detected (please run using 'pdfmom')
.               nr PDF_UNKNOWN 1
.           \}
.        \}
.        el \{\
.            ie d pdf:href(\\*[PDF_NM]).info \
.               as PDF_TXT \&\\*[PDF_AST_Q]\\*[pdf:href(\\*[PDF_NM]).info]\\*[PDF_AST_Q]
.            el .as PDF_TXT Unknown
.       \}
.    \}
.    pdfhref L \\*[PDF_PRE] \\*[PDF_POST] -D \\*[PDF_NM] -- \\*[PDF_TXT]
.    rm PDF_NM
.    rm PDF_PRE
.    rm PDF_POST
.    rm PDF_TXT
.    rm PDF_AST
.    rm PDF_AST_Q
.END
\#
.MAC PDF_WWW_LINK END
.    ds PDF_NM \\$1
.    shift
.    ie '\\$1'PREFIX' \{\
.       ds PDF_PRE -P "\\$2"
.       shift 2
.    \}
.    el .ds PDF_PRE
.    ie '\\$1'SUFFIX' \{\
.       ds PDF_POST -A "\\$2"
.       shift 2
.    \}
.    el .ds PDF_POST
.    ds PDF_AST_Q
.    ds PDF_TXT \\$1
.    ie !'\\*[PDF_TXT]'' \{\
.       ds PDF_AST \\*[PDF_TXT]
.       substring PDF_AST -1 -1
.       if '\\*[PDF_AST]'+' \{\
.          ds PDF_AST *
.          ds PDF_AST_Q ""
.       \}
.       if '\\*[PDF_AST]'*' \{\
.          chop PDF_TXT
.          as PDF_TXT \&\\*[PDF_AST_Q]\\*[PDF_NM]\\*[PDF_AST_Q]
.       \}
.    \}
.    el .ds PDF_TXT \\*[PDF_NM]
.    pdfhref W -D "\\*[PDF_NM]" \\*[PDF_PRE] \\*[PDF_POST] -- \\*[PDF_TXT]
.    rm PDF_NM
.    rm PDF_PRE
.    rm PDF_POST
.    rm PDF_TXT
.    rm PDF_AST PDF_AST_Q
.END
\#
.MAC PDF_TARGET END
.    ds ARG_1 \\$1
.    shift
.    ie '\\$*'' .pdfhref M -N \\*[ARG_1] -- \\$*
.    el .pdfhref M -N \\*[ARG_1] -E -- \\$*
.    if '\\*[.T]'ps' .if !dpdf:href.map .tm gropdf-info:href \\*[ARG_1] \\$*
.END
\#
\# PDF_IMAGE
\# ---------
\# *Arguments:
\#   [ -L -| -R | -C | -I <indent> ] \
\#     <image file> <width> <height> \
\#     [ SCALE <factor> ] [ ADJUST +|-<vertical shift> ] [ TARGET <pdf target> ] \
\#     [ NO_SHIM ] [ NO_FLEX ]
\# *Function:
\#   Allows embedding of PDF images with the same arguments as PSPIC
\#   plus SCALE and ADJUST options.
\# *Notes:
\#   <image file> <width> <height> are required.
\#
.MAC PDF_IMAGE END
.    if !'\\n[.z]'FLOAT*DIV' \{\
.       nr pdf-img:float 1
.       FLOAT
.       PDF_TARGET fig:\\n+[lists*target]
.    \}
.    nr float*img 1
.    ds ev-current \\n[.ev]
.    ev IMG
.    evc \\*[ev-current]
.    if \\n[#HYPHENATE] .nh
.    nr ind-pre-img \\n[.i]
.    nr ll-pre-img  \\n[.l]
.    in 0
.    ds pos:tmp \\$1
.    substring pos:tmp 0 0
.    ie !'\\*[pos:tmp]'-' .ds pdf-img:pos -C
.    el \{\
.       ds pdf-img:pos \\$1
.       shift
.    \}
.    if '\\*[pdf-img:pos]'-I' \{\
.       nr pdf-img:ind \\$1
.       shift
.    \}
.    ds pdf-img:file \\$1
.    ds pdf-img@file \\$1
.    substring pdf-img@file -1 -3
.    if !'\\*[pdf-img@file]'pdf' \{\
.       tm1 "[mom]: Image file '\\*[pdf-img:file]' at line \\n[.c] not found, or not a PDF image.
.       ab   [mom]: Aborting '\\n[.F]' at \\$0, line \\n[.c].
.    \}
.    nr pdf-img:width \\$2
.    nr pdf-img:depth \\$3
.    shift 3
.    nr loop-counter \\n[#NUM_ARGS]
.    nr loop-count 0 1
.    while \\n+[loop-count]<=\\n[loop-counter] \{\
.       if '\\$1'SCALE' \{\
.          shift
.          nr pdf-img:scale \\$1
.          shift
.          nr pdf-img:width \\n[pdf-img:width]*\\n[pdf-img:scale]/100
.          nr pdf-img:depth \\n[pdf-img:depth]*\\n[pdf-img:scale]/100
.       \}
.       if '\\$1'ADJUST' \{\
.         shift
.         ds pdf-img:adj \\$1
.         shift
.       \}
.       if '\\$1'FRAME' \{\
.          nr pdf-img:frame 1
.          if !r pdf-img:frame-inset .nr pdf-img:frame-inset 6p
.          shift
.       \}
.       if '\\$1'CAPTION' \{\
.          nr pdf-img*have-caption 1
.          ds pdf-img*caption \\$2
.          shift 2
.       \}
.       if '\\$1'SHORT_CAPTION' \{\
.          ds pdf-img*caption-short \\$2
.          shift 2
.       \}
.       if '\\$1'LABEL' \{\
.          nr pdf-img*have-label 1
.          ds pdf-img*label \\$2
.          ds label-type pdf-img
.          shift 2
.       \}
.       if '\\$1'TARGET' \{\
.          ds target "\\$2
.          PDF_TARGET "\\*[target]
.          shift 2
.       \}
.       if '\\$1'NO_SHIM' \{\
.          if !'\\n[.z]'FLOAT*DIV' .nr pdf-img*no-shim 1
.          nr @no-shim 1
.          shift 1
.       \}
.       if '\\$1'NO_FLEX' \{\
.          nr pdf-img*no-flex 1
.          nr @no-flex 1
.          shift 1
.       \}
.    \}
.    if (\\n[pdf-img*have-label]=1):(\\n[pdf-img*autolabel]=1) \
.       ds label-type pdf-img
.    if !'\\*[pdf-img*label-sffx]'' \{\
.       ds pdf-img*label-sffx-tmp \\*[pdf-img*label-sffx]
.       substring pdf-img*label-sffx-tmp -1
.       if '\\*[pdf-img*label-sffx-tmp]'.' \
.          if \\n[pdf-img*caption-after-label]=0 .chop pdf-img*label-sffx
.    \}
.    if '\\*[pdf-img:pos]'-C' \
.       nr pdf-img:ind (\\n[.ll]-\\n[ind-pre-img]-\\n[pdf-img:width])/2
.    if '\\*[pdf-img:pos]'-R' \
.       nr pdf-img:ind \\n[.ll]-\\n[pdf-img:width]-\\n[ind-pre-img]
.    if \\n[pdf-img*label-with-chapter] \
.       ds chapno \\n[#CH_NUM].
.    if \\n[pdf-img*autolabel] \{\
.       ds pdf-img*label \\*[pdf-img*label-prfx]\\*[chapno]\\n+[fig*label-num]\\*[pdf-img*label-sffx]
.       nr fig*label-width \w'\\*[pdf-img*label]'
.       nr fig*label-num -1
.    \}
.    if !'\\*[pdf-img*caption-short]'' .ds short -short
.    if \\n[#PDF_BOOKMARKS] \{\
.       ie (\\n[pdf-img*have-label]=1):(\\n[pdf-img*autolabel]=1) \{\
\!.        TO_FIGURES "\\*[pdf-img*label]" "\\*[pdf-img*caption\\*[short]]"
.       \}
.       el \{\
\!.        if !'\\*[pdf-img*caption\\*[short]]'' \
\!.           TO_FIGURES "\\*[pdf-img*caption\\*[short]]"
.       \}
.    \}
.    di PDF*IMAGE
.    if \\n[@TOP] \{\
.       ch RR_@TOP
.       rs
.       nop \&
.       sp -1v
.    \}
.    if \\n[pdf-img*have-caption] \{\
.       if !\\n[pdf-img*autolabel] \{\
.          if !\\n[pdf-img*have-label] \{\
.             if \\n[#MLA] \
.                mla@error caption label \\n[.F] \\$0 \\n[.c]
.          \}
.       \}
.       if !\\n[pdf-img*caption-after-label] \{\
.          if !\\n[@TOP] .sp .5v
.          nr lead-pre-caption \\n[.v]
.          ev caption
.          evc IMG
.          ie \\n[#PRINT_STYLE]=1 .TYPEWRITER
.          el \{\
.             img*caption-style
.             vs \\n[.ps]u+\\n[pdf-img*caption-autolead]u
.          \}
.          PDF_IMG*SET_CAPTION_QUAD \\*[pdf-img*caption-quad]
.          nr pdf-img*caption-top-lead-diff \\n[lead-pre-caption]-\\n[.v]
.          sp \\n[lead-pre-caption]u-\\n[.v]u
.          nop \\*[pdf-img*caption]
.          br
.          if !'\\*[pdf-img*caption-space]'' .sp \\*[pdf-img*caption-space]
.          ev
.          in 0
.          sp -.5v
.       \}
.    \}
.    nf
.    if \\n[pdf-img:frame] \{\
.       nr frame-width \\n[pdf-img:width]+(\\n[pdf-img:frame-inset]*2)
.       nr frame-depth \\n[pdf-img:depth]+(\\n[pdf-img:frame-inset]*2)
.       if '\\*[pdf-img:pos]'-L' \{\
.          nr pdf-img:ind \\n[pdf-img:frame-inset]
.          nr pdf-img:dbx-ind 0
.       \}
.       if '\\*[pdf-img:pos]'-C' \{\
.          nr pdf-img:dbx-ind \
\\n[.ll]-\\n[ind-pre-img]-\\n[pdf-img:width]/2-\\n[pdf-img:frame-inset]
.       \}
.       if '\\*[pdf-img:pos]'-R' \{\
.          nr pdf-img:ind -\\n[pdf-img:frame-inset]
.          nr pdf-img:dbx-ind \
\\n[.l]u-(\\n[pdf-img:width]u+(\\n[pdf-img:frame-inset]u*2u)+\\n[ind-pre-img]u)
.       \}
.       if '\\*[pdf-img:pos]'-I' \{\
.          nr pdf-img:ind +\\n[pdf-img:frame-inset]
.          nr pdf-img:dbx-ind \\n[pdf-img:ind]-\\n[pdf-img:frame-inset]
.       \}
.       DBX \\*[pdf-img:frame-weight] \
            \\n[pdf-img:dbx-ind]u \
            \\n[frame-width]u \
            \\n[frame-depth]u \
            \\*[pdf-img:frame-color]
.       sp \\n[pdf-img:frame-inset]u
.       nr pdf-img:ind -\\n[pdf-img:frame-inset]
.    \}
.    ti \\n[pdf-img:ind]u+\\n[pdf-img:frame-inset]u
.    nop \X'pdf: pdfpic \\*[pdf-img:file] -L \\n[pdf-img:width]z \\n[pdf-img:depth]z'
.    if '\\*[pdf-img:pos]'-C' .nr pdf-img:ind +\\n[pdf-img:frame-inset]
.    sp \\n[pdf-img:depth]u
.    if \\n[pdf-img:frame] .sp \\n[pdf-img:frame-inset]u
.    if (\\n[pdf-img*have-label]=1):(\\n[pdf-img*autolabel]=1):(\\n[pdf-img*caption-after-label]=1) \{\
.       if \\n[#MLA] \{\
.          if (\\n[pdf-img*have-label]=1):(\\n[pdf-img*autolabel]=1) \{\
.             if !\\n[pdf-img*have-caption] \
.                mla@error label caption \\n[.F] \\$0 \\n[.c]
.          \}
.       \}
.       nr lead-pre-label \\n[.v]
.       ev label
.       evc IMG
.       ie \\n[#PRINT_STYLE]=1 .TYPEWRITER
.       el \{\
.          img*label-style
.          vs \\n[.ps]u+\\n[pdf-img*label-autolead]u
.       \}
.       if \\n[pdf-img*label-with-chapter] \
.          ds chapno \\n[#CH_NUM].
.       PDF_IMG*SET_LABEL_QUAD \\*[pdf-img*label-quad]
.       sp \\n[lead-pre-label]u-\\n[.v]u
.       if !'\\*[pdf-img*label-space]'' .sp \\*[pdf-img*label-space]
.       ie \\n[pdf-img*autolabel] \{\
.          nop \
\\*[pdf-img*label-prfx]\\*[chapno]\\n+[fig*label-num]\\*[pdf-img*label-sffx]\|
.          ds pdf-img*label \\*[chapno]\\n[fig*label-num]
.          if dLABEL.REFS \
.             tm .ds \\*[target] \\*[chapno]\\n[fig*label-num]
.          rm target
.       \}
.       el .if !'\\*[pdf-img*label]'' .nop \\*[pdf-img*label]
.       fam
.       ft
.       ps
.       gcolor
.       if !'\\*[pdf-img*caption]'' \{\
.          if \\n[pdf-img*caption-after-label] \{\
.             ds pdf-img*caption-old \\*[pdf-img*caption]
.             ds pdf-img*caption " \\*[pdf-img*caption]
.             nop \\*[pdf-img*caption-specs]\\*[pdf-img*caption]\\*[revert-specs]
.             ds pdf-img*caption \\*[pdf-img*caption-old]
.          \}
.       \}
.       br
.       ev
.       in 0
.    \}
\!.  in
.    di
.    nf
.    vpt 0
.    if !'\\*[pdf-img:adj]'' \{\
.       if \\n[@TOP] \
.          if \\n[#COLUMNS]>1 \
\!.           rs
\!.     sp \\*[pdf-img:adj]
.    \}
.    PDF*IMAGE
.    if !'\\*[pdf-img:adj]'' \
.       if !\\n[@TOP] \!.sp -\\*[pdf-img:adj]
.    vpt
.    ev
.    if \\n[pdf-img:float] \{\
.       FLOAT off
.       nr dl \\n[pdf-img:width]
.    \}
.    if !\\n[pdf-img:float] \{\
.       ie !\\n[#NO_SHIM] \
.          if !\\n[pdf-img*no-shim] .SHIM
.       el \
.          if !\\n[#NO_FLEX] \
.             if !\\n[pdf-img*no-flex] .FLEX
.    \}
.    PDF_IMAGE_CLEAN 
.END
\#
\# PDF_IMAGE_FRAME
\# ---------------
\# *Arguments:
\#   [ <inset> ] [ <rule weight> ] [ <color> ]
\# *Function:
\#   Sets parameters for pdf image frames.
\# *Notes:
\#   Defaults are '6p' '.5' 'black'.  Arguments to be left at default
\#   must be entered as "".
\#
.MAC PDF_IMAGE_FRAME END
.    ie !'\\$1''\{\
.       ds frame-arg \\$1
.       substring frame-arg -1
.       ie \B'\\*[frame-arg]' \{\
.          tm1 "[mom]: \\$0 inset argument at line \\n[.c]
.          tm1 "       of '\\n[.F]' requires a unit of measure.
.          tm1 "       Default 6 point inset will be used instead.
.       \}
.       el \{\
.          nr pdf-img:frame-inset \\$1
.          shift
.       \}
.    \}
.    el .shift
.    ie !'\\$1'' \{\
.       ds frame-arg \\$1
.       substring frame-arg -1
.       ie \B'\\*[frame-arg]' \{\
.          ds pdf-img:frame-weight \\$1
.          shift
.       \}
.       el \{\
.          ds frame-arg \\$1
.          substring frame-arg -1 
.          length arg-len \\*[frame-arg]
.          if \\n[arg-len]=1 \{\
.             tm1 "[mom]: \\$0 rule weight argument at line \\n[.c]
.             tm1 "       of '\\n[.F]' must not have a unit of measure appended.
.             tm1 "       Default .5 rule weight will be used instead.
.             shift
.          \}
.       \}
.    \}
.    el .shift
.    if !'\\$1'' \{\
.       ie m \\$1 .ds pdf-img:frame-color \\$1
.       el \{\
.          tm1 "[mom]: \\$0 color argument '\\$1' at line \\n[.c]
.          tm1 "       of '\\n[.F]' is not a valid color.
.          tm1 "       Default black will be used instead.
.       \}
.    \}
.END
\#
.MAC PDF_IMAGE_CLEAN END
.    rm PDF*IMAGE
.    rm pdf-img:adj
.    rm pdf-img*caption
.    rm pdf-img*caption-short
.    rm pdf-img:file
.    rm pdf-img*label
.    rm pdf-img:pos
.    rm short
.    rr ind-pre-img
.    rr pdf-img:depth
.    rr pdf-img:float
.    if !\\n[pdf-img:frame] \
.       rr pdf-img:frame
.    rr pdf-img:ind
.    rr pdf-img:no-shim
.    rr pdf-img:no-flex
.    rr pdf-img:scale
.\" Cutarounds not yet implemented
.    if !\\n[defer] \
.       if !\\n[cutaround] \
.          rr pdf-img*have-caption
.    if !\\n[cutaround] \{\
.       rr pdf-img:frame-inset
.       rr pdf-img:width
.    \}
.    if '\\*[pdf-img*label-sffx-tmp]'.' .ds pdf-img*label-sffx .
.END
\#
.de pdfmomclean
.   ie '\\n[.z]'' \{\
.      ds pdfcleaned \\$*
.      ev pdfcln
.      tr \[em]-
.      nf
.      box pdf:clean
.      nop \\*[\\*[pdfcleaned]]
.      fl
.      box
.      chop pdf:clean
.      asciify pdf:clean
.      ev
.      ds \\*[pdfcleaned] "\\*[pdf:clean]
.      rm pdf:clean
.      tr \[em]\[em]
.    \}
.    el .nop \!.pdfmomclean \\$@
..
\#
.MAC PAUSE END
.    vpt 0
.    br
.    vpt
.    ie !'\\n[.z]'' \{\
\!.     pdfpause
\!.     pdftransition BLOCK \\$1
.    \}
.    el \{\
.       pdfpause
.       pdftransition BLOCK \\$1
.    \}
.END
\#
.MAC TRANSITION END
.    ie !'\\n[.z]'' \
\!.     pdftransition PAGE \\$1
.    el .pdftransition PAGE \\$1
.END
\#
\# Local Variables:
\# mode: nroff
\# End:
\# vim: filetype=groff:
